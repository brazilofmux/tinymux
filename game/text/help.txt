& help
  This is the MUX online help facility.
 
     Notes on help descriptions: 
        [text] - Text enclosed in []'s is optional.  The []'s are never typed
                 in as part of the command.
        <parameter> - Information parameter for a command.  The <>'s are
                      never typed in as part of the command.
 
  -  Syntax of help command:
       help [<command>]
 
  -  To get a list of MUX topics:
       help topics 
 
  -  To get a list of Comsystem commands:
       help comsys
  
  -  To get a list of MUX Commands:
       help commands      (or @list commands)
 
  Some of the configuration shown in the help.txt might not be the same as
  the configuration of this MUX. If you notice any errors, contact an Admin.

& commands

  Help available for MUX Commands:
  Note: Some commands are @-related.
 
  drop         enter        examine      get          give         goto
  help         inventory    kill         leave        LOGOUT       look
  move         news         OUTPUTPREFIX OUTPUTSUFFIX page         pose
  QUIT         read         say          score        SESSION      take
  think        throw        use          version      whisper      WHO
  "            :            ;            &            #            \\
 
  @@           @cemit       @chown       @chzone      @clone       @cpattr
  @create      @decompile   @destroy     @dig         @doing       @dolist
  @drain       @edit        @emit        @entrances   @femit       @find
  @force       @fpose       @fsay        @halt        @last        @link
  @list        @listmotd    @lock        @mail        @mvattr      @name
  @notify      @npemit      @oemit       @open        @parent      @password
  @pemit       @power       @program     @ps          @quitprogram @quota
  @remit       @robot       @search      @set         @stats       @sweep
  @switch      @teleport    @trigger     @unlink      @unlock      @verb
  @wait        @wipe       
 
{ 'help commands2' for more }

& commands2

  Help available for MUX Commands (continued):
 
  @aahear      @aclone      @aconnect    @adescribe   @adfail      @adisconnect
  @adrop       @aefail      @aenter      @afail       @agfail      @ahear
  @akill       @aleave      @alfail      @alias       @amail       @amhear
  @amove       @apay        @arfail      @asuccess    @atfail      @atofail
  @atport      @aufail      @ause        @away        @charges     @cost
  @daily       @describe    @dfail       @drop        @ealias      @efail
  @enter       @fail        @filter      @forwardlist @gfail       @idesc
  @idle        @idletimeout @infilter    @inprefix    @kill        @lalias
  @leave       @lfail       @listen      @mailsucc    @move        @odescribe
  @odfail      @odrop       @oefail      @oenter      @ofail       @ogfail
  @okill       @oleave      @olfail      @omove       @opay        @orfail
  @osuccess    @otfail      @otofail     @otport      @oufail      @ouse
  @oxenter     @oxleave     @oxtport     @pay         @prefix      @reject
  @rfail       @runout      @sex         @signature   @startup     @success
  @tfail       @tofail      @tport       @ufail       @use

& topics

  Help available on the following Topics:
 
  ARBITRARY COMMANDS  ATTRIBUTE OWNERSHIP BEING KILLED        BOGUS COMMANDS
  BOOLEAN VALUES      COMMAND EVALUATION  COMSYS              CONTROL 
  COSTS               CREDITS             DROP-TO             ENACTOR
  EXITS               FAILURE             FLAG LIST           FLAGS 
  FUNCTION LIST       FUNCTIONS           GENDER              GOALS 
  HERE                HOMES               LINKING             LISTENING
  LISTS               LOOPING             ME                  MONEY
  MOVING              OBJECT STACK        OBJECT TYPES        PARENT OBJECTS
  PARENT ROOMS        PIPING              POWERS LIST         PUEBLO
  PUPPETS             REGEXPS             ROBBERY             SEARCH CLASSES
  SEMAPHORES          SPOOFING            STACK               SUBSTITUTIONS
  SUCCESS             SWITCHES            VERBS               WIZARDS
  ZONE OBJECTS

& PIPING
 
  Command piping in MUX is similar to piping in a UNIX shell. You string two
  or more commands together using the ;| symbol, much as you would using a
  semicolon. The output from the previous command in a pipe is accessable
  using the %| substitution. This output contains the raw ASCII codes that
  would normally be directly output to your terminal. You may use the
  translate() function to either convert the raw characters in the output to
  MUX substitutions, or strip them out altogether. Like the semicolon, the ;|
  symbol in MUX is taken literally if you type it on the terminal. Currently
  you may only pipe 20 commands in a row.
 
  Examples:
  > &MAILDESC me=$+maildesc *=*:look %0 ;| @mail/quick
                  %1/Description=[translate(%|,1)]

  > &SAYDESC me=$+saydesc *:look %0 ;| say %r%|
  > +saydesc me
  You say "
  Lauren(#5PXMWc)
  You see nothing special.
  "
 
  See also: translate().
 
& PUEBLO
 
  Details on Pueblo support in TinyMUX:
 
  @VRML_URL is the URL of a VRML scene for a particular room.
  @HTDesc is an alternate description for players who are logged in using
       Pueblo.
  @pemit/html and @emit/html allow outputting unescaped HTML strings.
  Please see http://www.chaco.com/pueblo/doc/enhancing.html for more
  details.
 
& ZONE OBJECTS

  ZONE OBJECTS
 
  Zones are areas of the MUX which may be controlled by many people.
  Essentially, they allow group ownership of objects. 
  
  The default zone is NOTHING. Any building done by a player defaults
  to belonging to the same zone that the player belongs to.
  Every zone is defined by a Zone Master Object (ZMO). The ZMO is an
  ordinary MUX object owned by some player. A wizard may change the
  zone of an object or player to a ZMO.
  
  If the ZMO is a room, it is called a "Parent room." Most of the
  statements about ZMOs also apply to parent rooms; for details,
  see the help topic PARENT ROOMS.
  
  See ZONES2.
 
& ZONES2
  
  Anyone who can pass the Enter lock of the ZMO has control over all
  objects in that zone. This, in essence, gives that player wizard
  powers within that zone. For this reason, one must be extremely
  careful with the enter locks of ZMOs!
  
  Also, $commands on a ZMO are treated as global within that zone.
  The game attempts to match $commands for the ZMO of the player's
  location, as well as $commands for the player's own zone.
  For some suggestions on how to use zones, see "help ZONES3".
  
& ZONES3

  Some suggested uses of zones:
  
    1. If you are working on a building project with several people, it
       may be useful to create a zone object and @elock it to all of you,
       and ask a wizard to @chzone the players involved to the zone object.
       That way, all of the players working on the project will be able to
       modify the building.
  
    2. On a similar thread, if several players are working on a project
       involving only a few objects, it may be simpler to create a zone
       object and @chzone those few objects to the ZMO instead of resetting
       the zones of the players. Note that a player does not have to belong
       to a zone in order to change objects in that zone; all is merely
       required to pass the ZMO's enter lock.
  
    See ZONES4.
 
& ZONES4
 
  More possible uses for zones:
  
    3. If local wizards are desired, a zone object may be created and enter
       locked to the local wizard. Players building within that zone should
       be @chzone'd to that ZMO. The local wizard will then be able to
       control anything within that domain.
  
    4. If you want restricted global commands defined over only a small area,
       you can define that area to be part of a zone, and place the desired
       $commands upon the ZMO.
  
& parent rooms
 
  Parent rooms are a subset of zones. If a room is used as as zone object,
  it is a parent room (PR). PRs are like local "master" rooms. Exits in
  the PR are global to that zone, and $commands on objects in the PR are
  global to that zone. Parent rooms are only defined if globals are used.
  Parent rooms should only be used for very large zones which have a lot
  of global exits. Otherwise, a ZMO thing should be used, because command
  evaluation on a parent room is slower than command evaluation on a ZMO.
  Large numbers of parent rooms may slow down the game significantly.
  
  See ZONE OBJECTS and COMMAND EVALUATION for more information.
  
& comsys
 
  This is the help for the MUX comsystem. Note that the channel
  names and aliases are case-sensitive. Upon creation, new players
  automatically join the "Public" channel, while guest characters join
  channel "Guests" when they connect.
 
  Note: <alias> is the alias you choose for the channel. 
  The "Public" channel for new players is aliased to "pub".
  The "Guests" channel for guests is aliases to "g".
 
  Aliases are the most common way to manipulate channels, and may be used in
  2 different ways:
        <alias> <who|on|off>
        <alias> <message>
 
{ 'help comsys2' for more }
 
& comsys2
  
  For example:
  > pub off
  [Public] Foobar has left this channel.
 
  > pub on
  You have joined channel Public.
  [Public] Foobar has joined this channel.
 
  > pub who
  -- Players --
  Foobar(#23PWc)
  Wizard(#1PWc)
  -- Objects --
  -- Public --
 
  > pub Hello world!  
  [Public] Foobar says, "Hello world!"

{ 'help comsys commands' for more }
 
& comsys commands
 
  These are the topics for the MUX comsystem:
  
  addcom       allcom       alias        comlist      comtitle     clearcom
  delcom
 
  @ccreate     @cboot       @ccharge     @cchown      @cdestroy    @clist
  @coflags     @cpflags     @cset        @cwho
  
& @cboot
 
  Command: @cboot <channel>=<object>
 
  Only wizards, or the owner of the channel can use this command. It
  forcefully removes an object from that channel.
 
  Note: You may specify a player name as <object> if you prefix it with an
  '*'. Otherwise, <object> should be a dbref, or a name of an object if you
  are nearby it.
 
& addcom
 
  Command: addcom <alias>=<channel>
        
  This command joins you to an existing channel with <alias>. You should
  avoid having multiple aliases for a channel, although it is allowed.
  
  See also: delcom, comlist, alias, comtitle.
 
& alias
 
  Command: <channel alias> <on|off|who|message|:pose|;pose>
   
  'on' allows you to turn an alias on.
  'off' lets you temporarily leave that channel.
  'who' shows you who is on that channel.
 
  You may send a message over the channel with <alias> <text>, where <text>
  is the message to be sent, or you can pose on a channel with
  <alias> :<text> or <alias> ;<text>
  
  See also: allcom, comlist, addcom, delcom.
 
& allcom
 
  Command: allcom <on|off|who>
         
  This works like using a single alias, except it does an action for every
  alias you have. You can turn every alias on, or off, or see who is on
  every channel you subscribe to. 
  
  See also: alias, comtitle, delcom, addcom.
 
& comlist
 
  Command: comlist
 
  Displays a list of all the aliases you are using, whether you are 'on' or
  'off' the channel, and some information about them, such as your channel
  title and status.
  
  See also: comtitle, addcom, alias, delcom.
 
& comtitle
 
  Command: comtitle <alias>=<title>
 
  This command allows you to prefix your name on a channel with a title.
 
  For example:
  > comtitle pub=The Great and Powerful
  Title set to 'The Great and Powerful' on channel Public.
  > pub :waves to everyone.
  [Public] The Great and Powerful Foobar waves to everyone.
 
  See also: comlist, addcom, alias, delcom.
 
& clearcom
 
  Command: clearcom
 
  Removes all your aliases for channels. You should be extremely careful
  about this command, as it will wipe out all of your channel information.
  
  See also: addcom, delcom.
 
& delcom
 
  Command: delcom <alias>
 
  Deletes <alias> from your list of channel aliases. If <alias> was the only
  alias you had for a certain channel, you may no longer use that channel
  until you add a new alias for it.
  
  See also: addcom, comlist, clearcom.
 
& @ccreate
 
  Command: @ccreate <channel name>
 
  Creates a channel with default settings. Only wizards can create a channel.
   
  See also: @cdestroy, @clist, @cchown.
 
& @cdestroy
 
  Command: @cdestroy <channel>
 
  Deletes <channel> permanently from the comsystem database. It does not
  destroy all aliases that exist for <channel>, which is left to the owners of
  those aliases. Players are notified at login when they own aliases for which
  a channel no longer exists.
 
  See also: @clist, @ccreate, @cchown.
 
& @clist
 
  Command: @clist[/full]
 
  Without any switches, it will display the list of public channels with
  their owner, and description. It will also display all channels you own.
  With the /full switch, it will display the various channel statistics.
  
  See also: @ccreate, @cdestroy, @cchown.
 
& @cwho
 
  Command: @cwho <channel>[/all]
 
  For channels that you own, identifies all connected players on the channel
  and their stats for the channel. If switch is /all, then it also displays
  unconnected players.
  
  See also: @clist.
 
& @cchown
 
  Command: @cchown <channel>=<player>
 
  Changes ownership of <channel> to <player>.
  
  See also: @clist, @cwho.
 
& @ccharge
 
  Command: @ccharge <channel>=<amount>
 
  This command imposes a charge of <amount> coins on transmitting over a
  channel. The default fee when a channel is created is 0. All proceeds
  benefit the channel owner.
 
& @cpflags
 
  Command: @cpflags <channel>=[!]flag
 
  Sets player flags for that channel. The flag can be one of: join, transmit,
  or receive.
  
  Transmit: Whether a player can broadcast things over the channel.
  Join: Whether a player can join the channel.
  Receive: Whether a player can receive messages over the channel.
  
  If it is !flag, then that flag is reset. Note that channel flags ALWAYS
  override locks on channel objects.
  
  See also: @coflags, @clist, CHANNEL OBJECT.
  
& @coflags
 
  Command: @coflags <channel>=[!]flag
 
  Sets object flags for that channel. The flag can be one of: join, transmit,
  or receive.
  
  Transmit: Whether an object can broadcast things over the channel.
  Join: Whether an object can join the channel.
  Receive: Whether a object can receive messages over the channel.
  
  If it is !flag, then that flag is reset. Note that channel flags ALWAYS
  override locks on channel objects.
  
  See also: @coflags, @clist, CHANNEL OBJECT.
 
& @cset

  Command: @cset/<option> <channel>
  Changes the way a channel behaves.  <option> can be one of the
  following: public, private, loud, mute, quiet, object, spoof, anon
  or nospoof. Public makes it show up on everyone's @clist, private
  hides it. Loud makes it announce connects/disconnects. Mute/quiet,
  shuts them off. Spoof/anon allows the comtitle to replace the
  player's name. Nospoof makes it prepend the comtitle to the player's
  name.

  The object switch sets the channel object to whatever you specify.
  It will allow you to set a description for the @clist, by @descing
  the object.  Also, the lock will be used to check to see if people
  should be able to join the channel or not. See help channel object
  for more.

& channel object
 
  In the comsystem, you may specify a channel object for each channel. 
  (@cset/object channel=<object>).
   
  Channel objects allow you to specify a description for a channel, and
  place certain restrictions on joining, transmitting, and receiving.
 
  NOTE: If a channel flag is set by @cpflags/@coflags, it will ALWAYS
  override the equivalent lock. The flags are set by default, so you will
  have to clear them before your locks work.
 
  The join lock for a channel is a normal @lock on the channel object.  
  The transmit lock for a channel is a use @lock on the channel object.
  The receive lock for a channel is an enter @lock on the channel object.
  The description of a channel is the @desc of the channel object.
 
& CWHO()

  Function: cwho(<channel>)
 
  Returns a list of dbrefs who are connected, and on that channel. 
  This is limited to wizards and channel owners.
 
& @malias
 
  Command: @malias
  
  This allows you to generate and maintain mailing lists with the mail
  system. All mail aliases start with '*', and are case-sensitive. (*dir is
  different than *Dir).  There are two kinds of mail aliases, Personnal
  and Global. Global mailing lists are owned and maintained by the god (#1)
  char and are available for anyone to use.  Generally there will be
  *Wizards, *Admin, *Roleplay, and things of that nature.  Personal mailing
  aliases are mailing lists that you have defined with the @malias commad.
  Currently there is no limit to the number of people you can have on a
  mailing alias.
 
  To begin sending mail to a mailing list, use @mail *<alias>=subject.
  
  Usage:
  
  @malias                   Displays a list of all mail aliases.
  @malias *<alias>          Displays a list of people on that alias.
  @malias *<alias>=<list>   Creates that mailing list, using <list>.
  
{ 'help @malias2' for more }
 
& @malias2
 
  You can add, remove, rename, chown, redescribe, and delete mailing lists
  with a switch.
  
  @malias/remove *<alias>=<player>     Removes <player> from *<alias>.
  @malias/desc *<alias>=<description>  Changes the description for *<alias>. 
  @malias/add *<alias>=<player>        Adds <player> to *<alias>.
  @malias/rename *<alias>=<name>       Renames that alias. Names must always
                                       begin with '*'.
  @malias/delete *<alias>              Deletes <alias>.
  @malias/chown *<alias>=<player>      Changes the owner of <alias> to
                                       <player>.
 
  Wizards can use all of the malias commands on any mail alias. Instead of
  trying to figure out different mailing lists with the same name, wizards
  may use #<MALIAS NUMBER> instead of *alias in regards to the command.
  Remember that the alias commands will only recognize aliases owned by #1,
  owned by you, or by number.
  
  @malias/list                         When invoked by a wizard, it will
                                       list all mailing aliases currently
                                       defined by their number.
 
& drop 

  Command: drop[/<switch>] <object>
           drop[/<switch>] <exit>
 
  The first form removes <object> from your inventory and puts it in your
  location, except for the following special cases: Dropping a STICKY thing
  sends it home, and dropping a thing in a room with a drop-to sends the thing
  to the drop-to location.
 
  The second form removes <exit> from your list of exits and adds it to the
  list of exits for the current location.  Anyone in the same location as
  you may then use the exit to travel to the exit's destination.  You can
  only drop exits when you own the location where you are dropping them.
 
  The following switch is recognized:
     /quiet   - Don't perform the @odrop/@adrop attributes on the dropped
                 object.  This switch only works if you control the object.
 
  'throw' is the same as 'drop'.
  See also: get, @adrop, @drop, @odrop, DROP-TO, STICKY.  

& enter

  Command: enter[/<switch>] <object>
  The enter command is used to enter an object. Insides of objects are best
  used for vehicles, or storage spaces when you don't have a home (or even
  as a floating home).  In order to enter an object you must either own it or
  it must have its ENTER_OK flag set, and you must also pass the object's
  EnterLock (if it has one).
 
  The following switch is recognized:

     /quiet   - Don't perform the @oenter/@aenter or @oefail/@aefail
                attributes on the entered object, and don't perform the
                @oxleave attribute on your current location.  This switch
                only works if you control the object being entered.
 
  See also: leave, @aefail, @aenter, @efail, @enter, @idesc, @lock, @oefail,
            @oenter, @oxleave, ENTER_OK.

& examine

  Command: examine[/<switches>] <object>[/<wild-attrib>]
  Displays all available information about <object>.  <object> may be an
  object, 'me' or 'here'. You must control the object to examine it, or it
  must be set VISUAL.  If you do not own the object, you will just see the
  name of the object's owner, and optionally any public attributes and 
  attributes owned by you set on the object.
 
  If an attribute is owned by a player other than the owner of the object,
  the number of the attribute owner is shown in parentheses immediately
  following the attribute name.  Flag letters may appear in parentheses also,
  to indicate the status of the attribute:
    + - The attribute is locked, it does not change ownership when the
        object is @chowned and may not be modified.
    $ - The attribute is not checked when looking for $-commands.  Note
        that the predefined attributes DESC, IDESC, ODESC, FAIL, OFAIL,
        SUCC, OSUCC, DROP, ODROP, SEX, and CHARGES are never checked.
    I - This attribute is not inherited by children of the object.
    V - The attribute is visible to anyone who examines you.  Note that
        the predefined attributes DESC, SEX, and LAST are always VISUAL.
{ 'help examine2' for more }

& examine2

  If you specify a wildcarded attribute name, then only those attributes
  that match are shown.  So, 'exam me/v?' will show all your attributes that
  start with v and are two characters long.
 
  The following switches are available:
     /brief  - Shows everything except attributes. 
     /full   - When examining an object you don't control, show any public
               attributes set on the object in addition to the owner's name.
     /parent - Includes attributes that are not present on the object itself
               but which are inherited from the object's parent.
  See also: look, @decompile, VISUAL, ATTRIBUTE OWNERSHIP.

& get

  Command: get[/<switch>] <object>
           get[/<switch>] <exit>
           get[/<switch>] <object>'s <sub-object>

  The first form picks up <object> from your location and adds it to your
  inventory.  It will fail if the object is locked against you, or if you
  are inside a player or object that you don't control and which isn't
  set ENTER_OK.
 
  The second form takes an exit from your location and adds it to you.
  Anyone inside you may then use the exit to travel to the exit's destination.
  You may take exits that you own, and exits owned by others in locations that
  you own.
 
  The third form takes <sub-object> from <object> and adds it to your
  inventory.  <object> must be ENTER_OK and <sub-object> must not be locked
  against you for this to work.  The lock on <object> is not checked.
{ 'help get2' for more }

& get2

  The following switch is recognized:
     /quiet   - Don't perform the @osucc/@asucc or @ofail/@afail attributes
                on the target object.  This switch only works if you control
                the object.
 
  <object> and <sub-object> may be either players or things.
  'take' is the same as 'get'.
  See also: drop, @afail, @asucc, @fail, @ofail, @osucc, @succ, ENTER_OK,
            FAILURE, SUCCESS.

& give

  Command: give <player>=<amount/object>
  Gives player the specified amount of money or <object>. You can't give
  someone money if their new total would be greater than 10000 (No reason to
  get greedy).  You may also give players objects, but the other player must
  be set ENTER_OK to receive something you give. 
  See also: @apay, @cost, @opay, @pay, ENTER_OK.

& goto

  Command: goto[/<switch>] <direction>
           goto[/<switch>] home
           <direction>
           home
 
  Moves you in the specified direction, assuming that the direction is not
  locked against you.  'move home' is a special command that returns you to
  your home. The word 'move' may be omitted.
 
  The following switch is recognized:
     /quiet   - Don't perform the @osucc/@asucc/@odrop/@adrop or @ofail/@afail
                attributes on the exit being used.  This switch only works if
                you control the exit.
 
  'move' is the same as 'goto'.
  See also: enter, home, leave, 

& inventory

  Command: inventory
  Lists what you are carrying and how much money you have.

& kill

  Command: kill <player> [=<cost>]
  Attempts to kill the specified player. Killing costs <cost> coins, which
  gives you a <cost>% chance of killing the player. Thus, spending 100 
  coins always works (except against wizards and immortals, who can never be
  killed). Players cannot be killed in rooms which have been set HAVEN or
  which they control.  If you don't specify a cost, the default is 10 (for a
  10% chance of success).  The player, if killed, receives <cost>/2 coins in
  insurance.
  See also: @akill, @kill, @okill, BEING KILLED, IMMORTAL, WIZARD.

& leave

  Command: leave[/<switch>]
  This command leave allows you to exit an object you have entered, arriving
  in the same location as the object. You may not leave an object if you fail
  that object's LeaveLock (but you may still @teleport out, use an exit inside
  the object, or go home).
 
  The following switch is recognized:
     /quiet   - Don't perform the @oleave/@aleave or @olfail/@alfail
                attributes on the entered object, and don't perform the
                @oxenter attribute on your new location.  This switch
                only works if you control your current location.
 
  See also: enter, @lock, ENTER_OK, @aleave, @alfail, @leave, @lfail, @oleave,
            @olfail, @oxenter.

& LOGOUT

  Command: LOGOUT
  Disconnects you from your character without breaking the network connection
  to the game.  You may then log in to another character.  The LOGOUT command
  must be entered in all capitals.
  See also: QUIT.

& look

  Command: look[/<switches>] [<object>]
  Displays the description of <object>, or the room you're in if you don't
  specify an object.  Specifying object as <name> or #<dbref> or 'me' or
  'here' is legal.  You can also use look to look at objects held by other
  people, just use 'look <person>'s <object>'.
 
  You may use the /outside switch to look at the location of your current
  location (useful if you are inside a vehicle or other object).  You may
  also look at other objects in the 'outer' location, but you may not
  use the possessive form with the /outside switch (ie: "look/outside
  <person>'s <object>" won't work).
  
  'read' is the same as 'look'.
 
  See also: @adesc, @describe, @odesc.

& move

  Command: move[/<switch>] <direction>
           move[/<switch>] home
           <direction>
           home
 
  Moves you in the specified direction, assuming that the direction is not
  locked against you.  'move home' is a special command that returns you to
  your home. The word 'move' may be omitted.
 
  The following switch is recognized:
     /quiet   - Don't perform the @osucc/@asucc/@odrop/@adrop or @ofail/@afail
                attributes on the exit being used.  This switch only works if
                you control the exit.
 
  'goto' is the same as 'move'.
  See also: enter, home, leave.

& news

  Command: news [<topic>]
  Shows you the current news for the MUX. It is highly recommended that
  you check the news daily for new information.  Otherwise, the wizards will
  have no pity on you for messing up with the new commands.

& OUTPUTPREFIX

  Command: OUTPUTPREFIX <string>
  Causes <string> to be output on a line by itself before printing the
  results of each command.  This command is intended for use by external
  robot programs, and may be restricted to players whose ROBOT flag is set.
  The OUTPUTPREFIX command must be entered in all capitals.
  See also; @robot, OUTPUTSUFFIX, ROBOT.

& OUTPUTSUFFIX

  Command: OUTPUTSUFFIX <string>
  Causes <string> to be output on a line by itself after printing the results
  of each command.  This command is intended for use by external robot
  programs, and may be restricted to players whose ROBOT flag is set.
  The OUTPUTSUFFIX command must be entered in all capitals.
  See also; @robot, OUTPUTPREFIX, ROBOT.

& page 

  Command: page <player-list> [=[<control>]<message>]
 
  This command sends <message> to <player-list>.  If you do not specify a
  name, it defaults to the players you last paged.  You may use either the
  player's name or alias, a list of names and/or aliases, and you may also
  give a string that uniquely matches the start of a player's name on the
  WHO list.
 
  You can format the message one of several ways by specifying ':', ';', or
  '"' as the first character of the message.  ':' and ';' format the message
  as 'From afar, <player> <message>', with ';' omitting the space between
  <player> and <message>.  '"' formats the message in normal page format
  (this is the default).
 
  If your Idle attribute is set to something, then it is sent to anyone
  who successfully pages you.  This is useful for when you are away from
  your terminal for a short while.

{ 'help page2' for more }

& page2  

  You can selectively disable pages from certain players with the '@lock/page'
  command (players must pass the lock in order to page you).  If someone
  cannot page you, they will be sent a message including of your Reject
  attribute if they try.  If someone pages you while you are not connected,
  they are sent a message including your Away attribute.
 
{ 'help page3' for more. }

& page3

  You can also page many players at one time, where all the players you page
  will see the message. 
  Ex:
  > p darkenelf lauren = Hi
  You paged (Darkenelf Lauren) with 'Hi'.
  
  To (Darkenelf Lauren), Dreamline pages: Hi
 
  You only need to type the player-list once, then the next time you page that
  player or set of players, you can abbreviate it with:
  "p :waves."  or,
  "p I'm back."
 
  This will work until you page another player or list of players.  
 
  See also: pose, say, whisper, :, ;, ", @pemit, @away, @idle,
            @idletimeout, @reject.
 
& pose

  Command: pose[/<switches>] <message>
  Displays <message> to everyone in your current room, preceded by your name
  and optionally a space.  Example: the command 'pose jumps for joy' produces
  '<yourname> jumps for joy'.
 
  The following switches are available:
     /default - (default) Put a space between your name and the message
                (ie, display '<name> <message>').
     /nospace - Don't put a space between your name and the message
                (ie, display '<name><message>').
 
  See also: page, say, whisper, :, ;, ".

& QUIT    

  Command: QUIT
  Logs you out and disconnects you from the game. Must be in all capitals.  
  See also: LOGOUT.

& read 

  Command: read [<object>]
  Displays the description of <object>, or the room you're in if you don't
  specify an object.  Specifying object as <name> or #<dbref> or 'me' or
  'here' is legal.  You can also use look to look at objects held by other
  people, just use 'read <person>'s <object>'.
 
  You may use the /outside switch to look at the location of your current
  location (useful if you are inside a vehicle or other object).  You may
  also look at other objects in the 'outer' location, but you may not
  use the possessive form with the /outside switch (ie: "read/outside
  <person>'s <object>" won't work).
  
  'look' is the same as 'read'.

& ;

  Command: ;<message>
  This command is much like the ':' command, except that no space is inserted
  between your name and the action.  Example: the command ';'s watch beeps.'
  produces '<yourname>'s watch beeps.'.
 
  Warning: This command does not work in command lists run from an attribute
  because the ';' is treated as the command separator.  Use pose/nospace
  instead.
 
  See also: page, pose, say, whisper, :, ".

& :

  Command: :<message>
  Displays <message> to everyone in your current room, preceded by your name
  and a space.  Example: the command ':jumps for joy' produces
  '<yourname> jumps for joy'.
  See also: page, pose, say, whisper, ;, ".

& "

  Command: "<message>
  Says <message> out loud to everyone in your current room.  Example:
  the command '"Where is the movie theater?' produces
  '<yourname> says "Where is the movie theater>"'.  Note that the closing
  double quote is automatically added.
  See also: page, pose, say, :, ".

& #

  Command: #<number> <command>
  Forces the object whose database number is <number> to perform <command>.
  Example: '#1033 move north' forces object #1033 to go north (assuming that
  you control it).  The same restrictions that apply to @force also apply to
  this command.
  See also: @force.

& \\

  Command: \\<message>
  Outputs <message> to everyone in your current room without embellishment.
  Example: the command '\\A chill falls over the room.' produces
  'A chill falls over the room.'
  See also: @emit, @oemit, NOSPOOF.

& say

  Command: say <message>
  Says <message> out loud to everyone in your current room. You can also
  use '"<message>'.
  See also: page, pose, whisper, :, ;, ".

& score

  Command: score
  Displays how much money you have.  Helpful to see if any machines are
  looping.
  See also: @ps, LOOPING.

& SESSION

  Command: SESSION
  Displays information on how many characters you have sent and received
  during this session, and which (Internal) port you are connected to on the
  MUX.  It must be typed in all uppercase.
 
  Example:
    > SESSION
                                     Characters Input----  Characters Output---
    Player Name     On For Idle Port Pend  Lost     Total  Pend  Lost     Total
    Mortal           00:06   0s   16    0     0        44   156     0      2679
    2 Players logged in.
 
  Pending characters are those waiting to be acted on as commands (for input)
  or waiting to be sent out over the network (output).  Lost characters are
  due to overflowing either the MUX's input or output buffers, either as the
  result of running a single command that produces too much output (such as
  @find and @search commands that match a large number of objects), or from
  typing too much on one line.
 
  Note: your Pending count for output will always be nonzero, as the output
  of the SESSION command hasn't been sent out over the network yet.

& take

  Command: take[/<switch>] <object>
           take[/<switch>] <exit>
           take[/<switch>] <object>'s <sub-object>
 
  The first form picks up <object> from your location and adds it to your
  inventory.  It will fail if the object is locked against you, or if you
  are inside a player or object that you don't control and which isn't
  set ENTER_OK.
 
  The second form takes an exit from your location and adds it to you.
  Anyone inside you may then use the exit to travel to the exit's destination.
  You may take exits that you own, and exits owned by others in locations that
  you own.
 
  The third form takes <sub-object> from <object> and adds it to your
  inventory.  <object> must be ENTER_OK and <sub-object> must not be locked
  against you for this to work.  The lock on <object> is not checked.
{ 'help take2' for more }

& take2

  The following switch is recognized:
     /quiet   - Don't perform the @osucc/@asucc or @ofail/@afail attributes
                on the target object.  This switch only works if you control
                the object.
 
  <object> and <sub-object> may be either players or things.
  'get' is the same as 'take'.
  See also: drop, @afail, @asucc, @fail, @ofail, @osucc, @succ, ENTER_OK,
            FAILURE, SUCCESS.

& think

  Command: think <message>
 
  You can use this command to send a private message to yourself. Pronoun
  substitution is performed. This is essentially equivalent to "@pemit
  me=<message>", but with "think", there is no prepended text. One possible
  use: "@adesc me=think --> %n(%#[flags(%#)]) just looked at you."
 
& throw

  Command: throw[/<switch>] <object>
           throw[/<switch>] <exit>
 
  The first form removes <object> from your inventory and puts it in your
  location, except for the following special cases: Dropping a STICKY thing
  sends it home, and dropping a thing in a room with a drop-to sends the
  thing to the drop-to location.
 
  The second form removes <exit> from your list of exits and adds it to the
  list of exits for the current location.  Anyone in the same location as
  you may then use the exit to travel to the exit's destination.  You can
  only drop exits when you own the location where you are dropping them.
 
  The following switch is recognized:
     /quiet   - Don't perform the @odrop/@adrop attributes on the dropped
                 object.  This switch only works if you control the object.
 
  'drop' is the same as 'throw'.
  See also: get, @adrop, @drop, @odrop, DROP-TO, STICKY.  

& use

  Command: use <object>
  Uses <object>.  Some objects will do interesting, useful, or dangerous
  things when used, for instance, using a camera should result in a 
  picture being taken.
  See also: @ause, @ouse, @use.

& version

  Command: version
  Displays the version of MUX that is running and the date it was last
  rebuilt.

& whisper
 
  Command: whisper <player>=<message>
  Whispers the message to the named person, if they are in the same room as
  you. No one else can see the message that you whisper.
 
  You can format the message one of several ways by specifying ':', ';', or
  '"' as the first character of the message.  ':' and ';' format the message
  as 'You sense <player> <message>', with ';' omitting the space between
  <player> and <message>.  '"' formats the message in normal whisper format
  (this is the default).
  See also: page, pose, say, :, ;, ".

& WHO

  Command: WHO <prefix>
  Displays a list of players currently connected to the MUX.
  The WHO report tells you how long a player has been on, how long they
  have been inactive, and what they are doing (if they have used the @doing
  command).  If <prefix> is specified, only players whose names start with
  <prefix> are listed.  The WHO command must be entered in all capitals.
  See also: @doing.

& &

  Command: &<attribute> <object>[=<value>]
  Synonym: @set <object> = <attribute>:[<value>]
 
  Sets the attribute named <attribute> on <object> to <value>.  If
  <attribute> is not a predefined attribute (like ofail or va), then it is
  created.  Attributes so created are called user-named attributes.
  Attribute names may only contain letters, numbers, and the characters
  < -_.@#$^&*~?=+| >, and must start with a letter.  The names of user-named
  attributes may not be abbreviated (an attempt to get the value of the
  attribute will fail, and an attempt to set will create a new attribute).
  The & command may be used to set predefined attributes (in this instance,
  '&<attr> <object>=<value>' is equivalent to '@<attr> <object>=<value>').
 
  See also: @set.

& @@

  Command: @@ <args>
 
  This command does nothing, therefore it is useful for putting comments into
  a MUX program.  Be careful that ()'s and {}'s in the (otherwise ignored)
  arguments are nested correctly, lest your command-ending ; be trapped
  inside.
 
  Example:
     @va me=$foobar *:@fo #1234=%0;@@ This controls my foobar puppet.

& @chown

  Command: @chown <object>[=<player>]
           @chown <object>/<attr>[=<player>]
  The first form changes the ownership of <object> to <player> (default is
  to yourself).  Objects may be things, rooms or exits. To chown things, you
  have to be carrying the thing. For rooms or exits, you have to be in the
  room. Objects must have the CHOWN_OK flag set before they may be @chowned.
  In a room, the command used must be @chown here = <name>, and for an object,
  you must be very specific.
 
  The second form changes the ownership of the indicated attribute on <object>
  to <player> (default is the owner of the object).  You may only @chown
  unlocked attributes.  You may @chown unlocked attributes on objects that
  you own to yourself, and you may also @chown attributes that you own on
  objects owned by others to the owner of the object.
 
  When an object is @chowned, all unlocked attributes on the object are
  automatically @chowned as well, locked attributes remain owned by their
  original owners.
 
  The HALTED flag is automatically set on the new copy of the object.
  Players can't be @chowned; they always own themselves. 
  See also: @lock, @Unlock, CHOWN_OK, ATTRIBUTE OWNERSHIP.

& @chzone
 
  Command: @chzone <object>=<zone object>. 
  
  Changes the zone of <object> to <zone object>. If <zone object> is "none",
  the zone is reset to NOTHING.
  
  @chzone'ing a player does not automatically change the zone of their
  objects. Anyone may reset the zone of an object they own; <zone object>
  must either be "none", or must be owned by them. Only wizards may @chzone
  an object to an arbitrary zone object. Players may @chzone themselves to
  an object they own; otherwise, only wizards may @chzone players.
  @chzone'ing resets the WIZARD, ROYALTY, and INHERIT flags on non-player
  objects.
  
  See also: ZONE OBJECTS
 
& @clone

  Command: @clone[/<switches>] <object>[=<newname/cost>]
 
  Creates an exact duplicate of <object> that is owned by you and (for things
  and exits) puts it in your current location.  You may have the object put
  in your inventory (or your exitlist in the case of cloning exits) by using
  the /inventory switch.
 
  You may clone your own objects, plus VISUAL objects owned by others.
  The INHERIT and WIZARD bits of the (new) object are cleared when the object
  is cloned.  If <newname> is specified, it is used as the name instead of
  the original name.
 
  If you clone a linked exit, an attempt is made to link the clone to the
  same location.  Except when using the /inventory switch, you can only clone
  exits when you own your current location.
 
  If you clone a room with a drop-to, an attempt is made to link the drop-to
  to the same location.
 
  If the original object was owned by you, then the ACLONE attribute is run
  in the new attribute, otherwise the new object is set HALTED.  Exits and
  contents of cloned objects are not cloned, and LOCKED attributes are not copied.
{ 'help @clone2' for more }

& @clone2

  The following switches are available:
     /cost       - Treat the argument after the = as the cost of the new
                   object, not the name.
     /inherit    - Don't reset the INHERIT bit on the new object.
     /inventory  - Create the new object in your inventory (or your exitlist,
                   in the case of cloning exits).
     /location   - Create the new object in your location (default).
     /parent     - Set the new object's parent to be the template object and
                   don't copy the attributes.
  See also: @create, @decompile, @destroy, VISUAL.
 
& @cpattr

  @cpattr <obj>/<attr> = <obj1>/<attr1> [,<obj2>/<attr2>,<obj3>/<attr3>,...]
  @cpattr <obj>/<attr> = <obj1> [,<obj2>,<obj3>,...]
  @cpattr <attr> = <obj1>/<attr1> [,<obj2>/<attr2>,<obj3>/<attr3>,...]
  @cpattr <attr> = <obj1> [,<obj2>,<obj3>,...]
 
  The first form of this command is used to copy <attr> on <obj> to the
  object-attribute pairs in a comma-separated list. For example:
 
  @cpattr test/va = test/vb, cube/va, tribble/foo
 
  would copy the VA attribute from object "test" to VB on "test",
  VA on "cube", and FOO on "tribble".  <objN> is matched as if
  you were performing a @set on it.
 
  The second form copies <attr> to the list of objects, with the name
  <attr>. The third form copies <attr> from the object that executes the
  @cpattr, to the object-attribute pairs in the list. Finally, the third
  form copies <attr> from the object that executes the @cpattr to the
  objects in the list, with the name <attr>.
 
& @create

  Command: @create <name> [=<cost>]
  Creates a thing with the specified name.  Creation costs either <cost>
  or 10 coins, whichever is greater. The value of a thing is proportional
  to its cost, specifically, value=(cost/5)-1.  The value may not be greater
  than 100, values that would be greater than 100 are rounded down to 100.
  See also: @destroy, TYPES OF OBJECTS.

& @decompile

  Command: @decompile[/dbref] <thing>[/attr] [=<newname>]
  Dumps the sequence of commands you would have to type to clone <thing>.
  This is handy for saving your objects in a text file in case the MUX dies
  a horrible death, or for moving your pride-and-joy creation from one MUX
  to another.  @decompile works on all object types.
  If you specify <newname>, then the commands emitted will set attributes,
  locks, and flags on an object named <newname> and will omit the command
  to create the object.
  If you specify <thing>/<attr>, <attr> accepts wildcards.
  If you specify the /dbref switch, you will get output using the dbref
  number instead of the object name.
  See also: examine, look.

& @destroy

  Command: @destroy[/<switches>] <object>
  This command destroys <object> and refunds its cost of creation to its
  owner.  You must own <object> in order to @destroy it, unless its
  DESTROY_OK flag is set, in which case anyone holding it may @destroy it.
  Rooms, exits, and objects may be destroyed, although the the actual
  destruction of rooms is delayed for up to ten minutes and the GOING flag
  is set on the victim room.  Clearing the GOING flag on the room spares it
  from destruction.
 
  If a thing OR it's owner is set DESTROY_OK, the thing will be destroyed
  with no delay.
 
  The @destroy command will not destroy objects with the SAFE flag set unless
  the /override switch is specified.  The DESTROY_OK flag overrides the
  protection given by the SAFE flag.
 
  The following switches are available:
    /override  - Negate protection offered by the SAFE flag.
  See also: DESTROY_OK, SAFE.

& @dig

  Command: @dig[/<switches>] <name> [= <exitlist> [, <exitlist>] ]
  Creates a new room with the specified name and displays its number. This 
  command costs 10 coins. If the [= <exitlist>] option is used, an exit will
  be opened from the current room to the new room automatically.  If the
  second <exitlist> option (after the comma) is specified, an exit from the
  new room back to the current room with the specified [Exits] name is
  opened.  Either exit creation may fail if you do not have sufficient
  rights to the current room to open or link the new exit.
  Example: The command
 
     @dig Kitchen = Kitchen;k;north;n,south;s
 
  will dig a room called Kitchen, and open an exit called 'Kitchen' in your
  current room.  The ; symbol means that you may enter the exit by typing
  'k', 'north' or 'n' also.  This command also opens the exit 'south;s' from
  'Kitchen' back to where you are.  Only the first Exit name is displayed in
  the Obvious exits list.
 
  If you specify the /teleport switch, then you are @teleported to the
  room after it is created and any exits are opened.
 
  See also: @destroy, @link, @open, LINKING, TYPES OF OBJECTS.

& @doing

  Command: @doing[/<switches>] [<message>]
  Sets your doing message, which appears after your name in the WHO report.
  The following switches are available:
     /message - Sets your Doing string in the WHO report. (default)
     /poll    - Displays the current Doing poll from the WHO report.
  See also: WHO, @poll.

& @dolist

  Command: @dolist[/<switch>] [<delimiter>] <list>=<action>
  <list> is a list of strings, which can be object numbers, attributes, or
  arbitrary words.  <action> is a command to perform once for each item in
  <list>, replacing the special symbol ## with the corresponding item from
  <list>, and the symbol #@ with the position in the list, starting with
  one. By default, @dolist considers each item in <list> to be separated
  with spaces. If you specify the /delimit switch, then each item is
  considered to be separated by <delimiter>. <delimiter> must be a single
  character.
 
  If present, <switch> can be any of:
    /space   - (Default) List elements are separated by spaces.
    /delimit - List elements are separated by <delimiter>.
 
  This command is particularly handy with lcon() and lexits(). A few examples:
 
    @dolist [lcon(here)] = "[name(##)](##)
    @dolist [lcon(here)] = @switch [get(##/last)]=*1990*,"[name(##)]
    @va me = va vb vc
    @dolist [get(me/va)] = @emit [get(me/##)]
    @dolist Frodo Bilbo Gandalf = page ## = HELP!!!!  I've fallen into a pit.
    @dolist/delimit , {Frodo, Bilbo Baggins, Gandalf} = page ## = HELP!!!!
  See also: iter(), parse().

& @drain

  Command: @drain <object>
  Discards all commands waiting on the semaphore <object> and resets the
  semaphore to its initial state.
  See also: @notify, @ps, SEMAPHORES

& @edit

  Command: @edit <object>/<wild-attr> = <search>,<replace>
           @edit <object>/<wild-attr> = ^,<text>
           @edit <object>/<wild-attr> = $,<text>
  This command edits the contents of one or more attributes of an object,
  eliminating the need to retype a long attribute in order to make a simple
  change.  In the first form, all occurrences of <search> in the specified
  attribute of the named object are replaced with <replace>.  Use curly
  braces ({ and }) around <search> or <replace> if they contain commas.
  The second and third form prepend and append <text> to the selected
  attributes, respectively.
 
  If <wild-attr> contains wildcard characters, then all attributes that
  match are edited.

& @cemit

  Command: @cemit[/<switches>] <channel>=<message>
  Sends <message> over <channel> prefixed by the channel's name. You must
  own or control the channel to do this.
 
  The following switches are available:
     /noheader - Sends the message to everyone on <channel>, without the
                 channel's name prefixed.
 
& @emit

  Command: @emit[/<switches>] <message>
  Sends <message> to everyone in your current location without prefixing it by
  your character name.  You can also send the message to everyone in the room
  that contains the object you are inside with the /room switch.
 
  The following switches are available:
     /here  - Sends the message to everyone in the same location as you.
     /room  - Sends the message to everyone in the room that contains the
             object you are in.  Starting from your location, this switch
             'leaves' objects until it reaches a room, and @emits the message
             there.
  If both switches are specified, the message is sent to both places.  If
  neither is specified, /here is assumed.
 
  Some MUXes may restrict the use of this command.
  See also: @femit, @oemit, @pemit, @npemit, @remit, SPOOFING.

& @remit

  Command: @remit <room dbref#> = <message>
  Sends <message> to the contents of <room>.
 
  See also: @femit, @oemit, @pemit, @npemit, @emit, SPOOFING.
 
& @entrances

  Command: @entrances [[<object>][,<low>[,<high>]]]
 
  Lists links from elsewhere to the specified object (default: your current
  room).  For rooms, exits and drop-to's, leading to the room and players
  and objects whose home is in the room are listed.  For players and objects,
  lists exits leading to them.  Because this command is computationally
  expensive, it costs 100 coins.  <low> and <high> can be used to indicate
  where to start and stop the search, respectively.
 
  Examples:
    > @entrances             <- all links to here
    > @entrances object      <- all links to object
    > @entrances ,100,200    <- all links to here from #100 to #200
    > @entrances me,1000     <- all links to me from #1000 and above.
  See also: @link, @unlink.

& @femit

  Command: @femit[/<switches>] <object>=<message>
  Forces <object> to emit <message>.  This command is similar to the command
  '@force <object> = @emit <message>', except that it will work so long as
  you own the object, whereas @force may fail if the object has its INHERIT
  flag set and the object performing the @force does not.
 
  The following switches are available:
     /here  - Sends the message to everyone in the same location as <object>.
     /room  - Sends the message to everyone in the room that contains the
              object that <object> is in.  Starting from your location, this
              switch 'leaves' objects until it reaches a room, and @emits the
              message there.

  If both switches are specified, the message is sent to both places.  If
  neither is specified, /here is assumed.
 
  Some MUXes may restrict the use of this command.
  See also: @remit, @emit, @fpose, @fsay, INHERIT, SPOOFING.

& @find

  Command: @find <name>[,<low>[,<high>]]
 
  Displays the name and number of every room, thing, or player that you
  control whose name matches <name>. Because the command is computationally
  expensive, it costs 100 coins.
 
  <low> and <high> may be used to restrict the range of objects that are
  searched, if they are given then the search starts at object #<low> and ends
  at object #<high>.
 
  Examples:
    > @find Lost Room
    > @find Secret Device,12000,14000
  See also: @search.

& @force

  Command: @force <player/object>=<command>
  Forces the game to act as though <player/object> had entered <command>.
  You may only force objects that you control.  Objects may not force players
  unless either the object or the player has their INHERIT flag set, and
  objects that do not have their INHERIT flag set may not force objects that
  do.  If the victim is specified by number, you may use an alternate form
  of the command, '#<number> <command>'.
  See also: puppets.

& @fpose

  Command: @fpose[/<switches>] <object>=<message>
  Forces <object> to pose <message>.  This command is similar to the command
  '@force <object> = :<message>', except that it will work so long as you
  own the object, whereas @force may fail if the object has its INHERIT flag
  set and the object performing the @force does not.
 
  The following switches are available:
     /default - (default) Put a space between the name of the object and
                the message (ie, send '<name> <message>').
     /nospace - Don't put a space between the name of the object and the
                message (ie, send '<name><message>').
  See also: @femit, @fsay, pose, :, ;, INHERIT.

& @halt

  Command: @halt [<object>]
  Halts all commands being run by <object>, or by the object running the
  command if no <object> is given.  If the object to be halted is a player,
  then all commands being run by objects owned by that player are halted.
  Use this command to stop runaway objects and infinite loops.
  The process of halting an object involves removing all commands waiting
  to be run by the object from the queue and refunding the queue deposit.
  Halting an object does not affect commands waiting on it as a semaphore.
  See also: @drain, @notify, kill, HALTED, SEMAPHORES.

& @last

  Command: @last <player>
  This command displays a short 'connection history' for <player>, showing
  recent successful and failed connection attempts, as well as the total
  number of successful and failed connections.
  You can only display information about yourself.

& @link

  Command: @link <object>=#<number>/here/home
  When used on a player or a thing, this command sets the object's home
  to the indicated location.  The destination must be owned by you or be an
  ABODE room, and you must pass the destination's LinkLock.
 
  When used on a room, this command sets the room's drop-to, where objects
  dropped in the room go.  The destination must be a room that is either owned
  by you or is LINK_OK, and you must pass the destination's LinkLock.
 
  For exits, this command sets the destination if the exit is currently
  unlinked, you control the destination or it is set LINK_OK, and you pass the
  destination's LinkLock.  You can @link an unlinked exit regardless of who
  owns it or the lock set on it, you are made the owner if you successfully
  link to the destination.  Linking an exit costs 1 coin, and if the exit was
  owned by someone else, you also reimburse the the former owner 1 coin
  (making the total cost to you 2 coins).
{ 'help @link2' for more }

& @link2

  Note that in all the above cases that it is the player performing the @link
  command that must pass the LinkLock, not the object being linked.
  Therefore, you should use the '$' lock qualifier if you want to prevent
  specific players from linking to your LINK_OK locations, as simply locking
  against '*<playername>' does not lock out their puppets.
 
  See also: @dig, @open, @unlink, DROP-TOS, HOMES, LINKING.

& @list

  Command: @list [<option>]
  Lists information from internal databases.  Information is available
  about the following options:
    attributes      - Valid object attributes.
    commands        - Commands that you may use (excluding the 
                      attribute-setting commands as well as any exits, and
                      $-commands available).
    costs           - Lists the costs associated with many commands and
                      actions.
    default_flags   - Lists the flags that new objects receive by default
                      when created.
    flags           - Lists the name and letter of all the flags.
    functions       - Lists all the available functions.
    options         - Lists several global options and limits.
    powers          - Lists all powers.
    switches        - Lists what commands support switches and the switches
                      that they do support.
  The information provided by the @list command is definitive, as it reads
  the internal tables to produce the information it displays.  Specifying
  @list with no argument lists the options you may use.

& @listmotd

  Command: @listmotd
  Displays the current message-of-the-day.  Note that it is displayed when
  you connect to your character. This will also display the "motd.txt" file. 

& @lock

  Command: @lock[/<whichlock>] <object>=<key>
           @lock <object>/<attrib>
 
  The first form locks <object> to a specific key(s).  Type 'help @lock keys'
  for a list of the keys you may use.
 
  <whichlock> indicates which lock you want to set on the object.  If you
  don't specify one, you set the Default lock. Type 'help @lock locks' for
  a list of the locks you may set and what they are used for.
 
  The second form locks the indicated attribute of the named object, so that
  when the object is @chowned, the attribute will remain owned by you.
  It may also be used when you own an attribute on an object that you do not
  own, in this case it prevents the object's owner from @chowning the
  attribute to himself, and prevents anyone from modifying or removing the
  attribute.
 
  See also: @chown, @unlock.

& @lock locks

  You can set the following locks:
 
     DefaultLock:  Exits:          controls who may traverse the exit to
                                   its destination.
                   Rooms:          controls whether the player sees the SUCC
                                   or FAIL message for the room following the
                                   room description when looking at the room.
                   Players/Things: controls who may GET the object.
     EnterLock:    Players/Things: controls who may ENTER the object if the
                                   object is ENTER_OK. Also, the enter lock
                                   of an object being used as a Zone Master
                                   Object determines control of that zone.
     GiveLock:     Players/Things: controls who may give the object.
     LeaveLock:    Players/Things: controls who may LEAVE the object.
     LinkLock:     All but Exits:  controls who may link to the location if the
                                   location is LINK_OK (for linking exits or
                                   setting drop-tos) or ABODE (for setting
                                   homes)
     PageLock:     Players:        controls who may page the player.
     ParentLock:   All:            controls who may make @parent links to the
                                   object.
     ReceiveLock:  Players/Things: controls who may give things to the object.
{ 'help @lock locks2' for more }

& @lock locks2

     SpeechLock:   All but Exits:  controls who may speak in that location
                                   (only checked if AUDITORIUM flag is set
                                   on that location)
     TeloutLock:   All but Exits:  controls who may teleport out of the
                                   location.
     TportLock:    Rooms/Things:   controls who may teleport there if the
                                   location is JUMP_OK.
     UseLock:      All but Exits:  controls who may USE the object, GIVE the
                                   object money and have the PAY attributes
                                   run, have their messages heard and possibly
                                   acted on by LISTEN and AxHEAR, and invoke
                                   $-commands stored on the object.
     DropLock:     All but rooms:  controls who may drop that object.
     UserLock:     All:            Not used by MUX, is intended to be used
                                   in MUX programming where a user-defined
                                   lock is needed.
 
 Note: If a player fails the UseLock on a parent of an object being searched
 for $-commands, then the search for attributes stops and the parent chain is
 not searched further for matches.

& @Lock keys
 
  You may use the following keys when setting locks.  For information about
  a particular type of key, type 'help @lock <keytype>'.
 
  Key Type    Form in @Lock Command
  ----------  ------------------------------
  Normal      <object>
  Is          =<object>
  Carry       +<object>
  Ownership   $<object>
  Indirect    @<object>
  Attribute   <attribute>:<wildcard-pattern>
              +<attribute>:<wildcard-pattern>
              =<attribute>:<wildcard-pattern>
  Evaluation  <attribute>/<value>
  Compound    <key> & <key>
              <key> | <key>
              !<key>
              ( <key> )

& @lock attribute

  ATTRIBUTE LOCKS:
 
  Key: <attribute>:<pattern>
       +<attribute>:<wildcard-pattern>
       =<attribute>:<wildcard-pattern>
 
  You may lock on whether a specific attribute on the player attempting to
  pass the lock matches a pattern.  Example: '@lock thing=sex:m*' will lock
  thing to anyone whose sex starts with an M. Wild cards, greater than and
  less than may be used, for example: '@lock a-f=name:<g' will lock the exit
  a-f against any one whose name is higher than f.
 
  Both the player testing the lock and every object in his inventory is
  checked, the player passes the lock if any of those objects passes the lock.
  If the attribute name is prefixed by a = then only the player is checked.
  Similarly, if the attribute name is prefixed by a + then only objects in
  the player's inventory are tested.
 
{ 'help @lock attribute2' for more }

& @lock attribute2

  Note: you may lock against any attribute, but the locked object must be
  able to read the attribute from the player attempting to pass the lock or
  the lock will fail.
 
  Examples:
    > @lock men's room=sex:m*
    > @lock a-f=name:<g
    > @lock post office=email:*@*
  See also: ATTRIBUTE OWNERSHIP, @lock evaluation.

& @lock evaluation

  EVALUATION LOCKS:
 
  Key: <attribute>/<value>
 
  Evaluation locks let you evaluate one of your attributes and compare the 
  result against a value stored in the lock.  The result must be an exact
  match (no wildcarding allowed, but uppercase and lowercase are considered
  to be the same).  When evaluating the attribute the enactor substitutions
  (%#/%n/etc) are replaced with information about the player trying to pass
  the lock, and 'me' and %! refer to the locked object or exit.
 
  If you call an indirect lock and the indirect lock is an evaluation lock
  (or is a compound lock that includes an evaluation lock), then the original
  lock object is checked for the attribute first, followed by the object that
  has the actual evaluation lock.  If there are multiple levels of indirection
  the intermediate locks are not checked.
 
{ 'help @lock evaluation2' for more }

& @lock evaluation2

  Examples:
    > @lock bank=checkmoney/1
    > &checkmoney bank=[gt(money(%#),5000)]
    Only people and objects with more than 5000 pennies may pass.
    Note: this lock requires wizard privileges to read the worth of other
    players.
 
    > @lock divisible_by_five_club = checkdiv/0
    > &checkdiv divisible_by_five_club = [mod(mid(%#,2,20),5)]
    Only objects whose db-number is divisible by 5 may pass.
  See also: @lock attributes.

& @lock indirect

  INDIRECT LOCKS:
 
  Key: @<object>
 
  You may reference the lock on another object and use the result of
  evaluating that other object's lock.    You pass an indirect lock if you
  pass the default lock on <object>.  This is especially useful if you
  have a large number of objects or exits that want to have the same lock,
  and you want to be able to update one object and have all the other
  locks change at the same time.
 
  <object> is searched for when you enter the @lock command and its
  database number is stored in the lock, so something like
  '@Lock north=@master.lock' is safe even if you are going to move master.lock
  to another location.
 
  Examples:
    > @lock master.lock = me
    > @lock north = @master.lock
    > @lock south = @master.lock
    North and south all reference the lock on master.lock, so you may change
    the lock on all three exits by changing master.lock.
  See also: @lock normal.

& @lock normal

  NORMAL LOCKS:
 
  Key: <object>
 
  You pass a normal lock if you either are the named object or if you carry
  the named object.  <object> may be the name or #number of a thing,  a
  playername prefixed by an asterisk (*<playername>), 'me', or 'here'.
 
  Examples:
    > @lock treasure room = secret key
    > @lock private area = me
  See also: @lock is, @lock carry.

& @lock is

  IS LOCKS:
 
  Key: =<object>
 
  You pass an is lock only if you are the named object.
 
  Example:
    > @lock mystical highway = =magic bus
    Only the magic bus may travel down the mystical highway.  You cannot
    travel the highway if you are carrying the bus.
  See also: @lock carry, @lock normal.

& @lock carry

  CARRY LOCKS:
 
  Key: +<object>
 
  You pass a carry lock if you are carrying the named object.
 
  Example:
    > @lock secret passage = +magic bus
    You can only traverse the secret passage if you are carrying the
    magic bus.  The bus cannot enter the passage on its own (perhaps
    when you are driving it).
  See also: @lock is, @lock normal.

& @lock ownership

  OWNERSHIP LOCKS:
 
  Key: $<object>
 
  You pass an ownership lock if you have the same owner as <object>.
 
  Examples:
    > @lock mystuff=$me
    Only objects you own may use the mystuff exit.
 
    > @lock/page me = !$*TinyJerk
    Neither TinyJerk nor any of his objects may page you.
  See also: @lock normal.

& @lock compound

  COMPOUND LOCKS:
 
  Key: <key> & <key>
       <key> | <key>
       !<key>
       ( <key> )
 
  You can make complex locks by combining keys with the logical AND and OR
  operators (& and ! respectively), or by using the NOT operator.  You
  may also group complex locks with parentheses.
 
  Examples:
    > @lock exit = me & !me
    An impossible lock, nothing can be both you and not you.
 
    > @lock message = me | *recipient
    Both you and the player recipient may get the msssage.

& @mail

  @mail[/<switches>] <player-list> = <subject>
  @mail[/<switches>] [<msg-list> [= <target>]]
 
  @mail invokes the built-in MUX mailer, which allows players to send
  and receive mail. Pronoun/function substitution is performed on
  any messages you may try to send.
 
  A <player-list> is a space-separated list of recipients, which may be:
        Player names (names with spaces in them should be put in double
                      quotes, ex: "Foo Bar")
        Player dbref #'s
        Message numbers to be replied to.
        A mix of the above, and mail aliases (see @malias)
 
  A <msg-list> is one of the following:
        A single msg # (ex: 3)
        A message range (ex: 2-5, -7, 3-)
        A sender (ex: *lauren)
        An age of mail in days (ex: ~3 (exactly 3), <2, >1)
           "days" here means 24-hour periods from the current time.
        One of the following: "read", "unread", "cleared", "tagged", "urgent"
        For certain commands, "all".
 
  See the following topics:
    mail-sending    mail-reading     mail-folders      mail-other
    mail-admin      @malias          mail-reviewing    mail-examples
 
& mail-reviewing
   
  @mail/review <player>
        Reviews the messages you have sent to <player>.
 
  @mail/review <player>=<msglist>
        Reads the messages you have sent to <player>.
 
  @mail/retract <player>=<msglist>
        Retracts (deletes) unread messages you have sent to <player>.
 
& mail-reading
 
  @mail <msg #>
  @mail/read <msg-list>
        This displays messages which match the msg# or msg-list from
        your current folder.
 
  @mail
  @mail <msg-list, but not a single msg #>
        This gives a brief list of all mail in the current folder,
        with sender name, a list of receiving players, subject, and
        message status.
  @mail/list [<msg-list>]
        This gives the same list, but with time sent instead of subject.
        The status field is a set of characters (ex: NC-UF+) which mean:
                N = New (unread) message
                C = Cleared message
                U = Urgent message
                F = Forwarded message
                + = Tagged message
        The opposites of these (read messages, etc.) are indicated with a
        '-' in the status field in that position.
 
& mail-sending

  @mail[/switch] <player-list> = <subject>
        This begins a message to all players in <player-list>.
        -<text> adds text to the message in progress, for example
            -This is a test
        would add the text 'This is a test' to the end of your @mail
        message, likewise, ~<text> prepends the text.
    
  @mail/send
        This sends the message that is currently in progress.
        -- is the equivalent of @mail/send. @mail/urgent sends
        the message as urgent, and should not be used often.
 
  @mail/cc <player-list>
        This replaces the currect player list with a new one for carbon
        copying. It does _not_ add onto the existing list.
 
  See mail-sending2.
 
& mail-sending2
 
  @mail/proof
        This shows you the message that is currently in progress, as
        it would be read by whomever received it.
  
  @mail/edit <old text> = <new text>
        Like @edit, but edits the message in process.
 
  @mail/abort
        This aborts the message currently in progress, allowing you
        to start a new one.
 
  @mail/fwd <msg> = <player-list>
        This sends a copy of <msg> to all the players in <player-list>.
        The copy will appear to have been sent by you (not the original
        sender), and its status will be "Forwarded". Note that this
        places the message to be forwarded into your mail buffer, where
        you can edit it with @mail/edit, add text with '-', or prepend
        text with '~'. You have to use '--' or @mail/send to send the
        message.
 
  @mail/quick <player-list>/<subject> = <message>
        Sends <message> to the list of players.

  See mail-sending3.
  
& mail-sending3

  @mail/reply[/quote] <message>
        This starts a working message to the person who sent you <msg>.

  @mail/replyall[/quote]
        This starts a working message to the person who sent you <msg>
        and to every other recipient of <message>.

  In both cases, because this is a reply, the subject line will be:
  
        'Re: <subject line from original message>'

  Also, in both cases, if /quote is specified, the original message
  will be quoted into the working message with a header and footer much
  like the following:
  
        On Thu Apr 27 21:33:04 2000, Gordon wrote:
  
        <quoted message from original message>
  
        ********** End of included message from Gordon

  You can add additional text above or below the quoted material with
  the postpend ('-') and prepend ('~') @mail commands. Like, normal
  outgoing @mail, the reply is finished and sent with '--' on a line
  by itself

& mail-other

  @mail/clear [<msg-list | all>]
  @mail/unclear [<msg-list> | all>]
        These commands mark mail in the current folder as cleared or
        uncleared. Mail marked for clearing is deleted when you
        disconnect, or if you use @mail/purge. If no msg-list is
        specified, all mail in your current folder is cleared. If "all"
        is given instead of a msg-list, all mail in *all* folders is
        cleared/uncleared.
 
  @mail/purge
        Actually deletes all messages marked for clearing with
        @mail/clear. This is done automatically when you log out.
 
  @mail/tag [<msg-list | all>]
  @mail/untag [<msg-list> | all>]
        These commands tag or untag mail in the current folder.
        Tagged mail can be later acted on en masse by using "tagged" as
        the msg-list for other commands (which does *not* untag them
        afterward). If no msg-list is specified, all messages in the
        current folder are tagged/untagged. If "all" is given as the
        msg-list, all mail in *all* folders is tagged/untagged.
        (Ex: To clear all mail from Lauren and Crusade,
        @mail/tag *lauren, @mail/tag *crusade, @mail/clear tagged,
        @mail/untag all).
 
{ 'help mail-other2' for more }
& mail-other2
 
  @mail/safe [<msg-list> | all>]
        This command marks a message as being safe from mail expiration. It
        should be used sparingly and only for very imporatant messages.
 
& mail-folders

  The MUX mail system allows each player 16 folders, numbered from
  0 to 15. Mail can only be in 1 folder at a time. Folder 0 is
  the "inbox" where new mail is received. Most @mail commands
  operate on only the current folder.
 
  @mail/folder
        This commands lists all folders which contain mail, telling
        how many messages are in each, and what the current folder is.
 
  @mail/folder <folder#|foldername>
        This command sets your current folder to <folder#>.
 
  @mail/folder <folder#> = <foldername>
        This command gives <folder#> a name.
 
  @mail/file <msg-list>=<folder#>
        This command moves all messages in msg-list from the current
        folder to a new folder, <folder#>.

& mail-admin
 
  The @mail command can also take the following switches:
 
    @mail/stats [<player>]    --  Basic mail statistics.
    @mail/dstats [<player>]   --  Also provides read/unread count.
    @mail/fstats [<player>]   --  Does all that, plus gives space usage.
 
    @mail/debug <action>[=<player>]
    @mail/nuke
 
  Only wizards may stats players other than themselves. The mail statistics
  commands are computationally expensive, and thus are subject to "daytime"
  restrictions. They also cost the same as a @find (100 credits).
 
  The /debug switch does sanity checking on the mail database, and may only
  be used by a wizard. "@mail/debug sanity" just does the check; the command
  "@mail/debug clear=<player name or dbref number>" wipes mail for an object.
  "@mail/debug fix" attempts to repair problems noted in the sanity check.
 
  The /nuke switch destroys the post office, erasing all @mail everywhere.
  It may only be used by a wizard.
 
  Also, admin may set the @amail attrib on their char.  When somebody sends
  you mail, it will trigger that attrib if it exists.

& mail-examples
 
  Here is an example of mailing a player, where is the player will be "bob",
  and sending the mail.
 
  > @mail bob = The MUX              - This is the Subject line. 
 
  Sending mail to player 'Bob'
  > -Hi bob.                         - This is where you will enter the body
                                       of the message.
  Text Added.
  > @send                            - Basically, sends the @mail.
 
  MAIL: You sent your message to 'Bob'.   
 
& @mvattr

  Command: @mvattr <object>=<old>,<new>[,<copy1>]...
  This command moves attributes around on an object.  The attribute <old> is
  renamed <new> (and is copied to <copy1>, <copy2> and so on if specified).
  If you cannot modify the <old> attribute (for instance if you are trying to
  move the Last attribute, or if it were owned by another player), then a new
  copy is made and the original is not removed.
  See also: @set.

& @name

  Command: @name <object> = <new name>

  Changes the name of <object>.  <object> can be a thing, player, exit, or
  room, specified as <name> or #<dbref> or 'me' or 'here'.
 
  See '@list options' as to whether or not a player name may contain 
  spaces.

& @notify

  Command: @notify[/<switches>] <object>[/<attribute>][=<count>]
 
  Notifies the semaphore <object>, running the first command that waited on
  <object> using the '@wait <object>=<command>' or '
  @wait <object>/<time>=<command>' forms of the @wait command.  If <count> is
  specified, it indicates the number of times the semaphore is notified.
  If there are no commands (or less than <count> commands) pending for
  <object>, then subsequent @waits will not block until the semaphore count
  reaches zero again. @notify may also take an argument of the form
  <object>/<attribute>, which notifies commands that are being blocked on
  an attribute other than the default 'Semaphore'. This allows blocking of
  muliple sets of commands on a single object, using different attributes.
 
  The following switches are available:
     /first - (default) Notify the first command waiting on the indicated
              semaphore (or the first <count> commands).
     /all   - Notify all commands waiting on the semaphore and reset the
              semaphore count to zero.  <count> is ignored.
 
  See also: @drain, @ps, @wait, SEMAPHORES

& @oemit

  Command: @oemit <player>=<message>
 
  Emits <message> to everyone in the current location of <player> except
  <player>.
 
  See also:  @remit, @emit, @pemit, @npemit, SPOOFING.

& @open

  Command: @open[/<switches>] <direction list> [=<number>[,<direction list>]]
  Creates an exit in the specified direction(s). If <number> is specified,
  it is linked to that room. Otherwise, it is created unlinked. You or anyone
  else may use the '@link' command to specify where the unlinked exit leads.
  Opening an exit costs 1 coin. If you specify <number>, linking costs 1 more
  coin.  You can specify a second direction list (after the comma), which is 
  automatically opened in the room that the new exit goes TO and which is
  linked back to where you are.  I.e.  @open north;n=#1234,south;s
  would open exit 'north;n' from here to #1234, and an exit 'south;s'
  from #1234 to here, assuming you have rights to open exits and link to
  the rooms in question.
 
  The following switches are available:
     /location  - Create the exit in your location (default).
     /inventory - Create the exit on yourself.
 
  See also: @dig, @link, LINKING.

& @parent

  Command: @parent <object> [=<parent>]
  This command sets the parent of <object> to <parent> (or clears the parent
  if <parent> is omitted.  You must control <object>, and must own <parent>.
  See also: PARENT OBJECTS.

& PARENT OBJECTS

  Topic: PARENT OBJECTS
 
  Parent objects provide a way for several objects to inherit common
  attributes, exits, and $-commands from a single object, so that changing
  the parent object affects all of its children.  When searching for
  attributes or exits, first the object itself is checked, then the parent
  is checked only if the object does not have what was searched for.
 
  Any attribute the parent object has will be passed down to its children,
  if they don't already have one. For instance, if the child object has no
  description, it will inherit the description of its parent.
 
  Any exits the parent object has will show up in the exit list of the
  child, and may be used as normal exits.
 
  The parent is searched for $-commands as well as the child, and only
  attributes that are unique to the parent are checked, so that conflicting
  attribute names are skipped.  If both have an attribute named "cmd1",
  only the child's "cmd1" attributes is checked for a $-command.
 
{ 'help parent2' for more }

& PARENT2 

  Topic: PARENT OBJECTS (continued)
 
  A parent object may itself have a parent, up to a configurable limit
  (usually 10 levels).  The parent need not be the same type as its children,
  and flags and locks are not inherited from parent objects.  You may not
  create parent loops.
 
  See also: @parent, parent().

& @password

  Command: @password <old password> = <new password>
 
  This command changes your password.

& @pemit

  Command: @pemit[/switches] <what>=<message>

  Emits <message> only to <what>, or to <what>'s contents of the /contents
  switch is given.  <what> must be either in the same location as you or
  be something you own.  You can also @pemit to distant players if
  pagelocks allow you to page them, and this costs as much as a page
  <This feature is not present in all MUXes>.  You cannot @pemit to the
  contents of something you don't own.
 
  The /list switch to this command allows you to @pemit a message to
  a list:  @pemit/list <object 1> [<object 2> <object N>] = <message>
  There can be any number of objects in the list. The objects must be
  specified by dbref number. This can be combined with other switches.

  The following switches are also available:
    /contents - Send the message to the contents of the named object.
    /html     - Send the message in HTML format (Pueblo).
    /noeval   - Do not parse the message.
    /object   - Send the message to the named object.

  See also: page, @remit, @emit, @oemit, SPOOFING.

& @npemit

  Command: @npemit[/switches] <what>=<message>

  Almost exactly like @pemit and it takes the same switches. However,
  it does not evaluate <message> at all. So, @npemit differs from
  @npemit/noeval in that no space compression is done.
 
  See also: @pemit
 
& @power

  Command: @power <object>=[!]<power>
 
  This is a command that allows the granting of special powers to objects of
  any type.
 
  See also: powers list
  
& powers list

  announce          Can use the @wall command.
  boot              Can use the @boot command.
  builder           Can build, if the builder power is enabled.
  chown_anything    Can @chown anything to anyone.
  comm_all          Like a wizard with respect to channels.
  control_all       Can modify any object in the database.
  expanded_who      Sees the wizard WHO, and SESSION commands.
  find_unfindable   Can locate unfindable people.
  free_money        Unlimited money.
  free_quota        Unlimited quota.
  guest             Is this a guest character?
  halt              Can @halt anything, and @halt/all.
  hide              Can set themselves DARK.
  idle              No idle timeout.
  long_fingers      Can get, look, whisper, etc from a distance.
 
{ 'help powers list2' for more }
 
& powers list2
  monitor           Can set or reset monitor flag.
  poll              Can set the @poll.
  prog              Can use @program on players other than themself.
  search            Can @search anyone.
  see_all           Can examine and see attributes like a wizard.
  see_queue         Can @ps/all or @ps any player.
  stat_any          Can @stat any player.
  steal_money       Can give negative money.
  tel_anywhere      Can teleport anywhere.
  tel_anything      Can teleport anything (includes tel_anywhere)
  unkillable        Cannot be killed with the 'kill' command.
 
  See also: @power
 
& @program
  Command: @program <player>=<obj/attr>[:<prefix>]
  
  This command allows for small 'programs' within MUX. To understand this
  command, you must first understand the fact that it completely bypasses any
  commands, built-in or otherwise, and allows you to send user-input directly
  into your code.
 
  A simple example:
 
  @va me=$start:@prog %#=me/vb:Please enter a word:
  @vb me=@emit You entered %0!;@prog %#=me/vc:Please enter another word:
  @vc me=@emit This time, you entered %0. You're done!
 
  > start
  Please enter a word:
  > foobar       (Note that @program literally gives you a '>' prompt.)
  You entered foobar!
  Please enter another word:
  > hoopla
  This time you entered hoopla. You're done!
{ 'help @program2' for more }
 
& @program2
 
  As you can see, this command basically takes what a user types at the
  prompt, stuffs it into %0 in the code in <obj/attr>, and then triggers
  that attribute. Note that when @program triggers an attribute, the enactor
  of that triggered attribute is <player>, and is inserted into %#.
  r-registers are preserved when @program triggers an attribute.
 
  An optional message, <prefix>, may be specified and will be output before
  the @program prompt. This is useful for telling the user what information
  they need to supply.
 
  A player caught in @program may send a command through to the normal
  command processor at the @program prompt by prefixing it with the '|'
  character, for example, '|WHO'.
 
  See also: @quitprogram.

& @ps
  Command: @ps[/<switches>] [<object>]
  Lists information about the commands you have on each of the queues.
  Unless the /summary switch is used, this command lists all the commands you
  have on the queues, optionally along with their enactor and arguments.
  Commands scheduled to be executed at a later time (by the @wait command)
  also show the number of seconds until they will be executed and/or the
  semaphore on which they are waiting.  If <object> is specified, only
  commands run by <object> are listed, otherwise all commands run by any of
  your objects is listed.  A summary of the number of commands listed and the
  total number of commands in the queues is also displayed.  This command is
  useful for identifying infinite loops in programs.
 
  The following switches are available:
     /brief   - (default) Display a brief summary that shows the semaphore
                number, time-to-wait, object running the command, and the
                command to be run.
     /long    - In addition to the information in the /brief report, display
                the name and number of the object that caused the command
                to be run (the enactor) and the arguments to the command.
     /summary - Display just the queue counts.
 
  See also: @notify, @wait.

& @quitprogram
 
  Command: @quitprogram <player>
  Terminates the @program for player. If <player> is not specified, then it
  works upon the enactor (a player may quit a program while they are in it
  by piping out @quitprogram, see 'help @program').
 
  See also: @program.
 
& @quota

  Command: @quota
  Lists your total building quota and the amount you have remaining.
  Creating objects, digging rooms, and opening exits all consume quota.
  See also: @create, @dig, @open.

& @robot

  Command: @robot <name>=<password>
  Creates a robot player owned by you.  The robot has its ROBOT flag set, so
  it may use the OUTPUTPREFIX and OUTPUTSUFFIX commands that most publicly
  available robot programs require.  This command costs 1000 coins.
  Note that some sites do not restrict OUTPUTSUFFIX and OUTPUTPREFIX to
  robots.
  See also: OUTPUTPREFIX, OUTPUTSUFFIX, ROBOT, TYPES OF OBJECTS.

& @search

  Command: @search [<player>] [<class>=<restriction>[,<low>[,<high>]]]
 
  Displays information about objects that meet the search criteria.
  Because this command is computationally expensive, it costs 100 coins.
  <player> restricts the search to the named player, while <class>
  and <restriction> control the objects listed.  Type 'help search classes'
  for a list of the classes you may use.

  Except when getting lists of players ('@search type=player' or
  '@search flags=P'), you may only search for objects that you own.
  You may limit the range of the search with <low> and <high>, which specify
  the objects to start and stop the search at, respectively.  The default for
  <low> is #0 and the default for <high> is the last object in the database.
 
  Examples:
    @search flags=PWc              <-- search for connected wizards.
    @search type=room              <-- list all rooms owned by me.
    @search eval=gt(money(##),10)  <-- search for things worth more than 10.
    @search type=room,100,300      <-- Rooms between #100 and #300, inclusive
    @search object=Test,5000       <-- Things starting with Test from object
                                       #5000 to the end of the database.
  See also: @find, search().

& @set

  Command: @set[/<switch>] <object>=[!]<flag>
           @set[/<switch>] <object>=<attribute>:<value>
           @set[/<switch>] <object>=<attribute>:_<fromobj>/<fromattr>
           @set[/<switch>] <object>/<attr>=[!]<attrflag>
 
  The first form sets (or clears) the indicated flag on <object>, the
  second form sets the <attribute> attribute on <object> to <value>,
  creating a new user-named attribute if there is no attribute named
  <attribute>.  The third form copies an attribute from another object, and
  the fourth form sets (or clears) an attribute flag on the <attr> attribute
  of <object>.
 
  When setting attributes on an object, you may also use the command
  '@<attribute> <object> = <value>' if the attribute is a predefined
  attribute.  You may also use the command '&<attribute> <object> = <value>'
  to set either predefined attributes or user-named attributes.  Either of
  these is equivalent to the second form of the @set command.
{ 'help @set2' for more }

& @set2

  The following flags may be set using the fourth form of the @set command:
     no_command - Prevent $-commands and ^-patterns defined in the attribute
                  from being performed.
     no_inherit - Prevents children of the object from obtaining the 
                  attribute.  From their perspective the attribute does not
                  exist.
     visual     - Anyone may see the attribute when they examine you, and
                  may get the attribute with get().
     hidden     - The attribute is only visable to wizards.
     regexp     - When $-commands are matched, treat the pattern as a
                  regular expression rather than a wildcard glob pattern.
     wizard     - The attribute may only be changed by wizards.
 
  The @set command takes the following switch:
     quiet      - Inhibit 'Set.' acknowledgement messages.
 
  See also: @lock, @lock, examine, FLAGS, &.

& @stats

  Command: @stats[/all] [<player>]
  Display the number of objects in the game.  @stats/all gives a
  breakdown by object types.  If <player> is specified, the breakdown
  for the named player is given.  You may only list individual counts
  for yourself.  If invoked with no arguments or switches this command is
  free, but if you specify either /all or <player>, then this  command costs
  100 coins to run, because it is computationally expensive.
  See also: stats().

& @sweep

  Command: @sweep[/<switches>]
  This command tells you all of the objects, players, and exits that are
  listening in the room you are currently in, as well as the objects you are
  carrying.  Most objects only listen for a particular string or phrase, so
  they normally do not pose a problem if you need privacy.  You will have to 
  be careful of players, puppets, and audible exits since they will hear
  everything you say and do.  There are several switches that may be used to
  limit the type of listeners that are checked for.  They are:
     /here      - Check the room I am in.
     /inventory - Check my inventory.
     /exits     - Check exits in the room.
 
     /commands  - Check for objects that have $-commands set on them.
     /connected - Check for connected players and their puppets.
     /listeners - Check for objects with @listen set to something.
     /players   - Check for players and their puppets, whether or not they
                  are connected.
 
  The default is to search for everything.  If you specify one or more
  switches from either category (either location or listener type then only
  that location or listener type is checked.
  See also: @listen, AUDIBLE, PUPPETS.

& @switch

  Command: @switch[/<switches>] <string>=<t1>,<c1> [,<tN>,<cN>]... [,<cD>]
  Compares <string> against the targets <t1>, <t2>, etc, until a match is
  found, at which time the corresponding list of commands is performed.
  Wildcards, and the < and > operators are allowed in the targets.  By
  default, any list whose target matches the string is executed (the targets
  are not mutually exclusive). If no target matches, the default list
  <cD> is executed.
 
  The following switches are available:
     /all   - (default) Perform the actionlists associated with all targets
              that match <string>.
     /first - Perform only the actionlist associated with the first target
              that matches <string>.

& @teleport

  Command: @teleport [<object>=] <room/thing>
           @teleport [<object>=] <exit>
           @teleport [<object>=] home
 
  The first form of the @teleport command moves <object> (or you) to the named
  room or thing.  The second form sends <object> (or you) to the destination
  of the named exit, while the third form sends <object> (or you) home.
  If the destination room has a drop-to, the object will go to the drop-to
  instead of the named location.

  For the first form of the @teleport command, the object being teleported 
  must pass its location's TeloutLock; and you must control the destination,
  or it must be JUMP_OK and you must pass the destination's TportLock.
 
  The second and third forms let you remove any object from locations you
  control by sending them through an exit or to their home.

  The following switch is available:
     /quiet - Teleports without setting off success or failure messages.
 
  See also: JUMP_OK, @lock (tport and telout), @tfail, @otfail, @atfail,
            @tofail, @otofail, @atofail.

& @trigger 

  Command: @trigger[/<switch>] <object>/<attr> [=<param> [, <param>]... ]
  Invokes an action list stored in an attribute on an object.  The triggering
  object becomes the enactor and the positional parameters %0 through %9
  are set to the supplied parameters.
 
  The @trigger command supports the following switch:
     quiet      - Inhibit 'Triggered.' acknowledgement messages.
 
  See also: LOOPING.

& @unlink

  Command: @unlink <room/exit>
  This command removes drop-tos on rooms and clears the destination on exits.
  Once unlinked, an exit may be taken over by anyone with the @link command.
  See also: @link, LINKING.

& @unlock

  Command: @unlock <object>
           @unlock <object>/<attrib>
  The first form removes the lock on <object>, so that anyone may pass
  through (if an exit) or pick it up (if a player or an object).
 
  The second form clears the locked flag on the indicated attribute of the
  named object.  This allows the attribute to change ownership to the new
  owner automatically when the object is @chowned, and allows the owner
  of the object to @chown the attribute to themself or to overwrite it.
  You must own the attribute to be unlocked, but you do not need to own the
  object.
  See also: @chown, @lock, ATTRIBUTE OWNERSHIP.

& @verb

  Command: @verb <victim>=<actor>,<what>,<def>,<owhat>,<odef>,<awhat>,<args>
 
  This command provides a way to do user-defined verbs with associated
  @attr/@oattr/@aattr groups. Invoking it does the following:
  
  <actor> sees the contents of <victim>'s <what> attribute, or
    the <def> string if you can't read <victim>'s <what> attribute.
  Everyone in the same room as <actor> sees the contents of
    <victim>'s <owhat> attribute, with <actor>'s name prepended,
    or <odef>, also with <actor>'s name prepended, if you can't read
    <victim>'s <owhat> attribute.
  If you control <victim>, then he executes the contents of his <awhat>
    attribute.
  
  By supplying up to nine <args>, you may pass those values on
  the stack (i.e. %0, %1, %2, etc. up through %9).
 
  You must control the actor, but need not control the victim.  Note that
  if you don't have the ability to read the appropriate attributes (whether
  because you control the victim, he is VISUAL, or the attributes are set
  VISUAL), the default messages will be used.
 
{ 'help @verb2' for more }

& @verb2

  Here is a description of the arguments to @verb:
    victim - The object that is searched for attributes, and which runs the
             <awhat> attribute if it is found.
    actor  - The object that 'did' the verb, this is the value for %#/%n/etc
             in substitutions, and this object's name is included in the
             message to others in the same location.
    what   - The name of the attribute containing the message to be delivered
             to the actor.
    whatd  - The message to deliver to the actor if the victim does not have a
             <what> attribute, or if it cannot be read.
    owhat  - The name of the attribute containing the message (prefixed by the
             actor's name) that is sent to everyone in the room with the actor.
    owhatd - The message (prefixed by the actor's name) to deliver to others
             in the room with the actor if the victim does not have an <owhat>
             attribute, or it cannot be read.
    awhat  - The name of the attribute that is to be executed by the victim.
    args   - The comma-separated arguments to be passed for substitution
             (%0-%9).  If there is more than one argument, enclose all the
             arguments within curly braces.  Any argument that contains an
             embedded comma needs to be enclosed in curly braces as well.
 
{ 'help @verb3' for more }

& @verb3

  Examples:
    > &xtest test1=You just xtested test1.
    > &oxtest test1=just xtested test1.
    > &axtest test1="I was xtested.  Yikes.  Arg1=%0, Arg2=%1, Arg3=%2.
    > @verb test1=me,xtest,XTEST DFLT,oxtest,OXTEST DFLT,axtest,{a,b c,de}
    You just xtested test1.
    test1 says "I was xtested. Yikes. Arg1=a, Arg2=b c, Arg3=de."
    > &xtest test1
    > @verb test1=me,xtest,XTEST DFLT,oxtest,OXTEST DFLT,axtest,{a,b c,de}
    XTEST DFLT
    test1 says "I was xtested. Yikes. Arg1=a, Arg2=b c, Arg3=de."
    > @fo test1={@verb test1=me,xtest,XTEST D,oxtest,OXTEST D,axtest,{a,b,de}} 
    test1 just xtested test1.
    test1 says "I was xtested. Yikes. Arg1=a, Arg2=b, Arg3=de."
  See also: locate().

& @wait

  Command: @wait <seconds>=<command>
           @wait <object>[/<seconds>]=<command>
           @wait <object>/<attribute>=<command>

  The first form of @wait executes <command> after <seconds> seconds.  The
  second form increments the semaphore count for <object> and executes
  <command> after <object> is notified with the @notify command.  If the
  semaphore count for <object> is negative (because it has been notified more
  times than it has been waited on), then <command> is run immediately.
  If <seconds> is specified in the second form, the command is automatically
  run after <seconds> seconds even if the semaphore isn't notified.  The
  third form allows for blocking multiple sets of commands on the same
  object, using seperate attributes to keep track of the semaphore. This
  command charges a deposit of 10 coins, which is refunded when <command>
  is executed.
  See also: @drain, @notify, @ps, SEMAPHORES.

& @wipe

  Command: @wipe <object>[/<wild-attr>]
 
  This command erases attributes from an object.  All attributes that match
  <wild-attr> (or all attributes, if <wild-attr> is not specified) are removed
  from <object>.  Attributes that you do not have permission to modify (such
  as read-only or locked attributes) are not removed.

& @aahear

  Command: @aahear <object> = <command-list>
  Attribute: Aahear
 
  An Aahear on an object is activated whenever the listen pattern
  matches anything done/said by anything else in the room, including
  itself.  (The Ahear ignores itself, helpful for keeping machines from 
  triggering itself)
 
  Example: @aahear listener = "I heard someone (maybe me?) say the word!
  See also: @ahear, @amhear, @listen.

& @aclone

  Command: @aclone <object> = <command-list>
  Attribute: Aclone
 
  Sets the actions to be taken by a new object that has just been created
  as the result of a @clone command.  The contents of the Aclone attribute
  are run by the new object and not by the old object.
 
  This attribute is only meaningful for things, and will never be
  automatically triggered on other object types.
  It is also possible to check the zone object/objects in the zone parent
  room for an @adisconnect. If one is found, it will be executed when a 
  player disconnects in that zone.
  
  Example: @aclone Time bomb = @wait 600=@trig me/va;@wait 10=@trig me/vb
           @va time bomb = :EXPLODES with a thundering roar;@destroy me
           @vb time bomb = :ticks.; @wait 10=@trig me/vb
  See also: @clone.

& @aconnect

  Command: @aconnect <object> = <command-list>
  Attribute: Aconnect
 
  Sets the actions to be taken by a player right after connecting to the
  game.  This attribute is only meaningful for players, and will never be
  automatically triggered on other object types.
  It is also possible to check the zone object/objects in the zone parent
  room for an @aconnect. If one is found, it will be executed when a player
  connects in that zone.
  
  Example: @aconnect me = check.my.mailbox
  See also: @adisconnect.

& @adescribe

  Command: @adescribe <object> = <command-list>
  Attribute: Adescribe
 
  Sets the actions to be taken when <object> is looked at.
 
  Example: @adesc kitten = :rubs against %n's legs affectionately.
  See also: look, @desc, @idesc, @odesc.

  See also "help think"

& @adfail

  Command: @adfail <object> = <command-list>
  Attribute: Adfail
 
  Sets the action to be taken by an object when someone tries to drop it
  but fails because they didn't pass the object's drop lock.
 
  Example: @adfail sword = @name me=Cursed Sword;:laughs maniacally.
  See also: drop, @dfail, @odfail, @lock.

& @adisconnect

  Command: @adisconnect <object> = <command-list>
  Attribute: Adisconnect
  Sets the actions to be taken by a player right after disconnecting from
  the game.
 
  This attribute is only meaningful for players, and will never be
  automatically triggered on other object types.
 
  Example: @adisconnect me = home
  See also: @aconnect.

& @adrop

  Command: @adrop <object> = <command-list>
  Attribute: Adrop
 
  Sets the action to be taken by an object when it is dropped, or by an exit
  when it is successfully used.
 
  Example: @adrop plastique = kill %n=100; @destroy me
  See also: drop, @drop, @odrop, DROP-TO, EXITS.

& @aefail

  Command: @aefail <object> = <command-list>
  Attribute: Aefail
 
  Sets the action to be taken by an object when someone tries to enter it
  but fails because the object is not ENTER_OK or the player fails the
  object's enter lock.
 
  The enter lock only affects the 'enter' command and its aliases (set via
  the @ealias command), it does not affect exits that lead to the object or
  teleporting in.
 
  This attribute is meaningful for players and things, and will never be
  automatically triggered on rooms or exits.
 
  Example: @aefail car = @emit ;'s alarm starts wailing when %n tries
                         to break in.
  See also: @aenter, @efail, @ealias, @enter, @oefail, @oenter, enter,
            ENTER_OK.

& @aenter

  Command: @aenter <object> = <command-list>
  Attribute: Aenter
 
  Sets the action to be taken by an object or room when someone enters it,
  whether by using an exit, the enter or leave commands, or by teleporting.
 
  This attribute is meaningful for players, things, and rooms, and will never
  be automatically triggered on exits.
 
  Example: @aenter car = :starts its engine, eagerly awaiting a road trip.;
                         "Beep Beep!
  See also: enter, @enter, @oenter, ENTER_OK.

& @afail

  Command: @afail <object> = <command-list>
  Attribute: Afail
 
  Sets the commands to be performed by <object> when one of these events
  occurs:
 
    - For exits: Someone tries to traverse the exit but cannot because they
      fail the exit's default lock or the exit is not linked.
    - For players and things: Someone tries to pick up the object but cannot
      because they fail the object's default lock.
    - For rooms, players, and things: Someone looks around inside the room,
      player, or thing and fails the object's default lock.
 
  Example:
    > @afail vase = :falls to the floor and smashes to pieces.;@destroy me
  See also: @fail, @ofail, FAILURE.

& @agfail

  Command: @agfail <object> = <command-list>
  Attribute: Agfail
 
  Sets the action to be taken by an object when someone tries to give it
  away but fails because they didn't pass the object's give lock.
 
  Example: @agfail sword = @name me=Cursed Sword;:laughs maniacally.
  See also: give, @gfail, @ogfail, @lock.

& @ahear

  Command: @ahear <object> = <command-list>
  Attribute: Ahear
 
  Sets the actions to be taken after the object hears a string that matches
  the pattern in the Listen attribute which was not produced by the object
  itself.  Messages that are produced by the object itself are ignored.
 
  Example: @ahear clock = "The time is now [time()].  >> BONNNNGGGGG <<
  See also: @aahear, @amhear, @listen.

& @akill

  Command: @akill <object> = <command-list>
  Attribute: Akill
 
  Sets the actions to be taken by an object after it is killed and has
  returned to its home.
 
  This attribute is only meaningful for players and things, and will never be
  automatically triggered on other object types.
 
  Example: @akill lion = south; :leaps onto %n, roaring loudly.;kill %n=100
  See also: kill, @kill and @okill, BEING KILLED, IMMORTAL, WIZARD.

& @aleave

  Command: @aleave <object> = <command-list>
  Attribute: Aleave
 
  Sets the action to be taken by an object or room when someone leaves it,
  whether by using an exit, the enter or leave commands, or by teleporting.
 
  This attribute is meaningful for players, things, and rooms, and will never
  be automatically triggered on exits.
 
  Example: @aleave car = :stops to let %n out.;:revs its engine, hoping
                         another brave soul would like a ride.
  See also: leave, @leave, @oleave.

& @alfail

  Command: @alfail <object> = <command-list>
  Attribute: Alfail
 
  Sets the action to be taken by an object when someone tries to leave it
  but fails because the player fails the object's leave lock.
 
  The leave lock only affects the 'leave' command and its aliases (set via
  the @ealias command), it does not affect going home, using an exit in the
  location, or teleporting out.
 
  This attribute is meaningful for players and things, and will never be
  automatically triggered on rooms or exits.
 
  Example: @alfail box = :rattles around as %n tries to escape.
  See also: @aleave, @lalias, @leave, @lfail, @oleave, @olfail, leave.

& @alias

  Command: @alias <player> = <name>
  Attribute: Alias
 
  Provides an alternate name by which the player is known.  The alternate
  name is only used for players when referenced as '*<name>' or by commands
  that only take playernames (such as page or @stats).  You may not set
  an alias on any other object type.
 
  When setting an alias, the alias is checked to see that it is both a legal
  player name and not already in use.  Only if both checks succeed is the
  alias set.
 
& @amail

  Command: @amail <player> = <command-list>
  Attribute: Amail
 
  Sets the actions to be taken after a player receives @mail. This should
  *never* @mail another player, as this could cause an infinite loop.
 
  Example: @amail me=@mail/file [mail()]=2
           This would place all incoming messages in folder #2.
  See also: @mailsucc, @signature, @mail.
 
& @mailsucc

  Command: @mailsucc <player> = <message>
  Attribute: Mailsucc
 
  Sets a message to be displayed to the sender whenever <player> receives
  mail.
 
  Example: @mailsucc me=Thanks for the mail.
  See also: @amail, @signature, @mail.
 
& @signature

  Command: @signature <player> = <message>
  Attribute: Signature
 
  Sets a message to be appended to ever @mail message you send. It is
  appended directly at the end of the message, so if you wish to start the
  signature on a new line you should begin it with a %r.
 
  Example: @signature me=%rThis is a mail signature. (Note: You might want 
  to include the %r at the front of the signature, other wise it will be 
  combined with the @mail message.)

  See also: @mailsucc, @amail, @mail.
 
& @amhear

  Command: @amhear <object> = <command-list>
  Attribute: Amhear
 
  Sets the actions to be taken after the object hears a string that matches
  the pattern in the Listen attribute which was produced by the object
  itself.
  Messages that are produced by anything other than the object itself are
  ignored.
 
  Example: @amhear listener = "Wait a minute.  I said the trigger word!
  See also: @aahear, @ahear, @listen.

& @amove

  Command: @amove <object> = <command-list>
  Attribute: Amove
 
  Sets the action to be taken by an object whenever it moves from one 
  location to another, whether by using an exit, entering or leaving an
  object, teleporting, or going home.
 
  This attribute is meaningful for players, and things and will never be
  automatically triggered on other object types.
 
  Example: @amove car = @vz me=[extract(%vz,1,19)] [loc(me)]
  See also: @move, @omove.

& @apay

  Command: @apay <object> = <command-list>
  Attribute: Apay
 
  Sets the actions to be taken after the object is given the number of coins
  specified in its Cost attribute.  If the giver tries to give more than that
  number of coins, the excess is refunded, and if less than the necessary
  amount is given then it is all given back and a snide message is sent to
  the giver.
 
  This attribute is only meaningful for players and things, and will never be
  automatically triggered on other object types.
 
  Example: @apay Coke machine = @clone Can of Coke; :drops a can on the
                                floor.
  See also: give, @cost, @opay, @pay.

& @arfail

  Command: @arfail <object> = <command-list>
  Attribute: Arfail
 
  Sets the action to be taken by an object when someone tries to give it
  something that fails its give lock.
 
  Example: @arfail merchant = "I don't buy such junk.  Begone!;
                              @tel %#=cheater_exit
  See also: give, @agfail, @gfail, @ogfail, @orfail, @rfail, @lock.

& @asuccess

  Command: @asuccess <object> = <command-list>
  Attribute: Asucc
 
  Sets the actions to be taken by an object when someone successfully picks
  it up (because they passed the lock), by an exit when someone passes
  through it, or when someone looks at a room and passes the room's lock.
 
  Example: @asucc kitten = :climbs up your sleeve and nuzzles your face.
  See also: @osucc, @success, SUCCESS.

& @atfail

  Command: @atfail <object> = <command-list>
  Attribute: Atfail
 
  Sets the action to be taken by an object when someone tries to teleport
  there but fails.
 
  Example: @atfail here = @page [owner(me)]=%N tried to teleport here.
  See also: @teleport, @tfail, @otfail, @lock.

& @atofail

  Command: @atofail <object> = <command-list>
  Attribute: Atofail
 
  Sets the action to be taken by an object when someone tries to teleport
  out but fails.
 
  Example: @atofail here = @page [owner(me)]=%N tried to teleport out.
  See also: @teleport, @tofail, @otofail, @lock.

& @atport

  Command: @atport <object> = <command-list>
  Attribute: Atport
 
  Sets the actions to be performed by object whenever it teleports.
  The actions are performed after the object moves to its new location.
 
  This attribute is only meaningful for players and things, and will never be
  automatically triggered on other object types.
  
  Example: @atport me = &TEL.COUNT me=add(v(TEL.COUNT),1)
 
  See also: @otport, @oxtport, @tport, @teleport.

& @aufail

  Command: @aufail <object> = <command-list>
  Attribute: Aufail
 
  Sets the list of commands to be run when someone 'use's the object but
  fails the object's use lock.  Note that the other functions controlled
  by the use lock (paying, listening, and $-commands) do not trigger
  Aufail.
 
  Example: @aufail robot = "I _told_ you to leave me alone; kill %n=100
 
  See also: @oufail, @ufail, @use.

& @ause

  Command: @ause <object> = <command-list>
  Attribute: Ause
 
  Sets the actions to be taken when someone uses the object with the use
  command.
 
  This attribute is only meaningful for players and things, and will never be
  automatically triggered on other object types.
 
  Example: @ause grenade = :EXPLODES with a thundering roar; kill %n=100;
                           @destroy me
  See also: use, @ouse, @use.

& @away

  Command: @away <object> = <message>
  Attribute: Away
 
  This attribute is sent as a message to anyone who tries to page you when 
  you are not connected.
 
  This attribute is only meaningful for players, and will never be
  automatically referenced on other object types.
 
  Example: @away me = Hey, I'm not even connected.  So why are you paging me?
  See also: @idle, @idletimeout, @reject, page.

& @charges

  Command: @charges <object> = <count>
  Attribute: Charges
 
  This attribute allows you to limit the number of times an object can be
  used.  If there is a charges attribute it is decremented each time an
  action on the object is triggered.  Once it reaches zero, normal triggering
  stops and the Runout attribute (if one is present) is run instead.
 
  Example: @charges Fireball wand = 5
  See also: @runout.

& @cost

  Command: @cost <object> = <amount>
  Attribute: Cost
 
  Sets the number of coins that need to be given to an object to trigger the
  Pay, Opay, and Apay attributes.  If the object is given more than this
  amount, the excess is returned to the giver, while if less than this amount
  is given the entire amount is returned, a snide message is sent to the
  giver, and the Apay, Opay, and Pay attributes are not used.
 
  This attribute is only meaningful for things, and will never be
  automatically triggered on other object types.
 
  Example: @cost Coke machine = 25
  See also: give, @apay, @opay, @pay.

& @daily
 
  Command: @daily <object>=<command-list>
  Attribute: Daily
 
  This attribute is automatically triggered once per day. No guarantees are
  made as to what time it will execute.
 
& @describe

  Command: @describe <object> = <description>
  Attribute: Desc
 
  Sets the description for <object>, which others see when they look at the
  object.  Giving all your objects, rooms, and exits good descriptions is
  considered to be good building practice.
 
  Function references and %-substitutions are allowed in descriptions, and
  are evaluated when someone looks at the object.  In function references,
  'me' refers to the object being looked at, while %-substitutions that refer
  to the enactor (such as %n, %#, %p, etc) refer to the looker.
 
  Examples:
    <object> @desc vase = You see a delicate Ming vase.
    <exit>   @desc elevator = There is an elevator to the east.
  See also: look, @adescribe, @odescribe.

& @dfail

  Command: @dfail <object> = <message>
  Attribute: Dfail
 
  Sets the message that a player sees when he tries to drop the object but
  fails because he didn't pass the object's drop lock.
 
  Function references and %-substitutions are allowed in drop failure
  messages, and are evaluated when someone drops the object.  In function
  references, 'me' refers to the object being dropped, while %-substitutions
  that refer to the enactor (such as %n, %#, %p, etc) refer to the dropper.
 
  This attribute is only meaningful for players and things, and will never be
  automatically triggered on other object types.
 
  Example: @dfail sword = The sword has welded itself to your hand.
  See also: drop, @adfail, @odfail, @lock.

& @drop

  Command: @drop <object> = <message>
  Attribute: Drop
 
  Sets the message that a player sees when he drops the object, or after he
  goes through the exit.
 
  Function references and %-substitutions are allowed in drop messages, and
  are evaluated when someone drops the object.  In function references,
  'me' refers to the object being dropped, while %-substitutions that refer
  to the enactor (such as %n, %#, %p, etc) refer to the dropper.
 
  This attribute is only meaningful for players and things, and will never be
  automatically triggered on other object types.
 
  Examples: <object> @drop vase = You gently put down the delicate vase.
            <exit>   @drop elevator = The elevator doors close behind you.
  See also: drop, @adrop, @odrop, DROP-TO, EXITS.

& @ealias

  Command: @ealias <object> = <entrance-list>
  Attribute: Ealias
 
  Sets up a set of alternate commands that may be used as synonynms for the
  command 'enter <object>' when you are in the same location as the object.
  The alternate commands are separated by semicolons just like in exit names.
 
  Entry aliases are checked for after exitnames, builtin MUX commands, and
  leave aliases for the current location, but before $-commands.  If more than
  one object has an entry alias that matches a player's command, the one on
  the object that occurs first in the location contents list is used.
 
  This attribute is meaningful for players and things, and will never be
  automatically looked at on rooms or exits.
 
  Example: @ealias car = get in car; car; climb in; go for a ride
  See also: @lalias, enter, leave.

& @efail

  Command: @efail <object> = <command-list>
  Attribute: Efail
 
  Sets the message that a player sees when he tries to enter the object but
  fails because the object is not ENTER_OK or the player fails the
  object's enter lock.
 
  Function references and %-substitutions are allowed in efail messages, and
  are evaluated when someone fails to enter the object.  In function
  references, 'me' refers to the object that the enactor tried to enter, while
  %-substitutions that refer to the enactor (such as %n, %#, %p, etc) refer to
  the the player who tried (and failed) to enter.
 
  The enter lock only affects the 'enter' command and its aliases (set via
  the @ealias command), it does not affect exits that lead to the object or
  teleporting in.
 
  This attribute is meaningful for players and things, and will never be
  automatically triggered on rooms or exits.
 
  Example: @efail car = The car's door is locked.
  See also: @aefail, @aenter, @ealias, @enter, @oefail, @oenter, enter,
            ENTER_OK.

& @enter

  Command: @enter <object> = <message>
  Attribute: Enter
 
  Sets the message that a player sees when entering an object or room,
  whether by using an exit, the enter or leave commands, or by teleporting.
 
  Function references and %-substitutions are allowed in enter messages, and
  are evaluated when someone enters the object.  In function references,
  'me' refers to the object being entered, while %-substitutions that refer
  to the enactor (such as %n, %#, %p, etc) refer to the player entering the
  object.
 
  This attribute is meaningful for players, things, and rooms, and will never
  be automatically triggered on exits.
 
  Example: @enter car = You climb into the car and buckle your seatbelt.
  See also: enter, @aenter, @oenter, ENTER_OK.

& @fail

  Command: @fail <object> = <message>
  Attribute: Fail
 
  Sets the failure message for <object>.  This message is seen by the actor
  when one of these events occurs:
 
    - For exits: Someone tries to traverse the exit but cannot because they
      fail the exit's default lock or the exit is not linked.
    - For players and things: Someone tries to pick up the object but cannot
      because they fail the object's default lock.
    - For rooms, players, and things: Someone looks around inside the room,
      player, or thing and fails the object's default lock.
 
  Substitution and evaluation is performed on the message before it is shown.
 
  Example:
    > @fail table = It's too heavy to lift!                            <thing>
    > @fail doorway = The doorknob does not turn.                       <exit>
  See also: get, @afail, @ofail, FAILURE.

& @filter

  Command: @filter <object> = <pattern>[, <pattern>...]
  Attribute: Filter
 
  This attribute specifies a series of patterns to be used to suppress
  text normally forwarded by the AUDIBLE flag.  If the desired pattern
  contains a comma, the pattern may be enclosed in curly braces {}.
 
  Example:
    > @fo test=out
    > @set #378=puppet
    test> test grows ears and can now hear.
    > @filter out = {* has arrived.},{* has left.}
    Set.
    > :has not arrived.
    Wizard has not arrived.
    test> From a distance, Wizard has not arrived.
    > :has arrived.
    Wizard has arrived.
  See also:  AUDIBLE, @forwardlist, @infilter, @inprefix, @prefix.

& @forwardlist

  Command: @forwardlist <object> = <dbref-list>
  Attribute: Forwardlist
 
  Specifies a list of locations (specified by their db numbers) that are to
  receive messages heard by <object> (filtered by the @filter attribute and
  prefixed by the @prefix attribute).  The messages are only forwarded if
  <object> has its AUDIBLE flag set.
  See also: @filter, @prefix, AUDIBLE.

& @gfail

  Command: @gfail <object> = <message>
  Attribute: Gfail
 
  Sets the message that a player sees when he tries to give away the object
  but fails because he didn't pass the object's give lock.
 
  Function references and %-substitutions are allowed in give failure
  messages, and are evaluated when someone tries to give away the object.
  In function references, 'me' refers to the object being given away, while
  %-substitutions that refer to the enactor (such as %n, %#, %p, etc) refer
  to the (attempted) giver.
 
  This attribute is only meaningful for players and things, and will never be
  automatically triggered on other object types.
 
  Example: @gfail sword = You can't give away a cursed sword!
  See also: give, @agfail, @ogfail, @lock.

& @idesc

  Command: @idesc <object> = <message>
  Attribute: Idesc
 
  Sets the internal description for <object>.  The internal description of an
  object will be shown to any player entering it.  If not set, the regular
  description in the Desc attribute is shown instead.
 
  Function references and %-substitutions are allowed in inside descriptions,
  and are evaluated when someone fails to get or look at the object.  In
  function references, 'me' refers to the object being looked at, while
  %-substitutions that refer to the enactor (such as %n, %#, %p, etc)
  refer to the player doing the looking.
 
  This attribute is only meaningful for players and things, and will never be
  automatically triggered on other object types.
 
  Example: @idesc car = You are sitting in the driver's seat of a Volkswagen
                        Beetle.
  See also: enter, @describe, ENTER_OK.

& @idle

  Command: @idle <object> = <message>
  Attribute: Idle
 
  This attribute is sent as a message to anyone who successfully pages you.
  It can be used to tell someone who pages you when you will return
  (if you are going to be away for a while).
 
  This attribute is only meaningful for players, and will never be
  automatically referenced on other object types.
 
  If an @idletimeout is set on the person being paged, you will only see
  the @idle message if that person is more idle than the specified amount
  of time.
 
  Example: @idle me = At dinner.  Back about 7PM.
  See also: @away, @idletimeout, @reject, page.

& @idletimeout

  Command: @idletimeout <object> = <seconds>
  Attribute: IdleTimeout
 
  This attribute is used to determine if your @idle message is sent to
  a player who successfully pages you.
  If you're online and working at the same time, you can set the minimum
  idle time to allow your message to show. so whilst you're not idle your
  @idle message will not show without you having to delete it to hide it. 
 
  This attribute is only meaningful for players, and will never be
  automatically referenced on other object types.
 
  Example: @idle me = Working IRL. Monitoring this window from time to time.
           @idletimeout me = 60
  See also: @away, @idle, @reject, page.

& @infilter

  Command: @infilter <object> = <pattern>[, <pattern>...]
  Attribute: Infilter
 
  This attribute specifies a series of patterns to be used to suppress
  text normally sent to the contents of <object> by @listen.  If the desired
  pattern contains a comma, the pattern may be enclosed in curly braces {}.
 
  Example:
    > @listen sports car=*
    > @fo test=enter sports car
    test has left.
    test> Sports Car(#383Q)
    > :waves.
    test> Wizard waves.
    Wizard waves.
    > @infilter sports = *waves*
    > :waves.
    Wizard waves.
    > :knocks on the window.
    test> Wizard knocks on the window.
    Wizard knocks on the window.
  See also:  @filter, @inprefix, @listen, @prefix.

& @inprefix

  Command: @inprefix <object> = <prefix text>
  Attribute: Inprefix
 
  This attribute, when set, will prefix all text that is sent to the contents
  of <object> by @listen.  The default is to have no prefix, the text is
  forwarded unadorned.
 
  Example:
    > @listen sports car=*
    > @fo test=enter sports car
    test has left.
    test> Sports Car(#383Q)
    > :waves.
    test> Wizard waves.
    Wizard waves.
    > @inprefix sports car = In the mundane world outside,
    test> In the mundane world outside, Wizard waves some more.
    Wizard waves some more.
  See also: @filter, @infilter, @listen, @prefix.

& @kill

  Command: @kill <object> = <message>
  Attribute: Kill
 
  This command sets the message that is shown to anyone who kills <object>.
 
  This attribute is only meaningful for players and things, and will never be
  automatically triggered on other object types.
 
  Function references and %-substitutions are allowed in kill messages, and
  are evaluated when someone kills the object.  In function references, 'me'
  refers to the object that was killed, while %-substitutions that refer to
  the enactor (such as %n, %#, %p, etc) refer to the player doing the killing.
 
  Example: @kill guard = The guard says "I'll get.. you... for... this... %n"
                         as he falls down and dies.
  See also: kill, @akill, @okill, BEING KILLED, IMMORTAL, WIZARD.

& @Lalias

  Command: @lalias <object> = <entrance-list>
  Attribute: Lalias
 
  Sets up a set of alternate commands that may be used as synonynms for the
  command 'leave' when you are inside a player or a thing.  The alternate
  commands are separated by semicolons just like in exit names.
 
  Leave aliases are checked for after exitnames and builtin MUX commands, but
  before enter aliases and $-commands.
 
  This attribute is meaningful for players and things, and will never be
  automatically looked at on rooms or exits.
 
  Example: @lalias car = get out;climb out;out;open door;outside
  See also: @ealias, enter, leave.

& @leave

  Command: @leave <object> = <message>
  Attribute: Leave
 
  Sets the message that a player sees when leaving an object or room, whether
  by using an exit, the enter or leave commands, or by teleporting.
 
  Function references and %-substitutions are allowed in leave messages, and
  are evaluated when someone leaves the object.  In function references,
  'me' refers to the object being left, while %-substitutions that refer
  to the enactor (such as %n, %#, %p, etc) refer to the player leaving the
  object.
 
  This attribute is meaningful for players, things, and rooms, and will never
  be automatically triggered on exits.
 
  Example: @leave car = You unbuckle your seatbelt and climb out of the car.
  See also: leave, @aleave, @oleave.

& @lfail

  Command: @lfail <object> = <command-list>
  Attribute: Lfail
 
  Sets the message that a player sees when he tries to leave it but fails
  because the player fails the object's leave lock.
 
  The leave lock only affects the 'leave' command and its aliases (set via
  the @ealias command), it does not affect going home, using an exit in the
  location, or teleporting out.
 
  This attribute is meaningful for players and things, and will never be
  automatically triggered on rooms or exits.
 
  Example: @lfail plane = You don't have a parachute!
  See also: @aleave, @alfail, @lalias, @leave, @oleave, @olfail, leave.

& @listen

  Command: @listen <object> = <string>
  Attribute: Listen
 
  This attribute contains a wildcard pattern that the object listens for.
  Anything spoken, posed, emitted, or whispered in the room that <object> is
  in, as well as messages resulting from using objects (such as Opay and Succ
  messages) are checked against the Listen attribute.  When the object hears 
  something that matches the pattern, it triggers the Ahear attribute, as
  well as either the Amhear or Aahear attributes, as appropriate,
  substituting %0 the string that matched the first wildcard character in the
  Listen, %1 for the second. etc.  If the pattern in the Listen attribute is
  matched, objects in <object>'s inventory will also hear the message and
  have a chance to match it.  Objects whose Listen attribute is set to
  anything will be listed when a @sweep command is run by someone in the
  same room.
 
  If the @listen pattern is matched, then the object's contents will
  hear the message also, prefixed by the text in @inprefix if it is set.  Any
  text that matches any pattern specified in @infilter will not be sent to
  the contents.
 
  Example: @listen camera = * has arrived.
           @ahear camera = @va me = %va %0
  See also: @aahear, @ahear, @amhear, @sweep, @inprefix, @infilter.

& @move

  Command: @move <object> = <command-list>
  Attribute: Move
 
  Sets the message that an object sees after it moves from one location to
  another, whether by using an exit, entering or leaving an object,
  teleporting, or going home.
 
  This attribute is meaningful for players, and things and will never be
  automatically triggered on other object types.
 
  Example: @move bopper = OK.  You're there now.
  See also: @amove, @omove.

& @odescribe

  Command: @odescribe <object> = <message>
  Attribute: Odesc
 
  Sets the message (prefixed by the player's name) that is shown to others in
  the room when someone looks at <object>.
 
  Example: @odesc vase = carefully inspects the vase.
  See also: look, @adescribe, @describe, @idesc.

& @odfail

  Command: @odfail <object> = <message>
  Attribute: Odfail
 
  Sets the message (prefixed by the player's name) that is shown to others in
  the same room when someone tries to drop <object> but fails because they
  didn't pass the object's drop lock.
 
  Function references and %-substitutions are allowed in drop failure
  messages, and are evaluated when someone drops the object.  In function
  references, 'me' refers to the object being dropped, while %-substitutions
  that refer to the enactor (such as %n, %#, %p, etc) refer to the dropper.
 
  Example: @odfail sword = tries to put down the sword but it leaps back
                                       into %p hand.
  See also: drop, @adfail, @dfail, @lock.

& @odrop

  Command: @odrop <object> = <message>
  Attribute: Odrop
 
  Sets the message (prefixed by the player's name) that is shown to others in
  the room when someone drops <object>, or to others in the room that the
  player arrives in after taking an exit.
 
  Example: <object> @odrop loadstone = puts down the loadstone and then
                                       wipes sweat from %p brow.
           <exit>   @odrop elevator = enters the elevator from the lobby.
  See also: drop, @adrop, @drop, DROP-TO, EXITS.

& @oefail

  Command: @oefail <object> = <command-list>
  Attribute: Oefail
 
  Sets the message (prefixed by the player's name) that is shown to others in
  the same room as the player when he tries to enter the object but fails
  because the object is not ENTER_OK or the player fails the
  object's enter lock.
 
  The enter lock only affects the 'enter' command and its aliases (set via
  the @ealias command), it does not affect exits that lead to the object or
  teleporting in.
 
  This attribute is meaningful for players and things, and will never be
  automatically triggered on rooms or exits.
 
  Example: @oefail car = tries to open the car's door, but it is locked.
  See also: @aefail, @aenter, @ealias, @efail, @enter, @oenter, enter,
            ENTER_OK.

& @oenter

  Command: @oenter <object> = <message>
  Attribute: Oenter
 
  Sets the message (prefixed by the player's name) that is shown to others in
  the location being entered when someone enters <object>.  Note that the
  message is shown to those inside the object, not those outside.
 
  This attribute is meaningful for players, things, and rooms, and will never
  be automatically triggered on exits.
 
  Example: @oxenter wormhole = enters the wormhole from normal space.
  See also: enter, @aenter, @enter, @oxenter.

& @ofail

  Command: @ofail <object> = <message>
  Attribute: Ofail
 
  Sets the others failure message for <object>.  This message is seen others
  in the same location as the actor when one of these events occurs:
 
    - For exits: Someone tries to traverse the exit but cannot because they
      fail the exit's default lock or the exit is not linked.
    - For players and things: Someone tries to pick up the object but cannot
      because they fail the object's default lock.
    - For rooms, players, and things: Someone looks around inside the room,
      player, or thing and fails the object's default lock.
 
  Substitution and evaluation is performed on the message before it is shown.
 
  Examples:
    > @ofail table = tries to pick up the table, but it is too heavy.  <thing>
    > @ofail doorway = tries the knob on the door, to no avail.         <exit>
  See also: get, look, @afail, @fail, FAILURE.

& @ogfail

  Command: @ogfail <object> = <message>
  Attribute: Ogfail
 
  Sets the message (prefixed by the player's name) that is shown to others in
  the same room when someone tries to give away <object> but fails because
  they didn't pass the object's give lock.
 
  Function references and %-substitutions are allowed in give failure
  messages, and are evaluated when someone tries to give away the object.
  In function references, 'me' refers to the object being given away, while
  %-substitutions that refer to the enactor (such as %n, %#, %p, etc) refer
  to the (attempted) giver.
 
  Example: @ogfail blob = tries to give away a sticky blob of goo.
  See also: give, @agfail, @gfail, @lock.

& @okill

  Command: @okill <object> = <message>
  Attribute: Okill
 
  Sets the message (prefixed by the player's name) that is shown to others in
  the room when someone kills <object>.
 
  This attribute is meaningful for players, things, and rooms, and will never
  be automatically triggered on exits.
 
  Example: @okill guard = bashes in the guard's skull, killing him.
  See also: kill, @akill, @kill, BEING KILLED, IMMORTAL, WIZARD.

& @oleave

  Command: @oleave <object> = <message>
  Attribute: Oleave
 
  Sets the message (prefixed by the player's name) that is shown to others in
  the location being left when someone leaves <object>.  Note that the
  message is shown to those inside the object, not those outside.
 
  This attribute is meaningful for players, things, and rooms, and will never
  be automatically triggered on exits.
 
  Example: @oleave wormhole = departs the wormhole to return to normal space.
 
  See also: leave, @aleave, @leave, @oxleave.

& @olfail

  Command: @olfail <object> = <command-list>
  Attribute: Olfail
 
  Sets the message (prefixed by the player's name) that is shown to others in
  the same room as the player when he tries to leave it but fails because the
  player fails the object's leave lock.
 
  The leave lock only affects the 'leave' command and its aliases (set via
  the @ealias command), it does not affect going home, using an exit in the
  location, or teleporting out.
 
  This attribute is meaningful for players and things, and will never be
  automatically triggered on rooms or exits.
 
  Example: @olfail plane = thinks about jumping out of the plane without a
                           parachute, but wisely reconsiders.
  See also: @aleave, @alfail, @lalias, @leave, @lfail, @oleave, leave.

& @omove

  Command: @omove <object> = <command-list>
  Attribute: Move
 
  Sets the message that others in the same location see after the object has
  moved to that location from somewhere else, whether by using an exit,
  entering or leaving an object, teleporting, or going home.
 
  This attribute is meaningful for players, and things and will never be
  automatically triggered on other object types.
 
  Example: @omove car = coasts to a stop.
  See also: @amove, @move.

& @opay

  @opay <object> = <message>
  Attribute: Opay
 
  Sets the message (prefixed by the player's name) that is shown to others in
  the room when someone pays <object> enough to satisfy its Cost attribute.
 
  This attribute is only meaningful for players and things, and will never be
  automatically triggered on other object types.
 
  Example: @opay Coke machine = slips some change into the coin slot on the
                                Coke machine.  You hear some rumbling from
                                inside the machine and a can of Coke appears
                                in the tray at the bottom of the machine.
  See also: give, @cost, @apay, @pay.

& @orfail

  Command: @orfail <object> = <message>
  Attribute: Orfail
 
  Sets the message (prefixed by the player's name) that is shown to others in
  the same room when someone tries to give <object> a thing that does not
  pass <object>'s receive lock.
 
  Function references and %-substitutions are allowed in receive failure
  messages, and are evaluated when someone tries to give away the object.
  In function references, 'me' refers to the intended recipient of the object,
  while %-substitutions that refer to the enactor (such as %n, %#, %p, etc)
  refer to the (attempted) giver.
 
  Example: @orfail merchant = tries to unload some worthless trash on Astinous.
  See also: give, @agfail, @arfail, @gfail, @ogfail, @rfail, @lock.

& @osuccess

  Command: @osuccess <object> = <message>]
  Attribute: Osucc
 
  Sets the message (prefixed by the player's name) that is shown to others in
  the room when someone picks up the named player or thing, goes through the
  named exit, or looks at the room and passes the room's lock.
 
  Setting Osuccess messages on all takeable objects and usable exits is
  considered good building practice.
 
  Examples: <object> @osucc vase = carefully picks up the vase.
            <exit>   @osucc doorway = opens the door and leaves the room.
                                      The door closes behind %o with a click.
  See also: get, look, @asuccess, @success, SUCCESS.

& @otfail

  Command: @otfail <object> = <message>
  Attribute: Otfail
 
  Sets the message (prefixed by the player's name) that is shown to others in
  the same room when someone tries to teleport to somewhere he does not have
  permission.  You do not see this message if they couldn't teleport out of
  their present location.
 
  Function references and %-substitutions are allowed in teleport failure
  messages, and are evaluated when someone attempts to teleport to the
  specified destination.  In function references, 'me' refers to the teleport
  destination, while %-substitutions that refer to the enactor (such as %n,
  %#, %p, etc) refer to the player attempting the teleport.
 
  When a player teleports another object (@tel <object>=<destination>), the
  lock is checked against the player, not the object.
 
  Example: @otfail here = thinks about teleporting to the Magic Room, but
                          decides against it at the last moment.
  See also: @teleport, @atfail, @tfail, @lock.

& @otofail

  Command: @otofail <object> = <message>
  Attribute: Otofail
 
  Sets the message (prefixed by the player's name) that is shown to others in
  the same room when someone tries to teleport out of somewhere they do not
  have permission.
 
  Function references and %-substitutions are allowed in teleport failure
  messages, and are evaluated when someone attempts to teleport from their
  location.  In function references, 'me' refers to the player's location,
  while %-substitutions that refer to the enactor (such as %n,
  %#, %p, etc) refer to the player attempting the teleport.
 
  Example: @otofail here = thinks about teleporting from the Magic Room, but
                          decides against it at the last moment.
  See also: @teleport, @atofail, @tofail, @lock.

& @otport

  Command: @otport <object> = <message>
  Attribute: Otport
 
  Sets the message (prefixed by your name) that others in the room to which
  the object goes see when the object teleports there.
 
  This attribute is only meaningful for players and things, and will never be
  automatically triggered on other object types.
  
  Example: @otport me = appears in a flash of non-wizardly brilliance.
 
  See also: @atport, @oxtport, @tport, @teleport.

& @oufail

  Command: @oufail <object> = <message>
  Attribute: Oufail
 
  Sets the message that others in the same room see when someone tries to
  use object but fails the object's use lock.  Note that the other functions
  controlled by the use lock (paying, listening, and $-commands) do not
  trigger Oufail.
 
  Example: @oufail robot = tries to activate the robot, but to no avail.
 
  See also: @aufail, @ufail, @use.

& @ouse

  Command: @ouse <object> = <message>
  Attribute: Ouse
 
  Sets the message (prefixed by the player's name) that is shown to others in
  the room when someone uses <object>.
 
  This attribute is only meaningful for players and things, and will never be
  automatically triggered on other object types.
 
  Example: @ouse camera = takes a picture with the camera.
  See also: use, @ause, @use.

& @oxenter

  Command: @oxenter <object> = <message>
  Attribute: Oxenter
 
  Sets the message (prefixed by the player's name) that is shown to others in
  the location being left when someone enters <object>.  Note that the
  message is shown to those outside the object, not those inside.
 
  This attribute is meaningful for players, things, and rooms, and will never
  be automatically triggered on exits.
 
  Example: @oxenter wormhole = climbs into the wormhole and vanishes.
  See also: enter, @aenter, @enter, @oenter.

& @oxleave

  Command: @oxleave <object> = <message>
  Attribute: Oxleave
 
  Sets the message (prefixed by the player's name) that is shown to others in
  the location being entered when someone leaves <object>.  Note that the
  message is shown to those outside the object, not those inside.
 
  This attribute is meaningful for players, things, and rooms, and will never
  be automatically triggered on exits.
 
  Example: @oxleave wormhole = steps out of a hyperspatial wormhole.
 
  See also: leave, @aleave, @leave, @oleave.

& @oxtport

  Command: @oxtport <object> = <message>
  Attribute: Oxtport
 
  Sets the message (prefixed by your name) that others in the room from which
  the object comes see when the object teleports out.
 
  This attribute is only meaningful for players and things, and will never be
  automatically triggered on other object types.
  
  Example: @oxtport me = disappears in a flash of non-wizardly brilliance.
 
  See also: @atport, @otport, @tport, @teleport.

& @pay

  Command: @pay <object> = <message>
  Attribute: Pay
 
  Sets the message that is shown to the player who gives <object> enough
  money to satisfy its Cost attribute.
 
  This attribute is only meaningful for things, and will never be
  automatically triggered on other object types.
 
  Example: @pay Coke machine = You slip some change into the slot.
  See also: give, @apay, @cost, @opay.

& @prefix

  Command: @prefix <object> = <prefix text>
  Attribute: Prefix
 
  This attribute, when set, will be used as a prefix for all text forwarded
  by the 'audible' flag on an object or exit.  The default if this attribute
  is not set is 'From <object name>,' for objects, and 'From a distance,'
  for exits.
 
  Example:
    > @fo test=out
    > @set #378=puppet
    test> test grows ears and can now hear.
    > :does something silly.
    Wizard does something silly.
    test> From a distance, Wizard does something silly.
    > @prefix out=From some strange place
    Set.
    > :does something even sillier.
    Wizard does something even sillier.
    test> From some strange place Wizard does something even sillier.
  See also: AUDIBLE, @filter, @forwardlist, @infilter, @inprefix.

& @reject

  Command: @reject <object> = <message>
  Attribute: Reject
 
  This attribute is sent as a message to anyone who tries to page you but
  you have prevented them from paging you via your page lock (@lock/page).
 
  This attribute is only meaningful for players, and will never be
  automatically referenced on other object types.
 
  Example: @reject me = I _told_ you not to page me anymore...
  See also: @away, @idle, page.

& @rfail

  Command: @rfail <object> = <message>
  Attribute: Rfail
 
  Sets the message that a player sees when he tries to give an object to
  someone else, but the receiver refuses to accept the object because
  the object didn't pass its receive lock.
 
  Function references and %-substitutions are allowed in receive failure
  messages, and are evaluated when someone tries to give away the object.
  In function references, 'me' refers to the intended recipient of the object,
  while %-substitutions that refer to the enactor (such as %n, %#, %p, etc)
  refer to the (attempted) giver.
 
  This attribute is only meaningful for players and things, and will never be
  automatically triggered on other object types.
 
  Example: @gfail merchant = The merchant doesn't want your worthless trash.
  See also: give, @agfail, @arfail, @gfail, @ogfail, @orfail, @lock.

& @runout 

  Command: @runout <object> = <command list>
  Attribute: Runout
 
  Sets the actions to be taken by <object> when another of its attributes is
  triggered (either automatically or via the @trigger command) and its
  Charges attribute is zero.  When this occurs, the Runout attribute is run
  INSTEAD OF the attribute that would have run normally.
 
  Example: @runout magic wand = :fizzles and turns to dust.; @destroy me
  See also: @charges.

& @sex

  Command: @sex <object> = <gender>
  Attribute: Sex
 
  Sets the gender for <object>, which is used to determine which pronouns to
  use when replacing %p, %o, %s, and %a parameters in messages that apply to
  <object>.  Genders that start with M or m are considered male, those
  starting with F, f, W, or w are considered female, those starting with
  P or p are considered plural, and anything else is considered neuter.
 
  Example: @sex me = female
           @sex me = No thank you (Silly, but possible.  Treated as neuter)
  See also: GENDER.

& @startup

  Command: @startup <object> = <command list>
  Attribute: Startup
 
  Sets a list of commands to be performed by <object> when the game is
  started up.  Typical actions include going home, cleaning visitors out of
  a room, resetting a puzzle or complex object to its initial state, or
  starting up an object that wants to run continuously.
 
  Example: @startup me = @vz me=MUX was last restarted at [time()].
           @startup me = home

& @success

  Command: @success <object> = <message>
  Attribute: Succ
 
  Sets the message that is shown to the player who successfully picks up the
  named player or thing, goes through the named exit, or looks at the room
  and passes the room's lock.
 
  Example: <object> @succ vase = You carefully pick up the delicate vase.
           <exit>   @succ doorway = You open the door and walk through the
                                    doorway.
  See also: get, look, @asuccess, @osuccess, SUCCESS.

& @tfail

  Command: @tfail <object> = <message>
  Attribute: Tfail
 
  Sets the message that a player sees when he tries to teleport to somewhere
  he does not have permission.  You do not see this message if you couldn't
  teleport out of your present location.
 
  Function references and %-substitutions are allowed in teleport failure
  messages, and are evaluated when someone attempts to teleport to the
  specified destination.  In function references, 'me' refers to the teleport
  destination, while %-substitutions that refer to the enactor (such as %n,
  %#, %p, etc) refer to the player attempting the teleport.
 
  When a player teleports another object (@tel <object>=<destination>), the
  lock is checked against the player, not the object.
 
  Example: @tfail here = A psychic barrier prevents you from teleporting there.
  See also: @teleport, @atfail, @otfail, @lock.

& @tofail

  Command: @tofail <object> = <message>
  Attribute: Tofail
 
  Sets the message that a player sees when he tries to teleport from somewhere
  he does not have permission.
 
  Function references and %-substitutions are allowed in teleport failure
  messages, and are evaluated when someone attempts to teleport out of their
  location.  In function references, 'me' refers to the player's current
  location, while %-substitutions that refer to the enactor (such as %n,
  %#, %p, etc) refer to the player attempting the teleport.
 
  Example: @tofail here = A psychic barrier prevents you from teleporting
           out.
  See also: @teleport, @atofail, @otofail, @lock.

& @tport

  Command: @tport <object> = <message>
  Attribute: Tport
 
  Sets the message that an object sees whenever it teleports.
  The message is displayed after the object moves to its new location.
 
  This attribute is only meaningful for players and things, and will never be
  automatically triggered on other object types.
  
  Example: @tport me = Hey! I teleported. Wow!
 
  See also: @atport, @otport, @oxtport, @teleport.

& @ufail

  Command: @ufail <object> = <message>
  Attribute: Ufail
 
  Sets the message that someone sees when they try to use object but fail
  the object's use lock.  Note that the other functions controlled by the use
  lock (paying, listening, and $-commands) do not trigger Oufail.
 
  Example: @ufail robot = The robot pointedly ignores you.
 
  See also: @aufail, @oufail, @use.

& @use

  Command: @use <object> = <message>
  Attribute: Use
 
  Sets the message that is shown to the player who uses <object>.
 
  This attribute is only meaningful for players and things, and will never
  be automatically triggered on other object types.
 
  Example: @use camera = You take a picture with the camera.  Click.
  See also: use, @ause, @ouse.

& ABODE
ABODE

  FLAG: ABODE(A)  ()  
  
  If a room is set ABODE, players can set their homes there, 
  and can set the homes of objects there.  It does not mean that a 
  player can open an exit to that room, only that they can set their 
  home there.
  
  Related Topics:

& AUDIBLE
AUDIBLE

  FLAG: AUDIBLE(a) (all types)
 
  When set on an object, player, or room everything from a say, pose, or emit
  inside the object will be sent to every object in the location of that
  object (except for rooms which have no location) as well as to all objects
  mentioned in the object's Forwardlist attribute.  When set on an exit,
  everything from a say, pose, or emit in the room the exit is in will be
  forwarded to the room the exit points to.  In both cases the @prefix
  attribute will be inserted in front of the text, or a default prefix if no
  @prefix attribute is set.  If the @filter attribute is present, it will be
  used to suppress those messages matching any of the patterns specified.
  
  Related Topics: @filter, @forwardlist, @prefix.

& CHOWN_OK
CHOWN_OK

  FLAG: CHOWN_OK(C)  () 
  
  This flag, when set, allows you to transfer ownership to
  another player. To set it, you must be carrying the object. You 
  also have to be in the room if you want to set this flag on rooms 
  or exits.  After this flag is set, the new player may gain 
  ownership of the object by using the @chown command. 
  
  Related Topics: @chown

& CONNECTED
CONNECTED

  FLAG: CONNECTED(c)  () 
  
  This flag applies only to players and it shows if the 
  player is connected or not. Thus, each time you are connected to 
  the game, you should see the 'c' flag set, otherwise, you are DEAD!
  You cannot reset this flag, and it is used internally by the code 
  for things like tabulating players for the WHO list, etc.
  
  Related Topics:

& DARK
DARK

  FLAG: DARK(D)  ()      
  
  If a room is DARK, then no items are shown when a person 
  'looks' there. If a thing is DARK, then "look" does not list that 
  object in the room's Contents:, and if an exit is DARK, it doesn't 
  show up in the Obvious Exits: list.  Puppets and objects that can 
  listen cannot be DARK.
  
  Related Topics:

& DESTROY_OK
DESTROY_OK

  FLAG: DESTROY_OK(d)  ()   
  
  When set on an object, it allows any player to destroy
  it as long as the object is not locked against them. This is good 
  for things like notes, whereby the recipient can destroy the note 
  after reading it, instead of having to look for you to destroy it.
  The DESTROY_OK flag overrides the SAFE flag, so that you do not need to
  give the /override switch to @destroy to destroy a thing that is both
  DESTROY_OK and SAFE. When it is set on any object or the owner of that
  object, that object is destroyed immediately, without delay.
  
  Related Topics: @destroy, SAFE.

& ENTER_OK 
ENTER_OK

  FLAG: ENTER_OK(e)  ()   
  
  If an object or person is ENTER_OK, other players may 
  enter the object or person by using 'enter <object/person>. Players
  must also have the ENTER_OK set if they wish to be able to receive 
  things given to them by other players via the 
  'give <player> = <object>'.
  
  Related Topics: 

& GAGGED
GAGGED
 
  FLAG: GAGGED(j)  ()    
  
  When a player is set GAGGED, they cannot speak or pose under any
  circumstances. This flag has no meaning for objects, exits, or rooms.
  
  Related Topics:
 
& GOING
GOING

  FLAG: GOING(G)  ()     
  
  Used internally for the @destroy command, it is set on 
  rooms that are set to be destroyed. In the event that a player 
  decides they don't want to destroy the room after all then they can
  unset it. 
  
  Related Topics:

& HAVEN
HAVEN

  FLAG: HAVEN(H)  ()     
  
  @set here=haven;@set me=haven. If a location is HAVEN, you 
  cannot kill in that location.  The HAVEN flag no longer blocks pages or
  @pemits, use @lock/page instead.
 
  Related Topics: @lock/page.

& KEY
KEY

  FLAG: KEY(K)  ()    
  
  When set on an object prevents puppets from picking it up.
  
  Related Topics:

& LINK_OK
LINK_OK

  FLAG: LINK_OK(L)  ()   
  
  If a room is LINK_OK, anyone can link exits to it (but 
  still not from it). It has no meaning for people, things, or exits.
  
  Related Topics: @link, LINKING

& UNFINDABLE
UNFINDABLE

  FLAG: UNFINDABLE(U)  ()
  
  If a player is set UNFINDABLE, he cannot be found by the loc() or room()
  functions.  
  
  If a room is set UNFINDABLE, players in that room (or inside objects
  in the room) cannot be found by loc()/room().
  
  Related Topics:

& FLOATING
FLOATING

  FLAG: FLOATING(F)  () 
  
  If a room is set floating, you will not be notified every 10 
  minutes or so that you have a disconnected room.
  
  Related Topics:

& OPAQUE
OPAQUE

  FLAG: OPAQUE(O)  ()   
  
  When set on a player, it prevents other players from 
  seeing what you are carrying in your inventory. Only exception is 
  when the object you are carrying belongs to the other player 
  looking at you.
  
  Related Topics:

& PLAYER
PLAYER

  FLAG: PLAYER(P)  () 
  
  The PLAYER flag identifies you as a player. This flag cannot
  be reset by any player, not even a Wizard (not, yet, anyway 
  *grin*).  It is used mainly by the MUX code to identify your 
  commands, check for validity of commands or locks etc. Generally, 
  just pretend it isn't even there.
  
  Related Topics: TYPES

& JUMP_OK
JUMP_OK

  FLAG: JUMP_OK(J)  ()
  
  When a room or thing is set JUMP_OK, then that location can be teleported
  into by anyone. 
  
  Related Topics: @teleport

& PUPPET
PUPPET

  FLAG: PUPPET(p)  ()   
  
  @set <object> = puppet. Causes an object to grow eyes and 
  ears, and relay all it sees and hears to its owner.  
  
  Related Topics: @force, PUPPETS

& ROOM
ROOM

  FLAG: ROOM(R)  ()  
  
  This flag is automatically set on rooms when you @dig a new
  room. It cannot be changed. Rooms have the added advantage that 
  they can be saved from destruction by setting the room to !GOING 
  (SEE GOING).
  However, this can only be done if no other room/object was created 
  that overwrote your room when it was set for destruction.
  
  Related Topics: 

& VISUAL
VISUAL 

  FLAG: VISUAL(V)  () 
  
  The flag a lot of players have been waiting for. When set on
  your object, it allows other players to examine it and see all the
  object's attributes as if they owned the object. They cannot make 
  any changes to the object.
  
  Related Topics: 

& VACATION
VACATION
 
  FLAG: VACATION(|)  () 
  
  This flag can only be set by wizards. It is usually used to
  mark players who will be inactive for a long period of time. It is
  automatically cleared when the character logs on.
  
  Related Topics:
 
& QUIET
QUIET

  FLAG: QUIET(Q)  ()     
  
  This flag when set on yourself prevents you from hearing 
  the 'set' or 'triggered' messages from any objects you own.  When 
  set on an object, only that object will not relay its messages.
  
  Related Topics:

& HALTED
HALTED

  FLAG: HALTED(h)  ()    
  
  While this flag is set, the object cannot perform any MUX 
  actions, listen, be triggered, etc.
  
  Related Topics:

& STICKY
STICKY

  FLAG: STICKY(S)  ()   
  
  If a thing is STICKY, it goes home when dropped 
  (See HOMES). If a room is STICKY, its drop-to is delayed until the 
  last person leaves (See DROP-TOs). Only meaningful for things and 
  rooms.
  
  Related Topics: 

& ROYALTY
ROYALTY

  FLAG: ROYALTY(z)  ()   
  
  If a person is ROYALTY, they can see and examine things, and
  teleport anywhere or anything, like a wizard can. They cannot modify
  objects or players they do not control, and cannot use wizard commands.
  This flag may only be set by a wizard.
  
  Related Topics:
 
& AUDITORIUM
AUDITORIUM

  FLAG: AUDITORIUM(b)  () 
  
  When set on a room, object, or player, it enables the checking
  of speechlocks.
  
  Related Topics:
 
& STAFF
STAFF

  FLAG: STAFF(w)  ()  
  
  This flag can be used to mark players who serve as staff on the
  MUX. It is wizard-settable only.
  
  Related Topics:
 

& ANSI
ANSI

  FLAG: ANSI(X)  ()   
  
  When set on a player, it will enable the player to see ANSI color. 
  If you have TinyFugue and you do not wish to see ANSI color, please 
  leave this flag set and /set catch_ctrls=ansi. The reason for this is when
  the ANSI flag is unset, the server must go through every line of text you
  see and strip the ANSI codes from it. With the ANSI flag set and /set
  catch_ctrls=ansi, TinyFugue will strip the ANSI and save the MUX from
  having to do it, resulting in less lag for everyone.
 
  Related Topics: ansi(), NOBLEED.
 
& NOBLEED
NOBLEED

  FLAG: NOBLEED(-)  ()    
  
  When set on a player, it will append an ANSI white character to
  the normal ANSI 'normal' character, so it will fix ANSI color 'bleed' on
  most terminals. (Bleed occurs when a color extends into text it was not
  meant to.) Do not set this flag unless you have to, it tends to slow down
  the text display for the MUX.
  
  Related Topics:
  
& HEAD
HEAD
 
  FLAG: HEAD(?)  ()   
  
  This is another marker flag, for faction heads and the like. As
  with STAFF, no powers come with it, it is purely a marker.
  
  Related Topics:
 
& FIXED
FIXED

  FLAG: FIXED(f)  ()   
  
  No object may teleport or go home when this flag is set. This
  flag may only be set by a wizard. If set on a player, neither they nor
  any of their objects may teleport or go home.
  
  Related Topics:
 
& UNINSPECTED
UNINSPECTED

  FLAG: UNINSPECTED(g)  ()  
  
  This flag is typically set on rooms that need to be
  inspected for good building practices. This flag may only be set by
  wizards and royalty.
  
  Related Topics:
 
& NO_COMMAND
NO_COMMAND

  FLAG: NO_COMMAND(n)  ()   
  
  The NO_COMMAND flag disables the checking of $-commands 
  on an object.
 
  Most MUXes will be configured to automatically set this flag on rooms
  and players. The server runs faster when fewer objects are checked for
  $-commands; thus, any object which does not have $-commands on it should
  be set NO_COMMAND.
  
  Related Topics:
 
& ANSI()
ANSI()

  FUNCTION: ansi(<codes>,<string>)
 
  This allows you to highlight a string using ANSI terminal effects. The
  string is terminated with a "return to normal" code, and the codes are
  utilized in the order they are specified.

  Related Topics: ANSI CODES, ANSI SUBSTITUTION. 
  
& ANSI CODES
ANSI CODES

        f - flash                       i - inverse
        h - hilite                      n - normal
 
        x - black foreground            X - black background
        r - red foreground              R - red background
        g - green foreground            G - green background
        y - yellow foreground           Y - yellow background
        b - blue foreground             B - blue background
        m - magenta foreground          M - magenta background
        c - cyan foreground             C - cyan background
        w - white foreground            W - white background
 
  For example, "ansi(fc, Test)" would hilight "Test" in flashing cyan.
  
  Related Topics: ansi(), ANSI SUBSTITUTION.
  
& ANSI SUBSTITUTION
ANSI SUBSTITUTION
  
  The percent substitution %x<color code> can be used instead of 
  ansi(), and is more efficient. 
 
  For example, the equivalent to [ansi(rBf,Color!)] would be:
  %xr%xB%xfColor!%xn
 
  The %xn (to return to normal) is not necessary, but if it is not 
  specified the ansi color codes will continue to the end of the string.

  %x is preferred, however %c may also be used. They are equivalent.

  Related Topics: ansi(), ANSI CODES  

& WIZARD
WIZARD

  FLAG: WIZARD(W)  ()   
  
  If a person is WIZARD, they are a wizard, unkillable, 
  subject to fewer restrictions, and able to use wizard commands.  
  In general, WIZARDs can do anything using #<number> or *<player>. 
  Only player #1 can set and unset the WIZARD flag of other players. 
  No WIZARD can turn their own WIZARD flag off. 
  
  Related Topics:  

& IMMORTAL
IMMORTAL

  FLAG: IMMORTAL(i)  ()    
  
  Objects set immortal cannot be killed and don't use up money.
  Only settable by wizards.  This is useful when an object's location
  shouldn't be changed by Joe Player, but you don't want to have to relink it
  to its current location whenever it moves.
  
  Related Topics:

& VERBOSE
VERBOSE

  FLAG: VERBOSE(v)  ()   
  
  This flag causes all commands executed by the object having
  the flag to be sent to the owner of the object.  
  
  Examples:
    > @create foo
    > @set foo=VERBOSE
    > @force foo="Hi.
      foo  "Hi.
      foo says "Hi."

  Related Topics: TRACE

& INHERIT
INHERIT

  FLAG: INHERIT(I)  ()  
  
  Previously, Wizard-owned objects had wizard powers.  This was
  a problem in many cases, so that behavior has changed.  Now, only Wizard
  objects or Wizard-owned Inherit-set objects have wizard powers.  Only
  players can set the Inherit flag, and the Inherit flag is reset during
  @chown.  If a player is set Inherit, all his stuff is assumed to be
  inherit, so his objects can control him.  If a player is NOT Inherit,
  his stuff does NOT control him.  (i.e. cannot @force him.)  This flag
  is not especially useful for non-wizards.
  
  Related Topics:

& MONITOR
MONITOR

  FLAG: MONITOR(M)  ()
 
  Objects:
  When set, anytime the object hears something from someone who passes the
  object's use lock, the object's attributes are scanned for attributes
  of the form '^<pattern>:<commandlist>'.  If the message matches the
  wildcarded <pattern>, then <commandlist> is executed, substituting %0 for
  the text that matched the first wildcard, %1 for the second, and so on.
  All matching attributes are executed, not just the first.
  Parents of MONITOR objects are never checked for ^-patterns.

  Players:
  When set on a player, this flag notifies that player whenever someone
  connects or disconnects from the MUX. It is valid only for players, and
  must be set by a wizard.
 
  Related Topics: LISTENING.

& TRACE
TRACE

  FLAG: TRACE(T)  ()
 
  When a thing is set TRACE, it will report to its owner the result of all
  substitutions that it performs that change the original string.  The order
  for displaying nested evaluations (such as when evaluating the arguments to
  a function) is a site-selected configuration parameter.
 
  Example:
    > @set object = trace
    > @va object = say The result is [add(4,mul(3,%0))].
    > @trig object/va = 7
      object(#322)} '%0' -> '7'
      object(#322)} 'mul(3,%0)' -> '21'
      object(#322)} 'add(4,mul(3,%0))' -> '25'
      object(#322)} 'The result is [add(4,mul(3,%0))].' -> 'The result is 25.'
      object says "The result is 25."

{ 'help trace2' for more } 

& TRACE2
TRACE (continued)

  When trace output is displayed in top-down order (final evaluation first,
  followed by the 'smaller' evaluations needed to perform it), then the total
  number of trace ouput lines that may be produced by an evaluation is limited
  to 200.  Bottom-up trace output is not limited.

  Related Topics: VERBOSE.

& NOSPOOF
NOSPOOF

  FLAG: NOSPOOF(N)  ()
 
  This flag gives you mucho output when people @emit.  It can be annoying,
  but you'll know who's spoofing.
  
  Related Topics: @emit, @femit, @oemit, @pemit.

& PARENT_OK
PARENT_OK

  FLAG: PARENT_OK(Y)  ()
 
  If an object is set PARENT_OK, then any other object that passes the object's
  ParentLock may make this object a parent of any object that it controls.
  Caution: allowing others to use your objects as parents lets them read the
  attributes on the object (as well as any parents of the object).

  Related Topics: @lock/parent.

& LIGHT
LIGHT

  FLAG: LIGHT(l)  ()

  An object or exit that is set LIGHT is visible even when inside a DARK
  location.  If an object is set both DARK and LIGHT, then its contents are
  visible even though the object itself is not.
  
  Related Topics:

& MYOPIC
MYOPIC

  FLAG: MYOPIC(m)  ()
 
  If you are set MYOPIC, then you are treated as if you did not own anything
  when you use the LOOK command or when you automatically look at a location
  when entering it.  Other commands (such as EXAMINE) are not affected.
  
  Related Topics:

& TERSE
TERSE

  FLAG: TERSE(q)  ()
 
  If you are set TERSE then you are not shown the description, success/failure
  messages, contents, or exits of locations you enter.  You must use the LOOK
  or EXAMINE commands to see this information.
 
  Others in the location still get the osucc/ofail messages and the asucc or
  afail command list is still run.
 
  Related Topics: examine, look.

& ROBOT
ROBOT

  FLAG: ROBOT(r)  ()
 
  If set on a player, indicates that the player is a robot and is allowed to
  use the OUTPUTPREFIX and OUTPUTSUFFIX commands that many publicly available
  robot programs require.  Some MUXes do not restrict access to the
  OUTPUTPREFIX and OUTPUTSUFFIX commands.
 
  If set on an exit or a thing, indicates that robot players may not use the
  exit or pick up the thing, the player is treated as having failed the lock.
  
  Related Topics: OUTPUTPREFIX, OUTPUTSUFFIX, @robot.

& SAFE
SAFE

  FLAG: SAFE(s)  ()
 
  When set, requires the use of the /override switch to @destroy in order to
  destroy the object.  It does not prevent the destruction of the object,
  but merely requires some additional effort.  If a thing is set DESTROY_OK,
  its SAFE flag is ignored and it may be destroyed without using the /override
  switch.
  
  Related Topics: @destroy, DESTROY_OK.

& TRANSPARENT
TRANSPARENT

  FLAG: TRANSPARENT(t)  ()
 
  If an exit is TRANSPARENT, then when you look at it you see the description
  of the room on the other side of the exit in addition to the description
  of the exit. When a room is TRANSPARENT, you see a 'long' listing of
  exits, including their destinations.
  
  Related Topics:

& SLAVE
SLAVE

  FLAG: SLAVE(x)  ()
 
  If set on a player, neither the player nor any of his objects may perform
  any commands that change the database.  Some sites may restrict additional
  commands.  This flag may only be set or cleared by wizards.
  
  Related Topics:

& ARBITRARY COMMANDS

  Topic: ARBITRARY COMMANDS
 
  You may define commands that are triggered whenever someone enters a command
  that matches the command template (wildcarding allowed).  These commands
  are called arbitrary commands, user-defined commands, or $-commands (for how
  they are defined), and they are checked for only after the check for
  single-character commands, exits, and internal commands have been performed
  and have failed (so an arbitrary command that matches 'page *' will never
  be performed).
 
  You define an arbitrary command by storing a string of the form
  '$<template>:<commandlist>' in an attribute of an object, then the command
  will be available to anyone who carries the object, is in the same room as
  the object, or is inside the object.  Only use user-named attributes and
  VA-VZ for arbitrary commands, as many of the predefined attributes are not
  for arbitrary commands.  <template> is the pattern to check for (it may
  contain wildcards), and <commandlist> is a semicolon-separated list of
  commands to perform.  The text that the wildcard characters matched are
  available in the variables %0 through %9.
{ 'help arbitrary2' for more }

& arbitrary2

  Example:
    > @va testobj = $foobar *:"I was foobar'ed with %0.
    Set.
    > foobar xyzzy
    testobj says "I was foobar'ed with xyzzy"
 
  You can prevent individual attributes from being checked for $-commands
  with the command '@set <obj>/<attr> = no_program'.  Attributes so set
  are reported with ($) following the attribute name when examined.
  The command '@set <obj>/<attr> = !no_program' clears the flag.
 
  You can also match a regular expression rather than wildcards. See
  'help Regular Expressions' for details.
 
  The following attributes are never checked for $-commands: ALIAS CHARGES
  DESC DROP FAIL IDESC ODESC ODROP OFAIL OSUCC SEX SUCC.
 
  See also: @set.

& REGEXPS
  Topic: REGEXPS (Regular Expressions)
 
  The majority of matching in MUX is done with wildcard ("globbing")
  patterns. There is a second type of matching, using regular expressions,
  that is available in certain circumstances.
 
  For attributes that are $-commands or ^-listen-patterns, setting that
  attribute "regexp" (with '@set <object>/<attribute>=regexp') causes
  patterns to be matched using regular expressions rather than globbing.
 
  In a regular expression match, the substring of the string which matched
  the regexp pattern is %0; %1 through %9 are the substrings of the string
  which matched parenthesized expressions within the regexp pattern. 
 
  Continued in 'help regexps2'.

& REGEXPS2
  Regular expressions are extremely useful when you want to enforce
  a data type. For example, if you have a command where you want a
  player to enter a string and a number ('+setnum <player>=<number>',
  for example), you might do it like this:
 
  &DO_NUM Command Object=$+setnum (.+)=([0-9]*): @va me=Data: %1 = %2
  @set Command Object/DO_NUM = regexp
 
  Then, '+setnum cookies=30' would set VA to "Data: cookies = 30".
  This eliminates your having to check to see if the player entered
  a number, since the regular expression matches only numbers.
  Furthermore, the '+' guarantees that there needs to be at least
  one character there, so a player can't enter '+setnum cookies='
  or '+setnum =10' or similarly malformed input.
 
  Also note that regexps are case-sensitive, but wildcard globbing 
  is not.
 
  Regular expression syntax is explained in 'help regexp syntax'.

& REGEXP SYNTAX
  Topic: REGEXP SYNTAX

  The following explanation is taken from Henry Spencer's regexp(3)
  package, the regular expression library used in TinyMUX.
 
          A regular expression is zero or more branches, separated by
          `|'.  It matches anything that matches one of the branches.
 
          A branch is zero or more pieces, concatenated.  It matches a
          match for the first, followed by a match for the second,
          etc.
 
          A piece is an atom possibly followed by `*', `+', or `?'.
          An atom followed by `*' matches a sequence of 0 or more
          matches of the atom.  An atom followed by `+' matches a
          sequence of 1 or more matches of the atom.  An atom followed
          by `?' matches a match of the atom, or the null string.
  
  Continued in 'help regexp syntax2'.

& REGEXP SYNTAX2
          An atom is a regular expression in parentheses (matching a
          match for the regular expression), a range (see below), `.'
          (matching any single character), `^' (matching the null
          string at the beginning of the input string), `$' (matching
          the null string at the end of the input string), a `\'
          followed by a single character (matching that character), or
          a single character with no other significance (matching that
          character).
 
          A range is a sequence of characters enclosed in `[]'.  It
          normally matches any single character from the sequence.  If
          the sequence begins with `^', it matches any single
          character not from the rest of the sequence.  If two
          characters in the sequence are separated by `-', this is
          shorthand for the full list of ASCII characters between them
          (e.g. `[0-9]' matches any decimal digit).  To include a
          literal `]' in the sequence, make it the first character
          (following a possible `^').  To include a literal `-', make
          it the first or last character.
 
  Continued in 'help regexp ambiguity' and 'help regexp examples'.

& REGEXP AMBIGUITY
  Topic: REGEXP AMBIGUITY
 
          If a regular expression could match two different parts of
          the input string, it will match the one which begins
          earliest.  If both begin in the same place    but match
          different lengths, or match the same length in different
          ways, life gets messier, as follows.
 
          In general, the possibilities in a list of branches are
          considered in left-to-right order, the possibilities for
          `*', `+', and `?' are considered longest-first, nested
          constructs are considered from the outermost in, and
          concatenated constructs are considered leftmost-first.  The
          match that will be chosen is the one that uses the earliest
          possibility in the first choice that has to be made.  If
          there is more than one choice, the next will be made in the
          same manner (earliest possibility) subject to the decision
          on the first choice.  And so forth.
 
  Continued in 'help regexp ambiguity2'.

& REGEXP AMBIGUITY2
          For example, `(ab|a)b*c' could match `abc' in one of two
          ways.  The first choice is between `ab' and `a'; since `ab'
          is earlier, and does lead to a successful overall match, it
          is chosen.  Since the `b' is already spoken for, the `b*'
          must match its last possibility-the empty string-since it
          must respect the earlier choice.
 
          In the particular case where no `|'s are present and there
          is only one `*', `+', or `?', the net effect is that the
          longest possible match will be chosen.  So `ab*', presented
          with `xabbbby', will match `abbbb'.  Note that if `ab*' is
          tried against `xabyabbbz', it will match `ab' just after
          `x', due to the begins-earliest rule.  (In effect, the
          decision on where to start the match is the first choice to
          be made, hence subsequent choices must respect it even if
          this leads them to less-preferred alternatives.)

& REGEXP EXAMPLES
  Topic: REGEXP EXAMPLES
 
  The regexp pattern '.' is equivalent to the wildcard '?'; it matches
  one and only one of an arbitrary character.
 
  The regexp pattern '.+' is equivalent to the wildcard '*'; it matches
  one or more arbitrary characters. To match zero or more arbitrary
  characters, the regexp pattern is '.*'.
 
  To match a string of numbers, use:       [0-9]+
  To match a string of letters only, use:  [A-Za-z]+
 
  See 'help regexp syntax' for a more detailed explanation.

& ATTRIBUTE OWNERSHIP

  Topic: ATTRIBUTE OWNERSHIP
  The attributes on an object may be owned independently from the object.
  Normally, the owner of the object owns all of its attributes.
  In addition to an owner, each attribute also has a locked flag,
  set or cleared with @lock <obj>/<attr> and @unlock <obj>/<attr>.
  This flag controls whether or not the owner of the object may
  @chown the attribute to himself with @chown <object>/<attrib>,
  as well as whether or not the attribute is automatically @chowned to
  the new owner when the object is @chowned.
 
  You may lock and unlock attributes that you own on any object (whether
  you own the object or not), and you may @chown an attribute that you own
  to the owner of the object if it is unlocked.  The examine command
  will show you all attributes that you own on an object, even if you
  don't own the object.
{ 'help attrib2' for more }

& attrib2

  Locked attributes may not be modified or removed, and do not change ownership
  when the object containing them is @chowned.
 
  You may not modify or remove attributes that you own that are stored
  on objects that you do not own, but you may modify or remove attributes
  owned by others on your objects (if you do this, the attribute becomes owned
  by you).
 
  If an attribute is owned by someone other than the object's owner, then
  the number of the attribute's owner is shown in parentheses immediately
  after the attribute name.  If there are any flags set on the attribute,
  those flags are indicated in the parentheses too.
 
  The + flag means means that the attribute is locked (so that it will not
  change ownership of the object is @chowned), the $ flag means that
  $-commands are not checked for that attribute.  The I flag indicates that
  the attribute is not inherited by children of the object, and the V flag
  shows that the attribute is publically visible.
{ 'help attrib3' for more }

& attrib3
 
  When checking an attribute lock against an object, the lock will always
  fail if the locked object is not owned by the same player as the attribute
  being tested.  The comparison specified in the lock is only performed if
  the owner of the locked object also owns the attribute on the object
  being checked.
 
  See also: @chown, @lock, @set, @unlock, examine.

& BEING KILLED

  Topic: BEING KILLED  
 
  Getting killed is no big deal. If you are killed, you return to your home,
  and  all things you carry return to their homes. You also collect 50 coins
  in insurance money (unless you have >= 10000 coins or you were killed via
  the Wizard slay command).  Generally, killing is not encouraged unless 
  absolutely necessary. (Note: Killing a wizard is a quick way to discover
  the many uses of the @boot command...  and killing anyone can be very
  rude.)
  See also: kill, @akill, @kill, @okill, IMMORTAL, WIZARD.

& BOGUS COMMANDS

  Topic: BOGUS COMMANDS    
  
  Bogus commands can be made using exits. For example, to make a 'sit'
  command, one could "@open sit", then "@link sit=here" (because unlinked
  exits can be stolen), "@lock sit=#0" (impossible for a room to pass a lock,
  #0 is always a room, therefore the lock always fails), and "@fail sit=You
  sit on the chair."; "@ofail sit=sits on the chair.".  Since nobody can go
  through it, it always fails. The @fail message is displayed  to the player,
  and the @ofail message (preceded by the player's name) to  everyone else.  
  See also: @afail, @fail, @link, @lock, @ofail, @open.

& BOOLEAN VALUES

  Topic: BOOLEAN VALUES
 
  Boolean values are internally considered to be either 1, generally
  interpreted as being true, and 0, which is generally interpreted as being
  false. Now, any string is interpreted as true(1), except for the null
  string (whose length is 0), which is false(0).  A #-1 is interpreted as
  false(0), and any other #<dbref> is interpreted as true(1).  Any number
  except 0 is interpreted as true(1), except 0 which is false(0). (Yes, even
  negative numbers are true(1))
 
  Examples:
  not(foo) = 0             not(<null string>) = 1   not(-66) = 0
  not(0) = 1               not(#-1) = 1             not(#12) = 0
  And so on...
 
  Note: These rules only apply when a function expects a Boolean 
  value, not for strings that expect other values.

& CONTROL

  Topic: CONTROL      
 
  There are 6 rules to controlling objects:
   1) You control anything you own.
   2) Anything you own that has its INHERIT flag set controls anything you 
      own (including you).
   3) Anything you own that does not have its INHERIT flag set only controls
      other things that you own that do not have their INHERIT flag set and
      do not control you, unless YOU have your inherit flag set.
   4) A wizard controls everything.
   5) Anybody controls an unlinked exit, even if it is locked.
   6) The object is in a part of a zone tree that you control.

  Builders should beware of 5, lest their exits be linked or stolen.
 
  Most of the commands for altering the database and many commands and
  functions that retrieve information only work on objects that you control.

& COSTS      

  Topic: COSTS
 
  Certain commands cost money to use, they will fail if you don't have
  enough.  Use the @list costs command to find out what these commands are
  and how much they cost.
  See also: @list.

& CREDITS

  Topic: CREDITS

TinyMUX 2.1 is based on TinyMUX 2.0. It is currently maintained by
Stephen Dennis (AKA Brazil). There is a more complete list of credits
in the README files for the server itself.

See http://www.tinymux.com for an on-line version of these README files.
 
& DROP-TOS

  Topic: DROP-TOS
 
  When the @link command is used on a room, it sets a drop-to location.  Any
  object dropped in the room (if it isn't STICKY) will go to that location.
  If the room is STICKY, the drop-to will be delayed until the last person in
  the room has left.
  See also: @link, STICKY.

& ENACTOR

  Topic: ENACTOR
 
  The enactor is the object that caused an action list to be performed.
  So, the enactor of the Ahear action list is the player or object who
  said/emoted/etc the message that matched the Listen attribute, the
  enactor of the Apay attribute is the player who gave the object money, etc.
  The enactor of an attribute that is run by a @trigger command is the 
  object that ran the @trigger command.  The following substitutions can be
  performed in an action list to return information about the enactor:
 
    %# or [v(#)]           - Database number of the enactor
    %N/%n or [v(N)]/[v(n)] - Name of the enactor.
    %O/%o ...              - Objective pronoun for the enactor
                             (him her it them)
    %P/%p ...              - Possessive pronoun (his her its their)
    %S/%s ...              - Subjective pronoun (he she it they)
    %A/%a ...              - Absolute possessive pronoun (his hers its theirs)
  See also: SUBSTITUTION.

& MOVING

  Topic: MOVING
 
  A number of things happen when you leave one location and enter another
  (assuming you pass the lock on the exit or have permission to enter the
  object or to teleport to the location).  The following list describes the
  actions that MUX takes when an object moves from one place to another.
  Note that if an indicated attribute is not set, no message is displayed
  (or no action is performed).
 
  - If you are using an exit (as opposed to teleporting, entering an object,
    or going home), You receive the SUCC message for the exit, others in the
    old location receive the exit's OSUCC message, and the exit runs its
    ASUCC action list.
  - If you are teleporting or being teleported, others in the old location
    receive your OXTPORT attribute.
  - If you are a player or have your LISTEN attribute set to something,
    and if the old location is not dark and you are not dark, you receive the
    LEAVE message for the old location, others in the old location receive
    the OLEAVE message, and the old location runs its ALEAVE action list.
    Others in the new location receive the OXENTER message from the old
    location, and others in the old location receive the message '<yourname>
    has left.'
{ 'help moving2' for more }

& moving2

  - You are moved to the new location.  If you are entering an object,
    teleporting, or going home, all KEY objects are stripped from you.
  - If the new location is a room, you receive the room's DESC, others in the
    room receive the ODESC, and the room runs its ADESC.  If you pass the
    room's lock do the same with SUCC, OSUCC, and ASUCC, otherwise use FAIL,
    OFAIL, and AFAIL.
  - If the new location is a player or an object, you receive the location's
    IDESC (or DESC if the IDESC is not set).  In either event, others in the
    same location see the ODESC message and the location runs its ADESC 
    action list.
  - You are shown the contents and visible exits if the location is not DARK.
  - If you used an exit, then you receive the DROP message for the exit,
    others in the new room receive the exit's ODROP message, and the exit
    runs its ADROP action list.
  - If you are teleporting or being teleported, you receive your TPORT
    attribute, others in your new location receive your OTPORT attribute,
    and your ATPORT attribute is run.
  - You receive your MOVE attribute, others in your new location receive
    your OMOVE attribute, and your AMOVE attribute is run.
{ 'help moving3' for more }

& moving3

  - If you are a player, or have your LISTEN attribute set to something,
    and if the old location is not dark and you are not dark, you receive the
    ENTER message for the new room, others in the new room receive the OENTER
    message, and the new room runs its AENTER action list. Others in the room
    you just left receive the new room's OXLEAVE message, and others in the
    old location receive the message '<yourname> has arrived.'
  - If the old location is a STICKY room and has its drop-to set, see if
    objects in that room should be sent to the drop-to location.  If so,
    do it.
  - If you are a player, you have a chance of finding some money.
 
  See also: @adesc, @adrop, @aenter, @afail, @aleave, @asucc, @atport, @desc,
            @drop, @enter, @fail, @leave, @listen, @odesc, @odrop, @oenter,
            @ofail, @oleave, @osucc, @oxenter, @oxleave, @oxtport, @succ,
            @tport, move, @teleport, home, KEY, STICKY, DROP-TOS, FAILURE,
            SUCCESS.

& EXITS

  Topic: EXITS
 
  An exit links one location to another location, providing a way to travel
  on the MUX.  Although normally used to link rooms together, exits can be
  made to and from players and objects.
 
  You may pick up exits that you own, and drop exits into locations that
  you own.  When you pick up or drop an exit, anyone in the exit's new
  location may use the exit and travel to its destination.
 
  If an exit is set DARK it will not show up in the list of obvious exits in
  a room.
  See also: @link, @open.

& FAILURE

  Topic: FAILURE  
 
  You fail to use a player or a thing when you cannot take it (because it's
  lock fails).  You fail to use an exit when you cannot go through it
  (because it is unlinked or locked). You fail to use a room when you fail
  to look around (because it's locked).
  See also: get, look, @afail, @fail, @lock, @ofail, STRINGS.

& FLAGS
FLAGS

  Everything in the universe of this MUX (Rooms, Exits, Things, Players,
  etc) are represented in the same way at the program level.  A room merely
  has the room flag set and a player has the player flag set.  In addition,
  flags also give objects abilities or qualities.  For instance, a wizard
  has the wizard flag set.  That is what lets the program know he may use
  wizard abilities.  An object or room may have the dark flag set. In the
  case of an object, this makes the object invisible to normal eye-sight.
  In the case of a room, the room becomes too dark to see other objects or
  players.  To get a list of the flags that are available, type '@list flags'
  or 'help flag list'. For more specific information on a particular flag,
  request help on the flag's name, as in 'help ENTER_OK'.

& FLAG LIST
FLAG LIST
 
  Flag  Title        Flag  Title        Flag  Title        Flag  Title
  -------------------------------------------------------------------------
    A - ABODE      |   C - CHOWN_OK   |   D - DARK       |   E - EXIT
    F - FLOATING   |   G - GOING      |   H - HAVEN      |   I - INHERIT
    J - JUMP_OK    |   K - KEY        |   L - LINK_OK    |   M - MONITOR
    N - NOSPOOF    |   O - OPAQUE     |   P - PLAYER     |   Q - QUIET
    R - ROOM       |   S - STICKY     |   T - TRACE      |   U - UNFINDABLE
    V - VISUAL     |   W - WIZARD     |   X - ANSI       |   Y - PARENT_OK
    Z - ROYALTY    |   a - AUDIBLE    |   b - AUDITORIUM |   c - CONNECTED
    d - DESTROY_OK |   e - ENTER_OK   |   f - FIXED      |   g - UNINSPECTED
    h - HALTED     |   i - IMMORTAL   |   j - GAGGED     |   l - LIGHT
    m - MYOPIC     |   n - NO_COMMAND |   p - PUPPET     |   q - TERSE      
    r - ROBOT      |   s - SAFE       |   t - TRANSPARENT|   u - SUSPECT
    v - VERBOSE    |   w - STAFF      |   x - SLAVE      |   
    z - CONTROL_OK |   ? - HEAD       |   - - NOBLEED    |   | - VACATION
  ------------------------------------------------------------------------
  Realms Patch Flags:
    o - OBF        |   k - HSS        |   y - UMBRA      |   $ - SHROUD
    / - MATRIX     |   ^ - MEDIUM     |   _ - DEAD       |   0 - FAE
    1 - CHIMERA    |   2 - PEERING    |                  |
  ------------------------------------------------------------------------
  For information on a particular flag, type 'help <flagname>'.
  Some flags may be disabled at the MUX you are located.

& FUNCTIONS

  Topic: FUNCTIONS
 
  Functions are specialized commands used to manipulate strings and other
  input. The format for a function is of this form: [fun-name(<input>)]
  Although usually the []'s indicate an input that is optional, in this case
  they are necessary and tell the MUX that this is a function, although
  nested functions (like [first(rest(This is a nice day))] returns 'is') do
  not require more than one pair of []'s.  Nested brackets may be used when
  it is necessary to insert a function call in the middle of an argument,
  like [get(me/[get(me/vz)])], which returns the contents of the attribute
  named in the VZ attribute.
 
  For help on a particular function, type 'help <functionname>'.  You may
  need to include the parentheses with the function name, ie.
  'help <functionname>()'.  Type 'help function list' or '@list functions'
  for a list of the available functions.  'help function classes' will show
  a list of the functions broken down into classes.
 
  See also: @list functions, FUNCTION CLASSES, FUNCTION LIST.

& FUNCTION LIST
FUNCTION LIST
 
  Help is available for the following functions:
    ABS()       ACOS()      ADD()       AFTER()     ALPHAMAX()  ALPHAMIN()
    AND()       ANDFLAGS()  ANSI()      APOSS()     ART()       ASIN()
    ATAN()      BAND()      BEEP()      BEFORE()    BNAND()     BOR()
    CAPSTR()    CASE()      CAT()       CEIL()      CENTER()    CHANNELS()
    CHILDREN()  CMDS()      COLUMNS()   COMALIAS()  COMP()      COMTITLE()
    CON()       CONN()      CONNLAST()  CONNLEFT()  CONNMAX()   CONNNUM()
    CONNTOTAL() CONTROLS()  CONVSECS()  CONVTIME()  COS()       CREATE()
    CRC32()     CWHO()      DEC()       DECRYPT()   DEFAULT()   DELETE()
    DIE()       DIGITTIME() DIST2D()    DIST3D()    DOING()     E()
    EDEFAULT()  EDIT()      ELEMENTS()  ELOCK()     EMPTY()     ENCRYPT()
    EQ()        ESCAPE()    EXIT()      EXP()       EXPTIME()   EXTRACT()
    EVAL()      FDIV()      FILTER()    FINDABLE()  FIRST()     FLAGS()
    FLOOR()     FOLD()      FOREACH()   FULLNAME()  GET()       GET_EVAL()
    GRAB()      GREP()      GREPI()     GT()        GTE()       HASATTR()
    HASATTRP()  HASFLAG()   HASPOWER()  HASTYPE()   HOME()      IADD()
    IDIV()      IDLE()      IFELSE()    IMUL()      INC()       INDEX()
    INSERT()    INZONE()    ISDBREF()   ISNUM()     ISUB()      ISWORD()
    ITER()      ITEMS()     LAST()      LATTR()     LATTRCMDS() LCMDS()
    LCON()      LCSTR()     LDELETE()   LEXITS()    LFLAGS()    LIST()
    LIT()       LJUST()     LN()        LNUM()      LOC()       LOCATE()
    LOCK()      LOG()       LPARENT()   LPOS()      LSTACK()    LT()

("help function list2" for more)

& FUNCTION LIST2
FUNCTION LIST (continued)

    LTE()       LWHO()      MAIL()      MAILFROM()  MAP()       MATCH()
    MATCHALL()  MAX()       MEMBER()    MERGE()     MID()       MIN()
    MIX()       MOD()       MONEY()     MOTD()      MUDNAME()   MUL()
    MUNGE()     NAME()      NEARBY()    NEQ()       NEXT()      NOT()
    NUM()       OBJ()       OBJEVAL()   OBJMEM()    OR()        ORFLAGS()
    OWNER()     PACK()      PARENT()    PARSE()     PEEK()      PEMIT()
    PI()        PLAYMEM()   PMATCH()    POLL()      POP()       PORTS()
    POS()       POSS()      POWER()     PUSH()      R()         RAND()
    REGMATCH()  REMOVE()    REPEAT()    REPLACE()   REST()      REVERSE()
    REVWORDS()  RJUST()     RLOC()      ROOM()      ROUND()     S()
    SCRAMBLE()  SEARCH()    SECS()      SECURE()    SET()       SETDIFF()
    SETINTER()  SETQ()      SETR()      SETUNION()  SHL()       SHR()
    SHUFFLE()   SIGN()      SIN()       SINGLETIME()SORT()      SORTBY()
    SPACE()     SPLICE()    SQRT()      SQUISH()    STARTSECS() STARTTIME()
    STATS()     STRCAT()    STRIPANSI() STRLEN()    STRMATCH()  STRTRUNC()
    SUB()       SUBJ()      SWITCH()    TABLE()     TAN()       TIME()
    TRANSLATE() TRIM()      TRUNC()     TYPE()      U()         UCSTR()
    UDEFAULT()  ULOCAL()    UNPACK()    V()         VADD()      VALID()
    VCROSS()    VDIM()      VDOT()      VERSION()   VISIBLE()   VMAG()
    VMUL()      VSUB()      VUNIT()     WHERE()     WORDPOS()   WORDS()
    WRITETIME() XGET()      XOR()       ZONE()      ZWHO()
 
& FUNCTION CLASSES
FUNCTION CLASSES
 
  Arithmetic:                ABS ADD BAND BNAND BOR CRC32 DEC DIE FDIV
                             IADD IDIV IMUL INC ISUB MOD MUL PACK POWER RAND
                             SHL SHR SIGN SUB SQRT UNPACK
  Comsystem Information:     CHANNELS COMALIAS COMTITLE CWHO
  Database Information:      EXIT INZONE LOC LOCATE MAIL NEARBY NEXT NUM RLOC
                             ROOM SEARCH STATS VALID WHERE ZONE ZWHO
  Floating Point Conversion: FLOOR ROUND TRUNC
  Game Information:          CWHO MOTD MUDNAME POLL VERSION
  Lists:                     COLUMNS EXTRACT ELEMENTS FOREACH FILTER FIRST
                             FOLD GRAB INDEX ITER LAST LNUM MAP MATCH MATCHALL
                             MEMBER MIX MUNGE PARSE REMOVE REST REVWORDS
                             SETDIFF SETINTER SETUNION SHUFFLE SORT SORTBY
                             SPLICE TABLE WORDS
  Logarithms:                E EXP LOG LN
  Logical:                   AND NOT OR XOR
  Miscellaneous:             ART R SETQ ANSI BEEP CREATE ISDBREF ISNUM ISWORD
                             LIT SETR SUBEVAL
 
{ 'help function classes2' for more }

& FUNCTION CLASSES2
FUNCTION CLASSES (continued)

  Object Information:        ANDFLAGS APOSS CMDS CONTROLS DEFAULT EDEFAULT
                             ELOCK FLAGS GET GET_EVAL GREP GREPI HASATTR
                             HASATTRP HASFLAG HASPOWER HASTYPE HOME LATTR
                             LATTRCMDS LCMDS LCON LEXITS LFLAGS LPARENT
                             LOCK MONEY NAME OBJ OBJEVAL OBJMEM ORFLAGS
                             OWNER PARENT PMATCH POSS S SUBJ TYPE U
                             UDEFAULT ULOCAL V VISIBLE
  Player Information:        CONN CONNLAST CONNLEFT CONNMAX CONNNUM CONNTOTAL
                             DOING FINDABLE IDLE LWHO PLAYMEM PORTS 
  Relational:                EQ GT GTE LT LTE MAX MIN NEQ SORT
  Realms:                    CANSEE
  Side-Effect Functions:     LINK TEL
  Strings:                   AFTER ALPHAMAX ALPHAMIN BEFORE CAPSTR CAT COMP
                             DELETE EDIT ESCAPE IFELSE LCSTR LPOS MERGE MID
                             POS REPEAT REPLACE REVERSE SCRAMBLE SECURE
                             SPACE SQUISH STRCAT STRLEN STRMATCH TRANSLATE
                             STRTRUNC SWITCH UCSTR ENCRYPT DECRYPT VALID
  Time:                      CONVSECS CONVTIME DIGITTIME EXPTIME SECS
                             SINGLETIME STARTSECS STARTTIME TIME WRITETIME
  Trigonometry:              ACOS ASIN ATAN COS DIST2D DIST3D PI SIN TAN
                             VADD VCROSS VDIM VDOT VMAG VMUL VSUB VUNIT
& GENDER

  Topic: GENDER
 
  A player's (virtual) gender is specified in the Sex attribute.  This
  attribute controls how gender-specific pronoun substitutions are evaluated
  for the player.  If the player's Sex attribute starts with an 'M' or an 'm'
  then the player is assumed to be male,  'F', 'f', 'W', and 'w' indicate
  female, and anything else indicates neuter.
  See also: SUBSTITUTIONS.  

& GOALS

  Topic: GOALS
 
  There is no ultimate goal to this game, except to have fun.  There are
  objects and places to build, puzzles to solve, scenery to visit, and people
  to meet. There are no winners or losers, only fellow players.  Enjoy.

& HERE

  Topic: HERE 
 
  The word 'here' refers to the room you are in (if you are inside an object,
  it refers to the object that you are in, not the room that the object is
  in).  For example, to rename the room you are in (if you control it), you
  could enter '@name here= <new name>'.

& HOMES

  Topic: HOMES
 
  Every thing or player has a home.  This is where players when they go home,
  or things with the STICKY flag set go when dropped.  Homes are set with the
  @link command. A thing's home defaults to the room where it was created, if
  you control that room, or your home. You can link an exit to send players
  home with '@link <dir>=home'.  Drop-tos can also be set to 'home'.
  See also: @link, DROP-TO, STICKY.

& LINKING  

  Topic: LINKING
 
  You can link to a room if you control it, or if it is set LINK_OK or ABODE.
  Being able to link means you can set the homes of objects or yourself to
  that room if it is set ABODE, and that you can set the destination of exits
  to that room if it is LINK_OK.
  See also: @link, ABODE, LINK_OK.

& LISTENING

  Topic: LISTENING
 
  Thee are two ways to listen for something in a room. The easiest way
  is to use a combination of @listen and @ahear/@aahear/@amhear. The
  second way is to use a "^" pattern in an attribute, similar to the way
  "$" is used for user-defined commands. The attribute takes the form:
  '^<pattern>:<action>'.
 
  The ^-pattern check is only performed on objects with their MONITOR flag
  set.  The criterion for triggering a pattern-listen is the same as that for
  triggering an @ahear - the object cannot trigger its own listen patterns.
  All matching attributes have their <action>s performed, not just the first.
  Also, attributes with the no_command flag set are not checked for ^-patterns,
  and neither are objects' parents.
 
  Example:
    > @va test = ^* says "foo *":say I got a foo with %1!.
    Set.
    > @set test=monitor
    test grows ears and can now hear.
    > say foo bar
    You say "foo bar"
    test says "I got a foo with bar!."
  See also: @ahear, @listen, @set.

& LISTS

  Topic: LISTS
 
  A list is a string, usually stored in an attribute (currently any of the
  va-vz attributes), which is a series of words, separated by one or more
  spaces.  The following would be a list (denoted on the ends by ', which is
  not actually in the string): 'one two three four five'.  The functions
  first(), rest(), cat(), member(), and remove(), all work on lists.
 
  See also: cat(), first(), member(), remove(), rest().

& LOOPING

  Topic: LOOPING
 
  Looping in an object can have its good parts and its bad parts.  The good
  part is when you activate part of a program multiple times to exhaustively
  perform an operation.  This is usually done by:
     @va object =  <list of commands>;@trigger me/vb
     @vb object =  @switch <test> = <false>,@trigger me/va,<otherwise go on>
 
  Looping can be a problem when it goes on without stopping.  The @ps command
  can be used to see if you are looping.  Beware!  A looping machine that
  isn't @halt'ed will drain your money supply while you are away!
  See also: @halt, @ps.

& ME

  Topic: ME
  The word 'me' refers to yourself. Some things to do when starting out: 
  1) give yourself a description with 
     '@describe me = <description>', then look at yourself with 'look me'.
  2) set your gender, if you wish it known, with
     '@set me=male' or '@set me=female'  (or '@set me=neuter' to be an 'it').

& MONEY

  Topic: MONEY
 
  You need money to build within the game, to run programmed objects or use
  certain other commands, or to buy things from vendors set up by other
  players.  You can get money via one or more of these methods:
    1.  You receive a daily allowance for each day you connect.
    2.  You have a chance of finding money as you wander around areas that
        other people have built.
    3.  Some MUXes may implement a place where you can sell valuable objects
        for money.
  See also: @list costs, COSTS.

& PUPPETS

  Topic: PUPPETS
 
  An object is made into a puppet by doing '@set <object>=puppet', once an
  object is a puppet it will relay all that it sees and hears to its master.
  All objects created by a puppet are owned by its master, when puppets spend
  or earn money, they use their master's money supply.  In order to prevent
  puppets from screwing up puzzles, objects may have the KEY flag set, this
  will prevent puppets from picking the object up. A puppet may be commanded
  by its master by '@force <object>=command', or by the shorthand version, 
  '#<number of puppet> command'.  The puppet flag is handy for debugging, as
  it allows you to see the result messages your object generates.
 
  Example:       
  @force fred="hi there.  -or-  #4342 "hi there.
  See also:  VERBOSE.

& ROBBERY

  Topic: ROBBERY
 
  Robbing is not allowed on this MUX. If you really need money, ask your
  friendly neighborhood wizard.
  See also: MONEY.

& search classes

  Topic: SEARCH CLASSES
 
  You may use the following classes in @search commands and search()
  function calls:
  
  TYPE      - Restricts to objects of the indicated type (OBJECTS, ROOMS,
              EXITS, PLAYERS, GARBAGE).  THINGS may be used as an alias for
              OBJECTS.
  NAME      - Restricts to objects whose names start with <restriction>.
  OBJECTS   - A combination of TYPE=OBJECT and NAME=<restriction>.
  THINGS    - An alias for OBJECTS.
  ROOMS     - A combination of TYPE=ROOM and NAME=<restriction>.
  EXITS     - A combination of TYPE=EXIT and NAME=<restriction>.
  PLAYERS   - A combination of TYPE=PLAYER and NAME=<restriction>.
  FLAGS     - Restricts to objects which have the flags listed in
              <restriction> set..
  POWER     - Restricts to objects which have the specified power.
  EVAL      - Evaluates the restriction for each object, replacing ##
              with the object's database number.  Evaluations that return
              TRUE (ie, not 0 or #-1) are selected.
  ZONE      - Restricts to objects that are in the indicated zone.
 
{ 'help search classes2' for more }
 
& search classes2

  EOBJECT   - A combination of TYPE=OBJECT and EVAL=<restriction>.
  ETHING    - An alias for OBJECTS.
  EROOM     - A combination of TYPE=ROOM and EVAL=<restriction>.
  EEXIT     - A combination of TYPE=EXIT and EVAL=<restriction>.
  EPLAYER   - A combination of TYPE=PLAYER and EVAL=<restriction>.
  PARENT    - Restricts to the parent designated by <restriction>.
  ZONE      - Restricts to the zone designated by <restriction>.
 
& SEMAPHORES

  Topic: SEMAPHORES
 
  Semaphores may be used for synchronizing complex objects or for enforcing
  mutual exclusion.  You may use any object you own or any LINK_OK object as
  a semaphore, and any type of object (thing, room, player, or exit) may be
  used.
 
  The semaphore state of an object is shown by the Semaphore attribute (which
  is read-only); a positive number indicates the number of commands awaiting
  notifies, and a negative number indicates the number of waits on that
  semaphore that will not block.
 
  Use the '@wait <object>' form of the @wait command to request a command be
  delayed until <object> is notified with the @notify command.  The @drain
  and @notify/all commands clear the semaphore on <object>, either
  discarding or executing all pending commands.  Remember that the
  object performing the @wait executes the command, not the object used
  as a semaphore. 
{ 'help semaphores2' for more }

& semaphores2

  You may also combine the semaphore and timer options of @wait with
  '@wait <object>/<timeout> = <command>'  If the time period expires before
  the semaphore is notified, then the command is executed and the semaphore
  count is decremented, just as if the command had been run because the
  semaphore had been notified.
 
  Examples: <simple>     @wait semaphore="Foo
                         @notify semaphore
            <mutex lock> @va mutex lock=@wait me=@trig me/vb
                         @vb mutex lock="Got it!;@notify me
                         @startup mutex lock=@notify me
            <timed wait> @wait timer/60 = "Sixty Second Timer.
 
  In the above examples you will say "Foo" after semaphore is notified,
  you will say "Got it" when you have the mutual exclusion lock mutex lock
  (You could have also modified object registers that need to be protected
  from concurrent update), and you will say "Sixty Second Timer." either when
  timer is notified or after sixty seconds pass.
 
  See also: @drain, @notify, @wait.

& SPOOFING

  Topic: SPOOFING
 
  Spoofing is the act of making other characters think that a person said or
  did something that they did not.  This is very easy to accomplish, and has
  some good effects, which is why it is allowed.  Note that the NOSPOOF flag
  allows players to see exactly who is spoofing what.
 
  Example:
    ... From TinyJerk's perspective ...
    > @emit Wizard is a jerk!
    Wizard is a jerk.
 
   ... From Wizard's perspective, Wizard is set NOSPOOF ...
   [TinyJerk(#226)] Wizard is a jerk!
   > @boot tinyjerk
   You booted TinyJerk off!
   TinyJerk has disconnected.
   1 connection closed.
 
   ... TinyJerk's perspective again ...
   Wizard gently shows you the door.
 
   *** Disconnected ***

& STACK

  Topic: STACK
 
  Command lists that are run on objects can have up to 10 stack values
  named %0 through %9 (or [v(0)] through [v(9)]).  Stack values can be set
  by the @trigger command, or by matching wildcard characters in the Listen
  attribute (in the case of the Ahear, Aahear, and Amhear attributes).
 
  Example:
    > @listen item = * foo *
    Set.
    > @ahear item = "-->[v(1)]<-- bar -->[v(0)]<--
    Set.
    > say Fee fie foo fum
    You say "Fee fie foo fum"
    item says "-->fum"<-- bar -->Wizard says "Fee fie<--"

& SUBSTITUTIONS

  Topic: SUBSTITUTIONS
 
  All messages may contain %-substitutions, which evaluate to gender-specific
  pronouns if the player's gender is set or to other useful information.
  Information returned is based on the player that caused the message to be
  displayed, not the object that stored the message or which is running the
  action list.  The substutitions available are:
 
    %s, %S  = Name, he, she, it, they.        (subjective)
    %o, %O  = Name, him, her, it, them.       (objective)
    %p, %P  = Name's, his, her, its, their.   (possessive)
    %a, %A  = Name's, his, hers, its, theirs. (absolute possessive)
    %n, %N  = the player's name.
    %r      = carriage return
    %t      = tab character
    %b      = space character
    %%      = literal '%' character
    %0-%9   = Value of positional parameter/stack location 0 through 9.
    %q0-%q9 = Value of temporary (setq) register 0 through 9.
    %va-%vz = Contents of attribute va through vz
{ 'help substitutions2' for more }

& substitutions2

    %#      = Database number of the object that caused the message to be
              displayed or the action list to be run.
    %l      = Database number of the location of the object that caused the
              message to be displayed or the action list to be run.
    %!      = Database number of the object holding the message or running
              the action list.
    %x %c   = ANSI color codes. See 'help ansi()' for more information.
    %|      = A string piped from the previous command in a pipe.
 
  If the letter following the % is capitalized, the first letter of the
  result of the substitution is also capitalized.
 
  Note: %<whatever> is equivalent to [v(<whatever>)], but is more efficient.
  See also: GENDER, V().

& SUCCESS

  Topic: SUCCESS
 
  You successfully use a player or a thing when you take it (because you
  passed the lock).  You successfully use an exit when you go through it.
  You successfully use a room when you look around and the room is not locked
  against you.
  See also: get, look, @asuccess, @lock, @osuccess, @success.

& SWITCHES

  Topic: SWITCHES
 
  Some commands have command switches associated with them that can be used
  to modify their behavior.  For instance, switches on the @ps command
  control the amount of information displayed, and switches on the @switch
  command indicate whether to perform all actionlists whose targets match
  the search string, or just the first.
  See also: @list.

& OBJECT TYPES

  Topic: OBJECT TYPES
 
  There are 4 types of objects: things, players, exits, and rooms. The first
  letter following an object's ID number indicates the type: P(layer),
  E(xit), R(oom), otherwise, thing.  Things are inanimate objects that can
  be carried.  Players are animate objects that can move and carry. Exits
  are the means by which objects move from room to room. Rooms are locations
  that contain objects and linked exits.

& COMMAND EVALUATION

  Topic: COMMAND EVALUATION

  When you submit a command to be executed by MUX (whether by typing it in or
  by having a machine run it, the following steps are performed, in sequence.
  If the command matches something in a step, the matching actions are
  performed and the walk down the list stops.
 
  - The first letter of the command is checked to see if it is a single-
    character command (", :, etc).  If so, %-substitution and function
    evaluation may be performed (depending on the command), and the command
    is executed.
  - The comsystem checks for a channel alias.
  - The command is checked to see if it is the 'home' command.  If so, the
    player or object performing the command goes home.
  - The command is checked against the exits in its current room.  If one
    matches, it is performed.  If more than one matches, one is picked randomly
    from the exits for which the player passes the lock (If the player does not
    pass any locks, then the exit to be tried is picked randomly.
{ 'help command evaluation2' for more }

& command evaluation2

  - The first word of the command is checked to see if it is an internal MUX
    command.  If so, the remainder of the command is broken up into arguments,
    %-substitution and function evaluation may be performed on the (split up)
    arguments, and the command is executed.
  - %-substitution and function evaluation is performed on the command.
  - All objects in the player's inventory, all objects in the player's
    location, and the location itself are searched for $-commands that match
    the command.  All that match are performed.  The player may or may not be
    checked, depending on how the MUX is configured.
  - The commands defined in the zone tree you or your location is in.

  Note: Commands that can cause other commands to be executed (such as @wait,
  @switch, @trigger, etc) never perform substitution on their arguments, they
  leave the evaluation to the command that is to be executed.  This prevents
  most of the problems with getting objects to perform unintended commands by
  putting a ';', '}', or ',' in an argument.  The @force command is an
  exception in that it evaluates its argument, so it should be used with
  caution (preferably by never using it to pass information that someone else
  entered, use @trigger instead).
 
  Also, the construct '$xx *:%0' does not work (and is very dangerous
  programming), use '$xx *:@force me=%0' if you need this functionality.

& VERBS

  Topic: VERBS
 
  For many verbs there are three attributes that specify messages and actions
  associated with the verb in addition to the verb's builtin action.
  The attributes are named Verb, Overb, and Averb.  Verb is the message that
  the enactor sees, Overb is the message that everyone else in the same room
  as the enactor sees, and Averb is a list of commands that are run.
  These attributes may be set using the @<attribute> command, so the commands
  to set the attributes related to the 'drop' command are @drop, @odrop, and
  @adrop.

& WIZARDS

  Topic: WIZARDS
 
  Wizards are the people that help run the game and make sure that everything
  is working properly.  They have special powers to tweak reality in ways
  mortals can only dream of.  Be nice to them, they are going out of their
  way to help keep the game running smoothly. And remember, if you have any
  problems or just want to talk to someone, they will be there for you as
  well.

& V()
V()

  FUNCTION:  v(<string>)
  
  The V function can be used as an alternative for percent (%) substitution
  and also as a replacement for get(me/<arg>).  If the argument is two
  characters long or longer and starts with a letter, then the object
  performing the v() call (and its parent, if necessary) is searched for the
  named attribute, and its value is returned if possible.  Otherwise, a
  percent substitution is performed on the argument (so that v(o) is
  equivalent to %o, for instance).  The percent form (%o in the previous
  example) is preferred as it is faster, and there are no longer any security
  problems associated with it.  Note that attributes with single-character
  names cannot be retrieved with v().
  
  Related Topics: GENDER, SUBSTITUTION, PARENT OBJECTS.

& BEEP()
BEEP()

  FUNCTION: beep()
  
  This function simply outputs the beep character, which on most terminals
  with sound, will emit a short beep. Only wizards may use this function.
 
  Related Topics:
  
& CREATE()
CREATE()

  FUNCTION: create(<object>, <cost>[, <type>])
  
  Works the same as @create <object>, but returns the database number of
  the object created. <cost> is the cost of making the object. <type>
  is an optional parameter, 'r' for rooms, 't' for things, and 'e' for 
  exits. If no <type> is specified, then a thing will be created by
  default. This is a side effect function, and should only be 
  used when necessary.
 
  Related Topics:

& SET()
SET()

  FUNCTION: set(<name>, <string>)
  
  Works the same as @set, <name> and <string> are equivalent to what comes
  before and after the '=' sign. Returns nothing. This is a side effect
  function, and should only be used when necessary.
  
  Related Topics:

& WORDPOS()
WORDPOS()

  FUNCTION: wordpos(<string>, <charpos>[, <delim>)
 
  Returns the number of the word within <string> where the character position
  <charpos> falls.  Spaces between words are treated as belonging to the word
  that follows them.  If <charpos> is not within the string, the value #-1 is
  returned.  Both words and characters are numbered starting at 1.
 
  <delim> may be used to specify a delimiter other than a space.
 
  Example:
    > say wordpos(This is a test, 4)
    You say "1"
    > say wordpos(This is a test, 5)
    You say "2"
    > say wordpos(This is a test, 6)
    You say "2"
    > say wordpos(This is a test, 20)
    You say "#-1"
  
  Related Topics:

& TYPE()
TYPE()

  FUNCTION: type(<object>)
  
  Returns a string indicating the object type of <object>, either EXIT,
  PLAYER, ROOM, or THING.
 
  Example:
    > say type(me)
    You say "PLAYER"
    > say type(here)
    You say "ROOM"

  Related Topics:
  
& HASFLAG()
HASFLAG()

  FUNCTION: hasflag(<object>,<flag>)
  
  Returns true if object <object> has the flag named <flag> set on it.
  You may not be able to retrieve information for objects that you do not
  own.
 
  Example:
    > say hasflag(me, wizard)
    You say "0"
    > say hasflag(me, connect) 
    You say "1"

  Related Topics:
   
& HASPOWER()
HASPOWER()

  FUNCTION: haspower(<object>,<power>)
  
  Returns true if object <object> has the power named <power> set on it.
  You may not be able to retrieve information for objects that you do not
  own.
 
  Example:
    > say haspower(me, announce)
    You say "0"
    > say hasflag(me, extended_who) 
    You say "1"

  Related Topics:
   
& DELETE()
DELETE()

  FUNCTION: delete(<string>,<first>,<len>)
  
  Returns <string>, but with <len> characters starting after the character
  at position <first> removed.  In other words, this function copies <first>
  characters, skips <len> characters, and then copies the remainder of the 
  string.
 
  Example:
    > say delete(abcdefgh, 3, 2)
    You say "abcfgh"
    > say delete(Would you like coffee or perhaps tea?, 15, 18)
    You say "Would you like tea?"

  Related Topics:
  
& LOCK()
LOCK()

  FUNCTION: lock(<object>[/<whichlock>])
 
  Returns the named lock on <object>.  If you don't specify the lock to get,
  the default lock is returned.  You must control <object>.

  Related Topics:
  
& ELOCK()
ELOCK()

  FUNCTION: elock(<object>[/<whichlock>],<victim>)
  
  Checks if <victim> would pass the named lock on <object>.  Only the object's
  owner may test locks other than the default lock.
  
  Related Topics:

& LWHO()
LWHO()

  FUNCTION: lwho()
  
  Returns a list of the db numbers of connected players.
 
  Example:
    > WHO
    Player Name          On For Idle  Doing
    Mortal                00:11   0s  
    Evinar                00:12   6m  
    Wizard                00:32   6s  
    3 Players logged in.
    > say lwho()
    You say "#226 #271 #1"
  
  Related Topics: WHO, conn(), idle().

& OBJ()
OBJ()

  FUNCTION: obj(<object>)
 
  Returns the proper objective pronoun (him, her, it, them) for referring to
  <object>, based on the object's Sex attribute.  You must either control
  or be near <object>.
  
  Related Topics:
  
& POSS()
POSS()

  FUNCTION: poss(<object>)
 
  Returns the proper possessive pronoun (his, her, its, their) for referring
  to <object>, based on the object's Sex attribute.  You must either control
  or be near <object>.
  
  Related Topics:

& APOSS()
APOSS()

  FUNCTION: aposs(<object>)
 
  Returns the proper absolute possessive pronoun (his, hers, its, theirs) for
  referring to <object>, based on the object's sex attribute.  You must either
  control or be near <object>.

  Related Topics:
  
& SUBJ()
SUBJ()

  FUNCTION: subj(<object>)
 
  Returns the proper subjective pronoun (he, she, it, they) for referring to
  <object>, based on the object's Sex attribute.  You must either control
  or be near <object>.
  
  Related Topics:

& LIT()
LIT()

  FUNCTION: lit(<string>)

  This function returns the string literally - without even squishing
  spaces, and without evaluating *anything*. This can be useful for
  writing ASCII maps with spaces or whatever.

  It can be a bit tricky to get a literal string with spaces into an
  attrib, however, since spaces are usually squished in setting an
  attribute. This example illustrates how to make it work:

  Example:
    > @va me=$test: think {[lit(near       far)]}
    Set.
    > ex me/va
    VA [#1]: $test: think {[lit(near       far)]}
    > test
    near       far

  Leaving out the {}'s will not work in the above.
  
  Related Topics:

& GREPI()
GREPI()

  FUNCTION: grepi(<object>,<attrs>,<pattern>)
 
  This function works exactly like grep, but is case-insensitive.
  
  Related Topics: grep() 

& GREP()
GREP()

  FUNCTION: grep(<object>,<attrs>,<pattern>)
  
  This function returns a list of attributes on <object> containing
  <pattern>.  <attrs> is a wildcard pattern for attribute names to
  search; if you want to search all attributes, use "*".
  
  Parsing _does_ occur before this function is invoked. Therefore,
  "special" characters will need to be escaped out.  <pattern> is
  NOT wildcard matched.

  This function is case-sensitive. grepi() is a case-insensitive version.

  Related Topics:
  
& LPARENT()
LPARENT()

  FUNCTION:  lparent(<object>)
  
  This function returns a list consisting of the object's db# (as per
  num()), the db# of its parent, grandparent, greatgrandparent, etc.
  The list will not, however, show parents of objects which the player
  is not privileged to examine.
  
  Related Topics:

& STRCAT()
STRCAT()

  FUNCTION: strcat(<string1>, <stringN>, ...)
 
  Concatanates two or more strings together, with no space between them.
  For example, strcat(foo,bar,baz,blech) will return the string
  "foobarbazblech".
  
  Related Topics:
 
& STRIPANSI()
STRIPANSI()

  FUNCTION: stripansi(<string>)
 
  Strips the ansi codes from <string>.
  
  Related Topics: ANSI, ansi()
 
& PMATCH()
PMATCH()

  FUNCTION: pmatch(<string>)
 
  Given the partial name of a player, it returns that player's dbref
  number. This partial name completion works identically to the partial
  name completion of the "page" command - i.e. it first attempts to match
  the normal names of all players (connected or not), and if that fails,
  it tries to match the partial names of connected players. If no player
  is matched, it returns "#-1". If more than one match is possible for
  a partial name, it returns "#-2".
  
  Pmatch() will also accept *<player> or #<db#>. If given a non-player
  dbref #, pmatch() will return #-1.
  
  Related Topics:
 
& PFIND()
  pfind(<string>)
 
  This function behaves just like pmatch() except that it will match
  a non-player dbref. This function is provided in case the old behavior
  of pmatch() is still required.

  See: pmatch()

& DIE()
DIE()

  FUNCTION: die(<number of times to roll die>, <number of sides on die>)
 
  This function simulates rolling dice. It "rolls" a die with a given
  number of sides, a certain number of times, and sums the results.
  For example, DIE(2, 6) would roll "2d6" - two six-sided dice,
  generating a result in the range 2-12.
  
  Related Topics:

& ALPHAMIN()
ALPHAMIN()

  FUNCTION: alphamin(<word1>, <word2>, <word3>, ...)

  Returns the word whose order is lexicographically first.
  
  Related Topics: alphamax().
  
& ALPHAMAX()
ALPHAMAX()
  
  FUNCTION: alphamax(<word1>, <word2>, <word3>, ...)

  Returns the word whose order is lexicographically last.

  Related Topics: alphamin().  

& ART()
ART()
  
  FUNCTION: art(<string>)

  This function returns the proper article, "a" or "an", based on whether
  or not <string> begins with a vowel.

  Related Topics:
  
& HASATTR()
HASATTR()

  FUNCTION: hasattr(<object>, <attribute name>)
 
  Returns 1 if the object has the named attribute, and 0 if it does
  not. If the object does not exist or the player does not have the
  ability to examine the object, #-1 will be returned.
 
  Hasattr() doesn't check for attributes inherited from parent
  objects. Use hasattrp() for that.
& HASATTRP()
  hasattrp(<object>, <attribute name>)
 
  Returns 1 if the object or its parent has the named attribute,
  and 0 if it does not. If the object does not exist or the player
  does not have the ability to examine the object, #-1 will be returned.
 
  Use hasattr() to check for attributes without checking parents.
& HASTYPE()
  hastype(<object>, <type>)

  Returns 1 if the object is of the named type, otherwise 0.
  Valid types are: ROOM, EXIT, PLAYER, THING.
  If an invalid type is given, #-1 is returned.

& SHL()
  shl(<number>,<count>)

  Performs a leftwards bit-shift on <number>, shifting it <count> times.
  This is equivalent to imul(<number>,pow(2,<count>), but much faster.

    > think shl(2,10)
    2048

  See also: shr(), band(), bnand(), bor().

& SHR()
  shr(<number>,<count>)

  Performs a rightwards bit-shift on <number>, shifting it <count> times.
  This is equivalent to div(<number>,pow(2,<count>), but much faster.

    > think shr(1309,5)
    40

  See also: shl(), band(), bnand(), bor().

& BAND()
  band(<number>, <number>)
 
  Both arguments are an integer that is treated as a bitfield. It
  performs a bitwise logical AND between these two bitfields and
  returns the resulting bitfield as an integer which can be further
  treated as an integer, a bitfield, or a logical boolean depending
  on your intentions.

     > think band(922,785)
     784

  In the above example, 922 in base 10 is equivalent to 39A in base
  16 or 0011 1001 1010 in base 2. Likewise, 785 in base 10 is the same
  as 311 in base 16 and or 0011 0001 0001 in base 2.

         0011 1001 1010 (922)
  (BAND) 0011 0001 0001 (785)
         --------------
         0011 0001 0000 (784)

  The result may be expressed as 310 in base 16 or 784 in base 10.

  So, this function is useful for testing whether a particular bit in
  the field is 'on' or 'off'. More than one bit can be tested at a
  time. If all bits are 'off', the result is zero which can also be
  interpreted as a boolean false in softcode.
 
  See also: shl(), shr(), bnand(), bor().
 
& BNAND()
  bnand(<number1>, <number2>)

  Both arguments are an integer that is treated as a bitfield. It
  performs a bitwise logical AND between <number1> and the complement
  of <number2> which has the effect of forcing certain bits in
  <number1> off in the result.

     > think bnand(922,785)
     138

  In the above example, 922 in base 10 is equivalent to 39A in base
  16 or 0011 1001 1010 in base 2. Likewise, 785 in base 10 is the same
  as 311 in base 16 and or 0011 0001 0001 in base 2. The complement
  of 785 (specifically the one's complement) is 1100 1110 1110 in base
  2, and is a simple bitwise reversal of 1's and 0's.

          0011 1001 1010 (922)
  (BAND)  1100 1110 1110 (Complement of 785)
          --------------
          0000 1000 1010 (138)

  The result may be expressed as 08A in base 16 or 138 in base 10.

  See also: shl(), shr(), band(), bor().
 
& BOR()
  bor(<number>, <number>)
 
  Both arguments are an integer that is treated as a bitfield. It
  performs a bitwise logical OR which has the effect of forcing certain
  bits on in the result.

     > think bor(922,785)
     923

  In the above example, 922 in base 10 is equivalent to 39A in base
  16 or 0011 1001 1010 in base 2. Likewise, 785 in base 10 is the same
  as 311 in base 16 and or 0011 0001 0001 in base 2.

         0011 1001 1010 (922)
  (BOR)  0011 0001 0001 (785)
         --------------
         0011 1001 1011 (923)

  The result may be expressed as 39B in base 16 or 923 in base 10.
 
  See also: shl(), shr(), band(), bnand().

& CRC32()
  crc32(<string1>, ..., <stringN>)

  Returns the Cyclic Redundancy Check of the strings or sequences of
  strings as a positive number. The answer for the same sequence of
  strings is always the same.
  
  The usefulness of this number is broad, but include as a unique
  fingerprint or checksum pattern, or as a high-quality hash
  function.

  > think crc32(MUX)
  629126998

& PACK()
  pack(<number>[,<radix>])

  Returns the equivalent of the given number using the specified base.
  The default radix is 64. Bases greater than 10 will be more compact
  than the original number. Bases less than 10 will be more expanded.

  The inverse function of pack is unpack. pack and unpack are designed
  to support the base-36 radix conversion used in Myrddin's popular
  Bulletin Board. For this reason, and to support bases: 2, 8, and 16,
  this conversion is not the radix-64 conversion used in unix-to-unix
  copy (uuencode).

  >think pack(629126998)
  bVxTM
  >think pack(629126998,16)
  257FB756
  >think pack(629126998,2)
  100101011111111011011101010110
  >think pack(-629126998)
  -bVxTM

  See also: unpack

& UNPACK()
  unpack(<packed number>[,<radix>])

  Returns the equivalent normal base-10 number of the given
  packed-number using the specified base. The default radix is 64.
  The inverse function of unpack is pack.

  >think unpack(bVxTM)
  629126998
  >think unpack(1111,2)
  15
  
  See also: pack()

& VADD()
  vadd(<vector>,<vector>[,<delim>][,<output delim>])
 
  Returns the sum of two vectors. A vector is a list of numbers
  separated by spaces or a delimiter, and may have up to 20 dimensions.
 
  > @pemit me=vadd(1 2 3,4 5 6)
  5 7 9
  > @pemit me=vadd(0|0|0,1|2|3,|,-)
  1-2-3

& VCROSS()
  vcross(<vector>,<vector>[,<delim>][,<output delim>])
 
  Returns the cross product of two vectors. The cross product of two
  vectors is a vector.
                          | a b c |
  (a,b,c) X (d,e,f) = det | d e f | = i(bf-ce) + j(cd-af) + k(ae-bd)
                          | i j k |

  where i, j, and k are taken as unit vectors in cartisian space.
   
  > @pemit me=vcross(1 2 3,2 3 4)
  -1 2 -1
& VDIM()
  vdim(<vector>[,<delim>])
 
  Returns the dimensions of a vector.
 
  > @pemit me=vdim(1 2 3 4)
  4
& VDOT()
  vdot(<vector>,<vector>[,<delim>][,<output delim>])
 
  Returns the dot product of two vectors. The dot product of two
  vectors is a scalar. (a,b,c) * (x,y,z) = aw + bx + cz
 
  > @pemit me=vdot(1 2 3,2 3 4)
  20
& VMAG()

  vmag(<vector>[,<delim>])
 
  Returns the magnitude of a vector using a euclidean distance metric.
  That is, for vector a b c d, returns sqrt(a^2+b^2+c^2+d^2).
  
  > @pemit me=vmag(3 4) 
  5

& VMUL()
  vmul(<vector|number>,<vector|number>[,<delim>][,<output delim>])
 
  Returns the result of either multiplying a vector by a number (scalar
  multiplication), or an elementwise multiplication of two vectors.
 
  > @pemit me=vmul(1 2 3,2)
  2 4 6
  > @pemit me=vmul(1 2 3,2 3 4)
  2 6 12
& VSUB()
  vsub(<vector>,<vector>[,<delim>][,<output delim>])
 
  Returns the difference between two vectors.
 
  > @pemit me=vsub(3 4 5,3 2 1)
  0 2 4
  > @pemit me=vsub(6-4-2,5-2-0,-)
  1-2-2
& VUNIT()
  vunit(<vector>[,<delim>])
 
  Returns the unit vector (a vector of magnitude 1) which points
  in the same direction as the given vector.
 
  > @pemit me=vunit(2 0 0)
  1 0 0
  > @pemit me=vmul(vunit(5 6 7),vmag(5 6 7))
  5 6 7
& NEARBY()

  Function: nearby(obj1,obj2)
 
  Tests if obj1 is near obj2 (if it is in the same location, in obj2's
  inventory, or is obj2's location).  You must control either obj1 or obj2, or
  be near either one of them, if both of these tests fail then 0 is returned.
  This function returns 1 if the two objects are nearby and 0 if not.

& GET()

  Function: get(<object>/<attribute>)
 
  The get function fetches the specified attribute from the named object.
  It can be used to get attributes from objects you own, public and visual
  attributes of objects near you, and public and visual attributes other
  than the description of players wherever they may be.  If the attribute is
  not present on <object>, its parent is searched for the attribute.
 
  Example:
    > read me
    > say get(me/desc)
  See also: get_eval(), eval(), xget().

& XGET()

  Function: xget(<object>,<attribute>)
 
  This function works exactly like get(), but uses the object and attribute
  seperated into two arguments.
 
  See also: get(), eval(), get_eval().
 
& EVAL()

  Function: eval(<object>,<attribute>)
            eval(<string>)
 
  The first form of the eval function works exactly like the get_eval
  function, but takes the object and attribute in two seperate arguments
  instead of an obj/attr pair. It is mainly used for compatibility with
  PennMUSH 1.50. The second form simply evaluates <string>. This is normally
  done when a function is called, however, it is useful in evaluating %q and
  %v substitutions.
  See also: get_eval(), get(), xget().
 
& GET_EVAL()

  Function: get_eval(<object>/<attribute>)
 
  The get_eval function returns the specified attribute from the named object
  (just like the get function), except that function references and
  %-substitutions have already been performed.  In function references, 
  'me' refers to the object being looked at, and %-substitutions that refer
  to the enactor (such as %n, %#, etc) refer to the object making the get_eval
  call.  If the attribute is not present on <object>, its parent is searched
  for the attribute.
 
  Example:
    > @va test = This is a get_eval test on %n.  The vb is [get(me/vb)]
    > @vb test = VB from test
    > @vb me = VB from me
    > say get(test/va)
    You say "This is a get_eval test on %n. The vb is [get(me/vb)]"
    > say get_eval(test/va)
    You say "This is a get_eval test on Foobar. The vb is VB from test"
  See also: get(), get_eval(), xget().

& TIME()

  Function: time([<zonename>])
 
  The optional <zonename> parameter may be "utc" or "local". If no
  <zonename> is given, "local" is assumed.

    local - Gives you the current local time string of the machine the
            MUX is running on. This time is affected by the daylight
            savings time (or 'summer') rules in force at the server's
            location.

    utc   - Gives you the time string for the UTC time zone.
 
  Example:

    > say time()
    You say "Fri May 05 13:05:39 2000"
    > say time(utc)
    You say "Fri May 05 20:05:39 2000"

  See also: convsecs(), convtime(), secs().

& RAND()

  Function: rand(<num>)
 
  Rand returns an integer between 0 and num-1.
 
  Example:
    > say rand(10)
    You say "6"
    > say rand(10)
    You say "1"
    > say rand(10)
    You say "4"
    > say rand(10)
    You say "9"
    > say rand(10)
    You say "1"

& EXIT()

  Function: exit(<object>)
 
  Exit returns the first exit on the list of exits in the object.  Dark exits
  are not listed, unless you own the object.  Unlike LEXITS(), this function
  does not provide information about exits in parent objects.
 
  See also: con(), lcon(), lexits(), next().

& ABS()

  Function: abs(<number>)
 
  Returns the absolute value of its argument.
  <number> may be a floating point number, and a floating point result
  is returned.
 
  Examples:
    > say abs(4)
    You say "4"
    > say abs(-4)
    You say "4"
    > say abs(0)
    You say "0"

& MAX()

  Function: max(<number1>,<number2>[,<numberN]...)
 
  Returns the largest integer from among its arguments.
  Up to 30 arguments may be specified.
  <numberN> may be a floating point number, and a floating point result
  is returned.
 
  Examples:
    > say max(2,4)
    You say "4"
    > say max(-100,50,0,25)
    You say "50"
 
  See also: min()

& MIN()

  Function: min(<number1>,<number2>[,<numberN]...)
 
  Returns the smallest integer from among its arguments.
  Up to 30 arguments may be specified.
  <numberN> may be a floating point number, and a floating point result
  is returned.
 
  Examples:
    > say min(2,4)
    You say "2"
    > say min(-100,50,0,25)
    You say "-10"
 
  See also: max()

& ADD()

  Function: add(<number1>[,<numberN>]...)
 
  Returns the result of adding its arguments together. You may add up
  to 100 numbers in one add() call. <numberN> may be a floating point
  number, and a floating-point result is returned.
 
  Example:
    > say add(2,4)
    You say "6"
    > say add(5,3,7,-4)
    You say "11"

  See also: dec(), div(), iadd(), idiv(), imul(), inc(), isub(), mod(),
            mul(), sub().

& IADD()

  Function: iadd(<number1>,<number2>[,<numberN>]...)
 
  Returns the result of adding its integer arguments together.
  You may add up to 30 numbers in one add() call. Similiar to add()
  except that the addition is done with faster integer math.
 
  Example:
    > say iadd(2,4)
    You say "6"
    > say iadd(5,3,7,-4)
    You say "11"

  See also: add(), dec(), div(), idiv(), imul(), inc(), isub(), mod(),
            mul(), sub().

& INC()

  Function: inc(<number>)
 
  Returns <number> plus 1. Much faster and more efficient than
  add(<number>,1). Decimal places will be truncated.
 
  See also: add(), dec(), iadd(), isub(), sub().
 
& DEC()

  Function: dec(<number>)
 
  Returns <number> minus 1. Much faster and more efficient than
  sub(<number>,1). Decimal places will be truncated.
 
  See also: add(), iadd(), inc(), isub(), sub().

& SUB()

  Function: sub(<number1>,<number2>)
 
  Returns the result of subtracting <number2> from <number1>.
  The numbers may be floating point numbers, and a floating point result
  is returned.
 
  Example:
    > say sub(5,2)
    You say "3"

  See also: add(), dec(), div(), iadd(), idiv(), imul(), inc(), isub(),
            mod(), mul().

& ISUB()

  Function: isub(<number1>,<number2>)
 
  Returns the result of subtracting integer <number2> from integer
  <number1>. Similiar to sub() except that the addition is done with
  faster integer math.
 
  Example:
    > say isub(5,2)
    You say "3"

  See also: add(), dec(), div(), iadd(), idiv(), imul(), inc(), mod(),
            mul(), sub().

& MUL()

  Function: mul(<number1>,<number2>[,<numberN>]...)
 
  Returns the result of multiplying its arguments together.
  <numberN> may be a floating point number, and a floating point result
  is returned.
 
  Example:
    > say mul(3,5)
    You say "15"
    > say mul(3,5,-2)
    You say "-30"

  See also: add(), div(), fdiv(), iadd(), imul(), isub(), mod(),
            round(), sub(), trunc().

& IMUL()

  Function: imul(<number1>,<number2>[,<numberN>]...)
 
  Returns the result of multiplying its integer arguments together.
  Similiar to mul() except that the mulitplication is done with
  faster integer math.
 
  Examples:
    > say imul(3,5)
    You say "15"
    > say imul(3,5,-2)
    You say "-30"

  See also: add(), div(), fdiv(), iadd(), isub(), mod(), mul(),
            round(), sub(), trunc().

& IDIV()

  Function: idiv(<number1>,<number2>)
 
  Returns the integer quotient from dividing <number1> by <number2>.
 
  Examples:
    > say idiv(15,3)
    You say "5"
    > say idiv(16,3)
    You say "5"
    > say idiv(17,3)
    You say "5"
    > say idiv(18,3)
    You say "6"
    > say idiv(-17,3)
    You say "-5"

  See also: add(), fdiv(), iadd(), imul(), isub(), mod(), mul(), round(),
            sub(), trunc().

& FDIV()

  Function: fdiv(<number1>,<number2>)
 
  Returns the floating point quotient from dividing <number1> by <number2>.
  <number> may be a floating point number, and a floating point result is
  returned.
 
  Examples:
    > say fdiv(15,3)
    You say "5"
    > say fdiv(16,3)
    You say "5.333333"
    > say fdiv(17,3)
    You say "5.666667"
    > say fdiv(18,3)
    You say "6"
    > say fdiv(-17,3)
    You say "-5.666667"
    > say fdiv(10,3.5)
    You say "2.857143"

    See also: add(), div(), mod(), mul(), round(), sub(), trunc().
 
& MOD()

  Function: mod(<integer1>,<integer2>)
 
  Returns the integer remainder from dividing <integer1> by <integer2>.
 
  Example:
    > say mod(15,3)
    You say "0"
    > say mod(16,3)
    You say "1"
    > say mod(17,3)
    You say "2"
    > say mod(18,3)
    You say "0"
  See also: add(), fdiv(),div(), mul(), round(), sub(), trunc().

& DIST2D()

  Function: dist2d(x1, y1, x2, y2)
 
  Returns the integer distance between the Cartesian points in two dimensions
  (x1,y1) and (x2,y2).
 
  Example:
    > say dist2d(0,0,3,4)
    You say "5"
  See also: dist3d()

& DIST3D()

  Function: dist3d(x1, y1, z1, x2, y2, z2)
 
  Returns the integer distance between the Cartesian points in three
  dimensions (x1,y1,z1) and (x2,y2,z2).
 
  Example:
    > say dist3d(0,0,0,10,15,20)
    You say "27"
  See also: dist2d()

& FIRST()

  Function: first(<string>[, <delim>])
 
  Returns the first word of a string, that is, everything to the left
  of the first space in the string, or the entire string if there are
  no spaces in the string.

  <delim> may be used to specify a word delimiter other than a space.
 
  Example:
    > say first(This is a test)
    You say "This"
    > say first(Would you like coffee, or perhaps tea)
    You say "Would"
    > say first(List&with&nonstandard&delimiters,&)
    You say "List"
  See also: rest().

& REST()

  Function: rest(<string>[, <delim>])
 
  The rest function takes a string, returns all the string except the first
  word, that is, everything to the right of the first space, or an empty 
  string, or the empty string if there are no spaces in the string.  
 
  <delim> may be used to specify a word delimiter other than a space.
 
  Example:
    > say rest(This is a test) 
    You say "is a test"
    > say rest(Would you like coffee, or perhaps tea) 
    You say "you like coffee, or perhaps tea"
    > say rest(List!with!different!delimiters,!)
    You say "with!different!delimiters"
  See also: first().

& STRLEN()

  Function: strlen(<string>)
 
  Returns the number of characters in <string>.
 
  Example:
    > say strlen(This is a test)
    You say "14"
    > say strlen(Would you like coffee, or perhaps tea)
    You say "37"

& STRTRUNC()

  Function: strtrunc(<string>,<number>)
 
  This function returns <string> truncated if it is longer than <number>. If
  <number> is greater than the length of <string>, it just returns <string>.
  Much more efficient than the equivalent mid().
 
  See also: mid(), ljust().
 
& MID()

  mid(<string>, <first>, <length>)
 
  Mid returns a segment of the string, the <length> characters to the
  right of the <first> character.  Note that the first character in a
  string is numbered zero, and not one.

& COMP()

  comp(<string1>, <string2>)
 
  Comp compares two strings.  It returns 0 if they are the same, 1 if
  string2 is less than/precedes alphabetically string1, and -1 
  otherwise.

& S()

  s(string)
 
  This function performs pronoun substitution in a string, and then returns
  that string.  As usually, %n is the name, %s the subjective pronoun, %o the
  objective, %p the possessive, and %a the absolute possessive.  It is
  important to note that the pronoun is that of the triggering object.
 
  So, if the ve of an object were: "[s(This is %n)], and I were to 
  type @trigger <object>/ve, it would return "This is <myname>", but 
  if vf were @trigger me/ve, then triggering the vf makes the ve 
  return "This is <object>"

& LPOS()

  lpos(<string>, <character>)
 
  This function returns a list of the positions that <character> occupies
  in <string>, with the first character of the string being 0. (Note that
  this differs from the pos() function, but it consistent with functions
  such as mid().)
 
  If <character> is null, a space is assumed.
 
  Example:
    > say lpos(a-bc-def-g,-)
    You say "1 4 8"
 
& POS()

  pos(<string1>,<string2>)
 
  This function returns the position that string1 begins in string2,
  with the first position being 1.
  If string1 is not in string2, then it returns -1.
 
  Example: pos(man,superman) returns 6

& MATCH()

  Function: match(<string>, <pattern>[, <delim>])
 
  This function matches <pattern> against each word of <string>, returning
  the number of the first word that matches.  If no words match then 0 is
  returned.  The case of the characters being matched is not significant.
 
  The pattern may contain the wildcards '*' and '?'.  '?' matches any one
  character, while '*' matches any number of characters, including none.
  So 's?x' would match 'sex' or 'six', but not to 'socx', but 's*x' would
  match any of them.

  <delim> may be used specified to specify a delimiter other than a space.

  Examples:
    > say match(This is a test, test)
    You say "4"
    > say match(This is a test, is)
    You say "2"
    > say match(This is a test, *is*)
    You say "1"
    > say match(This is a test, *not*)
    You say "0"
    > say match(This is a test, is a)
    You say "0"
  See also: LISTS, member(), strmatch().

& STRMATCH()

  Function: strmatch(<string>,<pattern>)
 
  This function matches <pattern> against the entire <string>, returning 1
  if it matches and 0 if it does not.  The case of the characters being
  matched is not significant.
 
  The pattern may contain the wildcards '*' and '?'.  '?' matches any one
  character, while '*' matches any number of characters, including none.
  So 's?x' would match 'sex' or 'six', but not to 'socx', but 's*x' would
  match any of them.
 
  Examples:
    > say strmatch(This is a test,*Test)
    You say "1"
    > say strmatch(This is a test,*This)
    You say "0"
    > say strmatch(This is a test,*is*is*)
    You say "1"
  See also: match(), member(), regmatch().

& REGMATCH()
  regmatch(<string>,<regexp>[,<register list>])
 
  This function matches the regular expression <regexp> against the
  entirety of <string>, returning 1 if it matches and 0 if it does not.
 
  If <register list> is specified, there is a side-effect: any
  parenthesized substrings within the regular expression will be set
  into the specified local registers, in the order they were specified
  in the list. <register list> can be a list of one through nine numbers.
  If the specified register is -1, the substring is not copied into a
  register.
 
  For example, if <string> is 'cookies=30', and <regexp> is '(.+)=([0-9]*)'
  (parsed; note that escaping may be necessary), then the 0th substring
  matched is 'cookies=30', the 1st substring is 'cookies', and the 2nd
  substring is '30'. If <register list> is '0 3 5', then %q0 will become
  "cookies=30", %q3 will become "cookies", and %q5 will become "30".
  If <register list> was '0 -1 5', then the "cookies" substring would
  simply be discarded.
 
  See 'help regexp syntax' for an explanation of regular expressions.

& COLUMNS()

  columns(<list>, <width>[, <delim>])
 
  Columns displays <list> formatted into columns containing <width>
  number of characters. As many columns as possible will be fit
  onto the screen. Columns takes an optional delimiter.
 
& TABLE()

  table(<list>,<field width>,<line length>,<delimiter>,
        <output separator>,<padding>)

  This function returns the elements of <list> in a tabular format.
  All other parameters are optional.
  - <field width> specifies how wide each table entry is allowed to be.
    Default: 10 characters.
  - <line length> is how wide a table row can be. Default: 78 characters.
  - <delimiter> is the delimiter used in <list>. Default: White space.
  - <output separator> is a single character to be used between entries
    in the table. Default: White space.
  - <padding> is a string which will be repeated to fill in space between
    the end of a table entry and the next column. Default: White space.

  Examples:
  > think table(a b areallylongone d)
  a          b          areallylon d

  > think table(the quick brown fox,10,25, ,|)
  the       |quick
  brown     |fox

  > think table(foo bar baz,101,25,0,|,.\,)
  foo.,.,.,.|bar.,.,.,.
  baz.,.,.,.

  See also: columns()

& FOREACH()

  foreach([<object>/]<attribute>,<string>[,<begin>, <end>])
 
  Maps a function onto a string.
 
  Each character in <string> has the user-defined function of the first
  argument performed on it; the character is passed to the function as
  %0. The results are concatenated. If <begin> and <end> are specified,
  only the characters between <begin> and <end> are parsed, other characters
  are concatenated as they are. This allows a rudimentary form of tokens and
  speeds up the evaluation greatly if tokenizing is your purpose.
 
  Examples:
 
    > &add_one me=[add(%0,1)]
    > say [foreach(add_one, 54321)]
    You say, "65432"
 
    > &add_one me=[add(%0,1)]
    > say [foreach(add_one, This adds #0# to numbers in this string,#,#)]
    You say, "This adds 1 to numbers in this string."
 
& MIX()
 
  mix([<object>/]<attribute>,<list 1>,<list 2>[,<delim>])
 
  This function is similar to MAP(), except that it takes the elements
  of both lists, one by one, and passes them to the user-defined function
  as %0 and %1, respectively, for elements of <list 1> and <list 2>.
  <delim> is used to separate elements; if it is not specified, it
 defaults to a space. The lists must have the same number of elements.
 
  Examples:
 
  > &add_nums me=[add(%0,%1)]
 
  > say [mix(add_nums,1 2 3 4 5,2 4 6 8 10)]
  You say, "3 6 9 12 15"
 
  > say [mix(add_nums,1:3:5:7,0:2:4:6,:)]
  You say, "1:5:9:13"
 
& MUNGE()
 
  munge([<object>/]<attribute>,<list 1>,<list 2>[,<delimiter>])
 
  This function takes two lists of equal length. It passes the entirety of
  <list 1> to the user-defined function as %0. Then, this resulting list
  is matched with elements in <list 2>, and the rearranged <list 2> is
  returned. This is useful for doing things like sorting a list, and then
  returning the correspoding elements in the other list. If a resulting
  element from the user-defined function doesn't match an element in the
  original <list 1>, a corresponding element from <list 2> does not appear
  in the final result.
 
  For example: Consider attribute PLACES, which contains "Fort Benden Ista",
  and another attribute DBREFS contains the dbrefs of the main JUMP_OK
  location of these areas, "#20 #9000 #5000".  We want to return a list of
  dbrefs, corresponding to the names of the places sorted alphabetically. The
  places sorted this way would be "Benden Fort Ista", so we want the final
  list to be "#9000 #20 #5000". The functions, using munge(), are simple:
 
  > &sort_alpha me=[sort(%0)]
  > say [munge(sort_alpha,v(places),v(dbrefs))]
  You say, "#9000 #20 #5000"
 
& OBJEVAL()

  objeval(<object>,<expression>)
 
  Allows you to evaluate <expression> from the viewpoint of <object>.
  You must be a wizard or own <object> to use this function. If <object>
  does not exist or you don't meet the criterion, the function evaluates
  with your privileges. No one may use this function on #1.
 
  This function is useful for securing objects which need to evaluate
  attributes on things owned by others.
 
& OBJMEM()
 
  objmem(<object>)
 
  Returns the size in bytes of <object>.
  Note that this is the complete struct size of the object, and
  not just the attribute values.
 
& PLAYMEM()
 
  playmem(<player>)
 
  Returns the size in bytes of <player>.
  Note that this is the total number of bytes that the player uses,
  including all objects that they own. You must be a Wizard, or have
  the search power to use this function on another player.
 
& ANDFLAGS()

  andflags(<object>,<list of flags>)
 
  This function returns 1 if <object> has all the flags in a specified
  list, and 0 if it does not. The list is specified with a single letter
  standing for each flag, like the output of the FLAGS() function. A '!'
  preceding a flag letter means "not flag".
 
  Thus, ANDFLAGS(me,WD) would return 1 if I was set WIZARD and DARK.
  ANDFLAGS(me,W!Dc) would return 1 if I was set WIZARD, not DARK,
  and CONNECTED.
 
  If a letter does not correspond to any flag, <object> doesn't have
  it, so the function returns 0. There can be an arbitrary number of
  flags. Do not put spaces between flag letters.
 
& ORFLAGS()

  orflags(<object>,<list of flags>)
 
  This function returns 1 if <object> has at least one of the flags in
  a specified list, and 0 if it does not. The list is specified with a
  single letter standing for each flag, like the output of the FLAGS()
  function. A '!' preceding a flag letter means "not flag".
 
  Thus, ORFLAGS(me,Wr) would return 1 if I am set WIZARD or ROYALTY.
  ORFLAGS(me,D!c) would return 1 if I am DARK or not CONNECTED.
 
  If a letter does not correspond to any flag, <object> doesn't have
  it, so it is simply ignored. There can be an arbitrary number of
  flags. Do not put spaces between flag letters.
 
& EXTRACT()

  extract(<string>, <first>, <length>[, <delim>])
 
  Extract returns a string of length words, starting with the first 
  word. Unlike letters, the first word in a string is number 1, 
  instead of 0.
 
  <delim> may be used to specify a delimiter other than a space.

  Examples:
    > say extract(This is a really neat example, 4, 2)
    You say "really neat"
    > say extract(Another@funky@test@for@extract, 3, 3)
    You say "test@for@extract" 
  See also: index(), insert(), ldelete(), replace().

& INDEX()

  Function: index(<list>,<character>,<first>,<length>)
  
  This function is similar to EXTRACT(), except that an item in the
  list may be more than one word; instead of a space being used to
  separate items in the list, <character> is used. The function returns 
  <length> items starting from that in the <first> position. Trailing
  spaces are trimmed. The comma cannot be used as the <character> separator. 
 
  Example:
    > say [index(Cup of Tea | Mug of Beer | Glass of Wine, |, 2, 1)]
    You say, "Mug of Beer"
  See also: extract().

& FLAGS()

  flags(<object>)
 
  Flags returns a string consisting of the flags attached to the 
  object. The string is, however, just one word.  Note that @switch
  is case-INsensitive.  i.e. p=P as far as it is concerned.  I wish
  that P=NP....

& NUM()

  num(<object>)
 
  Returns the dbref number of <object>.
 
  See also: locate().

& CON()

  con(<object>)
 
  Con returns the first object in the list of objects carried by 
  thing. Just the first, and only the first.  See NEXT.

& LOC()

  Function: loc(<object>)
 
  Returns the number of the location where <object> is.  You must either
  control the object or be nearby for it to work.  When used on an exit it
  returns the destination of the exit.  You can also use loc() to find the
  location of players that are not set UNFINDABLE.
 
  Example:
    > look
    Mortal's Room(#367R)
    A bare room with nothing in it but a bed and a chair.
    Contents:
    hat(#368)
    > say loc(me)
    You say "#367"
    > enter hat
    hat(#368)
    Contents:
    cat(#325)
    > say loc(me)
    You say "#368"
    > say loc(here)
    You say "#367"
  See also: rloc(), room(), where().

& RLOC()

  Function: rloc(<object>,<levels>)
 
  This function may be used to get the location of an object's location
  (for which you would previously use 'loc(loc(<object>))', which fails if you
  don't control <object>'s location).  <levels> indicates the number of
  nested 'loc' calls to make, so 'loc(loc(<object>))' could be replaced with
  'rloc(<object>,2)'.  If rloc() encounters a room, the dbref of the room
  is returned.
 
  You must either control the object or be nearby for it to work.  When used
  on an exit it returns the destination of the exit.  You can also use rloc()
  to find the location of players that are not set UNFINDABLE.
 
  rloc(<object>,0) is the same as num(<object>), and rloc(<object>,1) is the
  same as loc(<object>).
 
  See also: loc(), where().

& WHERE()

  Function: where(<object>)
 
  This function returns the "true" location of an object. You must control
  the object or be near it in order for it to work. For players and things,
  the "true" location is the normal location of the object. For exits, the
  "true" location is the source room. For rooms, it is #-1.
  See also: loc(), rloc().

& OWNER()

  Function: owner(<object>)
            owner(<object>/<attrib>)
 
  The first form of the owner() function returns the dbref of the owner of the
  object.  The object must either be yours or nearby.
 
  The second form returns the owner of an attribute on the named object.
  You must own either the object or the attribute.

& NAME()

  name(<dbref>)
 
  This function returns the name of the indicated object.  When called with
  an exit it returns the only the first alias.

  See also: fullname().

& FULLNAME()

  Function: fullname(<dbref>)
  
  This function returns the full name of the indicated object.  This is the
  same as name() in all cases except when <dbref> is an exit, then all the
  aliases are returned as well.
 
  See also: name().

& NEXT()

  next(<thing>)
 
  If thing is an exit in a room, then next will return the next 
  nondark exit in the list of exits for that room.  If thing is an 
  object, then next will return the next object in the inventory list 
  that the object is in.  Otherwise, it returns a '#-1' string.

& AND()

  Function: and(<boolean1>[,<booleanN>]...)
 
  Takes one or more booleans, and returns 1 if they are all each
  equivalent to true(1).
 
  See also: BOOLEAN VALUES, or(), not(), xor().

& OR()

  Function: or(<boolean1>,<boolean2>[,<booleanN>]...)
 
  Takes two or more booleans, and returns 1 if at least one is equivalent
  to true(1).
 
  See also: BOOLEAN VALUES, and(), not(), xor().

& NOT()

  Function: not(<boolean>)
 
  Takes a boolean value, and returns its inverse.  So, if the input is
  equivalent to true(1) it returns a 0, and if the input is equivalent to
  false(0), it returns a 1.
 
  See also: BOOLEAN VALUES, and(), or(), xor().

& XOR()

  Function: xor(<boolean1>,<boolean2>[,<booleanN>]...)
 
  Takes two or more booleans, and returns 1 if an odd number of them are
  equivalent to true(1).
 
  See also: BOOLEAN VALUES, and(), nor(), or().

& gt()

  Function: gt(<integer1>,<integer2>)
 
  Takes two integers, and returns 1 if and only if <integer1> is greater than
  <integer2>, and 0 otherwise.  Warning: passing anything but integers will
  produce unexpected results, as non-numeric strings usually are treated
  as numeric 0.
 
  Example:
    > say gt(4,5)
    You say "0"
    > say gt(5,5)
    You say "0"
    > say gt(6,5)
    You say "1"
    > say gt(foo, bar)
    You say "0"
  See also: lt(), lte(), gte(), eq(), neq().

& gte()

  Function: gte(<integer1>,<integer2>)
 
  Takes two integers, and returns 1 if and only if <integer1> is greater than
  or equal to <integer2>, and 0 otherwise.  Warning: passing anything but
  integers will produce unexpected results, as non-numeric strings usually are
  treated as numeric 0.
 
  Example:
    > say gte(4,5)
    You say "0"
    > say gte(5,5)
    You say "1"
    > say gte(6,5)
    You say "1"
    > say gte(foo, bar)
    You say "1"
  See also: lt(), lte(), gt(), eq(), neq().

& lt()

  Function: lt(<integer1>,<integer2>)
 
  Takes two integers, and returns 1 if and only if <integer1> is less than
  <integer2>, and 0 otherwise.  Warning: passing anything but integers will
  produce unexpected results, as non-numeric strings usually are treated
  as numeric 0.
 
  Example:
    > say lt(4,5)
    You say "1"
    > say lt(5,5)
    You say "0"
    > say lt(6,5)
    You say "0"
    > say lt(foo, bar)
    You say "0"
  See also: lte(), gte(), gt(), eq(), neq().

& lte()

  Function: lte(<integer1>,<integer2>)
 
  Takes two integers, and returns 1 if and only if <integer1> is less than or
  equal to <integer2>, and 0 otherwise.  Warning: passing anything but integers
  will produce unexpected results, as non-numeric strings usually are treated
  as numeric 0.
 
  Example:
    > say lte(4,5)
    You say "1"
    > say lte(5,5)
    You say "1"
    > say lte(6,5)
    You say "0"
    > say lte(foo, bar)
    You say "1"
  See also: lt(), gte(), gt(), eq(), neq().

& EQ()

  Function: eq(<integer1>,<integer2>)
 
  Takes two integers, and returns 1 if they are equal and 0 if they are not.
  Warning: passing anything but integers will produce unexpected results,
  as non-numeric strings usually are treated as numeric 0.
 
  Example:
    > say eq(1,-1)
    You say "0"
    > say eq(5,5)
    You say "1"
    > say eq(foo, bar)
    You say "1"
  See also: lt(), lte(), gte(), gt(), neq().

& NEQ()

  Function: neq(<integer1>,<integer2>)
 
  Takes two integers, and returns 1 if they are not equal and 0 if they are
  equal.  Warning: passing anything but integers will produce unexpected
  results, as non-numeric strings usually are treated as numeric 0.
 
  Examples:
    > say neq(1,-1)
    You say "1"
    > say neq(5,5)
    You say "0"
    > say neq(foo, bar)
    You say "0"
  See also: lt(), lte(), gte(), gt(), eq(), not().

& CAT()

  Function: cat(<string>[,<stringN>])
 
  cat returns a string made up of the contents of string1 through stringN,
  with each string separated from its neighbors by a space.
 
  Example:
    > say cat(this is, a test)
    You say "this is a test"
    > say cat(This is,another,test of the,CAT function)
    You say "This is another test of the CAT function"

& MEMBER()

  Function: member(<list>, <word>[, <delim>])
 
  Member takes a list and a word, and returns the position of that word
  within the list.  If the word does not occur in the list, then 0 is
  returned.  Unlike match(), member() does not check for wildcarding,
  and the cases of <list> and <word> are significant.  A word is defined as
  a string which has no interior spaces.  So 'hello' would be one word,
  while 'hello there' would be two.

  <delim> may be used to specify a delimiter other than a space.
 
  Example:
    > say member(This is a member test, member)
    You say "4"
    > say member(This is a member test, Member)
    You say "0"
    > say member(This is a member test, *e*)   
    You say "0"
    > say member(This is a member test, is a)
    You say "#-1 CAN ONLY TEST ONE ELEMENT"
 
  See also: LISTS, findelem(), match(), strmatch().

& REMOVE()

  Function: remove(<list>, <word>[, <delim>])
 
  Remove takes a list and a word, and returns the list, with the word deleted
  from it.  <delim> may be used to specify a delimiter other than a space.
 
  Example:
    > say remove(this is a test, is)
    You say "this a test"
    > say remove(You can't remove, this)
    You say "You can't remove"
    > say remove(You can't remove multiple words, You can't)
    You say "#-1 CAN ONLY DELETE ONE ELEMENT"
    > say remove(How about an o-separated list, w ab, o) 
    You say "Hout an o-separated list"

& STARTTIME()

  Function: starttime()
 
  Returns a string which is the time the MUX last rebooted.  The time
  is in the same format as the TIME() function returns.
 
  Example:
    > say starttime()
    You say "Sat Dec  7 00:09:13 1991

  See also: convtime().

& SECS()

  Function: secs([<zonename>])

  The optional <zonename> parameter may be "utc" or "local". If no
  <zonename> is given, "utc" is assumed.
  
    local - Returns an integer which corresponds to the current local
            time on the machine running the MUX. This integer is
            affected by timezones and daylight savings time and is
            therefore primarily useful in conjunction with
            convsecs(..,utc).

    utc   - Returns the number of seconds (not counting leap seconds)
            since Jan 01 00:00:00 1970 UTC. This count of seconds is
            not affected by timezone or daylight savings time and is
            useful for calculating durations between two absolute
            points in time.

  Example:
     > say secs()
     You say "957557434"
     ... wait a bit ...
     > say secs()
     You say "957557447"
     > say secs(local)
     You say "957532580"

  See also: convsecs(), convtime(), time().

& WORDS()

  words(<string>[, <delim>])
 
  Returns the number of words in <string>.  <delim> may be used to specify
  a delimiter other than a space.
 
  Example:
    > say words(This is a test)
    You say "4"
    say words(Would you like coffee or perhaps tea?)
    > You say "7"
    say words(This:is:a:colon:separated:list,:)
    > You say "6"

& VERSION()

  Function: version()
 
  Returns a string which contains various version information for the MUX
  you're on.
 
  Example:
     > version
     TinyMUX Beta version 2.0 patchlevel 0 #3
     Build date: Thu Dec  5 10:10:07 EST 1991
     > say version()
     You say "TinyMUX Beta version 2.0 patchlevel 0 #3"

& HOME()

  home(<object>)
 
  Returns the object's home.
 
  Example:
    > exam me
    Mortal(#226Pc)
    Type: PLAYER Flags: CONNECTED
    Desc:Just a plain, old boring Mortal. You know.
    Owner: Mortal  Key: VA:foobar Clams: 920
    Last:Thu Dec 19 08:57:21 1991
    Home: Mortal's Room(#367R)
    Location: The Town Square
    > say home(me)
    You say "#367"

& MONEY()

  Function: money(<object>)
 
  Returns an integer equal to the amount of money <object> has (if it is a
  player) or is worth (otherwise).
  Example:
    > score
    You have 1052 clams.
    > say money(me)
    You say "1052"
    > exam sac test
    Sac Test(#287V)
    Type: THING Flags: VISUAL
    Owner: Beaker  Key: *UNLOCKED* Clams: 20
    Home: Limbo(#0RLDAJ)
    Location: The Town Square
    > say money(sac test)
    You say "20"

& LCON()

  Function: lcon(<object>)
 
  Returns a space-separated list of the contents of <object> which are
  visible to the person running the function.
 
  Example:
    > i
    t1(#366)
    radio(#223)
    The Wizard's Pointy Hat(#188SO)
    You have 42463 clams.
    > say lcon(me)
    You say "#366 #223 #188"
  See also: lexits(), @dolist.

& LEXITS()

  Function: lexits(<loc>)
 
  Returns a space-separated list of the exits in <loc> and its parents.
  Dark exits are not returned unless you own the location.
 
  Example:
    > look here
    The Town Square
    You are in the town square.  All around you .....
    Obvious exits:
    foo  up  southeast  sw  north  
    > say lexits(here)
    You say "#302 #10 #9 #8 #6"
  See also: lcon(), @dolist, PARENT OBJECTS.

& SECURE()

  Function: secure(<string>)
 
  Returns <string> after replacing the characters [](){};%\$ with spaces.
  This prevents strings entered by players from causing undesired side
  effects when used, such as making your object perform unintended commands
  or give out information to which you have access.  Note that this function
  is only needed when the resulting string is to be passed through the @force
  command or be used as an attribute for an object (like the success message
  for a mail message object).
 
    > @va me=Sneak a peek at Wiz's desc... [get(#1/desc)]
    > say secure(%va)
    You say "Sneak a peek at Wiz's desc...  get #1/desc  "
    > say secure($foobar:this {is} a really, tough ; test.)
    You say " foobar:this is a really tough   test."
 
  Note: 'say secure(Sneak a peek at Wiz's desc... [get(#1/desc)])' does not
  produce the expected result because the argument is evaluated BEFORE being
  processed by secure(), therefore the [get()] call has already been
  performed.
  See also: escape().

& ESCAPE()

  Function: escape(<string>)
 
  Returns <string> after adding an escape character (\) at the start of the
  string and also before each of the characters %;[]{}\ that appear in the
  string.  This prevents strings entered by players from causing undesired
  side effects when used, such as making your object perform unintended
  commands or give out information to which you have access.  Note that this
  function is only needed when the resulting string is to be passed through
  the @force command or be used as an attribute for an object (like the
  success message for a mail message object).  This function has the 
  advantage over the secure() function in that the string the user sees
  after evaluating it is the same as the original string.
 
  Example:
    You say "\Sneak a peek at Wiz's desc... \[get(#1/desc)\]"
 
  Note: 'say escape(Sneak a peek at Wiz's desc... [get(#1/desc)])' does not
  produce the expected result because the argument is evaluated BEFORE being
  processed by escape(), therefore the [get()] call has already been
  performed.
  See also: secure().

& MUDNAME()
  Function: mudname()
 
  Returns the name of the MUD.  This is usually (but not necessarily) the name
  that appears in the various mud lists, and is the name that the mud is
  listed under in reports from RWHO servers (that is, if the mud sends its
  WHO information to an RWHO server).
 
  Example:
    > say mudname()
    You say "TestMUX"

& CAPSTR()

  Function: capstr(<string>)
 
  Returns <string> with the first character capitalized.  If the first
  character is not a letter, this function returns the string unmodified.
 
  Example:
    > say capstr(this is a string I want capitalized)
    You say "This is a string I want capitalized"
  See also: lcstr(), ucstr().

& LCSTR()

  Function: lcstr(<string>)
 
  Returns <string> with all letters converted to lowercase.
 
  Example:
    > say lcstr(This is something I want to TEST)
    You say "this is something i want to test"
  See also: capstr(), ucstr().

& UCSTR()

  Function: ucstr(<string>)
 
  Returns <string> with all letters converted to uppercase.
 
  Example:
    > say ucstr(This is a test, really!)
    You say "THIS IS A TEST, REALLY!"
  See also: capstr(), lcstr().

& LNUM()

  Function:  lnum(<number1>[,<number2>][,<sep>])
 
  If only given one argument, this function returns a list of numbers from
  0 to <number1>-1. If <number1> less than 1, nothing is returned.
 
  If given at least two arguments, this function returns a list of numbers
  from <number1> to <number2>. If <number2> is less than <number1>, the list
  will be in descending order, otherwise, the list will be in ascending order.
  Negative integers are valid.

  <sep> is used as the separator character, if given.
 
  Examples:
    > say lnum(5) 
    You say "0 1 2 3 4"
    > say lnum(3,7)
    You say "3 4 5 6 7"
    > say lnum(4,-2,|)
    You say "4|3|1|0|-1|-2"
    > say lnum(2,6,@@)
    You say "23456"

& LATTR()

  Function: lattr(<object>[/<wild-pattern>])
 
  Returns a list of the attributes set on <object>.  If <wild-pattern> is
  given, only attributes matching it are returned.
 
  Example:
    > ex me
    Mortal(#226Pc)
    ....
    VC:Mon Sep  9 12:09:01 1991
    VE:baz
    Last:Thu Dec 19 08:57:21 1991
    VV(#2+):Foof!
    Domain:Abusees
    ....
    > say lattr(me)
    You say "Desc VC VE Last VV Domain"
    > say lattr(me/v*)
    You say "VC VE VV"
 
  See also: @dolist.

& REVERSE()

  Function: reverse(<string>)
 
  Reverses the order of the characters of <string>.

  Examples:
    > say reverse(This is a test)
    You say "tset a si sihT"
    > say reverse(This is a test, Really...)
    You say "...yllaeR ,tset a si sihT"
    > say reverse(A man, a plan, a canal -- Panama!)
    You say "!amanaP -- lanac a ,nalp a ,nam A"
  See also: revwords().

& REVWORDS()

  Function: revwords(<string>[, <delim>])
 
  Reverses the order of the words of <string>.  A word is considered to be
  any sequence of nonblank characters, separated by blanks, so punctuation
  characters that follow a word are considered part of the word.

  <delim> may be used to specify a delimiter other than a space.
 
  Examples:
    > say revwords(This is a test. Really...)
    You say "Really... test, a is This"
    > say revwords(Was it a cat I saw?)
    You say "saw? I cat a it Was"
  See also: reverse().

& BEFORE()

  Function: before(<string1>, <string2>)

  Returns the portion of <string1> that occurs before <string2>.  If <string2>
  does not occur in <string1>, the entire string is returned.
  If you want to return the portion of the string after the first space,
  use the first() function instead.
 
  This function is case sensitive.

  Examples:
    > say before(This is a test,a)
    You say "This is "
    > say before(This is a test,is)
    You say "Th"
    > say before(This is a test, nope)
    You say "This is a test"
  See also: after(), first(), rest().

& AFTER()

  Function: after(<string1>[,<string2>])

  Returns the portion of <string1> that occurs after <string2> or after
  the first word if <string2> isn't given. If <string2> does not occur
  in <string1>, a null string is returned. If you want to return the
  portion of the string after the first space, use the rest() function
  instead.
 
  This function is case sensitive.
 
  Examples:
    > say after(This is a test,a)
    You say " test"
    > say after(This is a test,is)
    You say " is a test"
    > say after(This is a test, nope)
    You say ""

  See also: before(), first(), rest().

& ROOM()

  Function: room(obj)
 
  Returns the number of the room that <obj> is in, or would be in if it
  executed LEAVE commands until it got to a room.  You can find out the
  containing room of objects you own, nearby objects, and findable players.
 
  Example:
    > i
    You are carrying:
    hat(#368)
    cat(#325)
    > look
    Mortal's Room(#367R)
    A bare room with nothing in it but a bed and a chair.
    > say I am in [room(me)], the cat is in room [room(cat)].
    You say "I am in #367, the cat is in room #367."
    > @fo hat=get cat 
    cat has left.
    > say The cat is in [loc(#325)] within room [room(#325)].
    You say "The cat is in #368 within room #367."
  See also: loc(), UNFINDABLE.

& SEARCH()

  Function: search([<player>] [<class>=<restriction>[,<low>[,<high>]]])
 
  The search() function returns a list of objects that match the search
  criteria, which are the same as with the @search command.  This function
  costs as much as the @search command, so repeated use is expensive.
 
  Caution: if you use the [ and ] characters in an Eval selection you will
  need to escape them.
 
  Examples:
    > say search()
    You say "#226 #289 #325 #364 #368 #369"
    > @stats me
    6 objects = 0 rooms, 0 exits, 5 things, 1 players. (0 garbage)
    > say search(eval=\[eq(money(##),1)\])
    You say "#289 #325 #364 #368 #369"
    > say search(player=wizard)
    You say "#1"
  See also: @search, SEARCH CLASSES.

& STATS()

  Function: stats([<player>])
 
  This function returns information about the number of objects on the MUX,
  much like the @stats command.  If the argument is omitted or is 'all', then
  the stats for the entire MUX are returned, otherwise the stats for the
  named player are returned.  You can only get stats for yourself.
 
  The stats are returned as a set of 6 numbers, in the same order as reported
  by the @stats command: total objects, rooms, exits, things, players, and
  garbage.  This command costs as much as the equivalent @stats command (ie:
  '@stats/all' or '@stats <player>', not the free '@stats').
 
  Examples:
    > @stats me
    6 objects = 0 rooms, 0 exits, 5 things, 1 players. (0 garbage)
    > say stats(me)
    You say "6 0 0 5 1 0"
    > say stats()
    You say "377 51 165 134 20 7"
    > @stats/all
    377 objects = 51 rooms, 165 exits, 134 things, 20 players. (7 garbage)
  See also: @stats.

& ITER()

  Function: iter(<list>, <eval>[, <delim>])
 
  <list> is a <delimter>-separated list of strings, which can be object
  numbers, attributes, or arbitrary words.  <eval> is a string that is to be
  evaluated once for each item in <list>, replacing the special symbol ## with
  the corresponding item from <list>, and the symbol #@ with the position
  within the list being iterated.  A space-separated list of the results
  of these evaluations is returned to the caller.  The effect is very similar
  to @dolist, except that the results are made into a list and returned, not
  executed.
 
  Examples:
    > say iter(This is a test,strlen(##))
    You say "4 2 1 4"
    > say iter(This is a test,{strlen(##)})
    You say "4 2 1 4"
    > say iter(lnum(10),mul(mul(##,##),10))
    You say "0 10 40 90 160 250 360 490 640 810"
    > say iter(lcon(me),[name(##)]..[money(##)])
    You say "test..1 t1..1 radio..1 The Wizard's Pointy Hat..1"
    > say iter(Was it a cat I saw,[words(##)] #@,s)
    You say "1 1 4 2 1 3"
  See also: @dolist, list(), parse().

& LIST()
 
  Function: list(<list>, <eval>[, <delim>])
 
  This function is exactly like iter() but serves a specialized purpose:
  MUX has a buffer limit, and for things like lists of players, iter() can
  quickly become inadequate, since the output is cut off before the listing
  is finished. The normal way to handle this is to use a @dolist/@pemit
  combination, but that takes many queue cycles. list() takes <list>,
  <eval>, and an optional delimiter, and evaluates them exactly like
  iter(). The difference is the output: iter() produces a space seperated
  list, while list() outputs each list item on a new row of the screen.
 
  NOTE: This is a side effect function. It does not return anything,
  instead, it prints its output directly to the screen of the player causing
  the function to be evaluated. Since it does this, it is not hampered by
  the buffer limit.
 
  See also: iter(), @dolist, parse().
 
& LOCATE()

  Function: locate(<looker>,<string>,<where>)
 
  The locate function is used to look for an object from the perspective of
  <looker> (You must own <looker>).  The database number of the item that
  is found is returned.  The <where> parameter specifies a list of places to
  look, from this list:
    a    - Look for absolute references (#<number>)
    c    - Look for exits carried by <looker> (and by <looker>'s parents).
    e    - Look for exits in <looker>'s location (and the location's parents).
    h    - Look for 'here', which matches <looker>'s location.
    i    - Look in <looker>'s inventory.
    m    - Look for 'me', which matches <looker>.
    n    - Look for <looker>'s neighbors (other objects in the same location).
    p    - Look for player names prefixed by a '*'
    *    - Look for everything in the above list.
{ 'help locate2' for more }

& locate2

  You may also specify qualifiers in <where> to help resolve possible
  ambiguities:
    E    - Prefer exits over other types.
    L    - Prefer unlocked exits over locked exits.
    P    - Prefer players over other types.
    R    - Prefer rooms over other types.
    T    - Prefer things over other types.
    V    - Report "Can't find..." and "Which one..." errors to <looker>.
    X    - Select randomly if search finds multiple matches.
 
  If nothing matches, the value #-1 is returned.  If more than one thing
  of the preferred type matches, but nothing matches exactly, the value #-2
  is returned, except if the X qualifier was specified in which case one is
  chosen at random.  If more than one thing exactly matches, one is chosen
  at random.  If you specify more than one type preference (E, P, R, or T),
  then the last one entered is the one that is obeyed.  The default is for
  no type to be preferred.
 
{ 'help locate3' for more }

& locate3

  Examples:
    > i
    test1(#378)
    test(#376)
    You have 42463 clams.
    > look
    Nullspace(#250R)
    test1(#382)
    > say locate(me,test,i)                > say locate(me,tes,in)
    You say "#376"                         You say "#-2"
    > say locate(me,test,n)                > say locate(here,tes,*)
    You say "#382"                         You say "#382"
    > say locate(me,test1,in)              > say locate(me,out,e)
    You say "#378"                         You say "#252"
    > say locate(me,test1,in)              > say locate(me,here,*)
    You say "#382"                         You say "#250"

  See also: num(), PARENT OBJECTS.

& EDIT()

  Function: edit(<string>,<from>,<to>)
 
  This function edits <string>, replacing all occurrences of the substring
  <from> with the string <to>.  If <from> is '$', then <to> is appended to
  <string>, while if <from> is '^', then it is prepended.
 
  Examples:
    > say edit(This is a test,is,x)   
    You say "Thx x a test"
    > say edit(Atlantic,^,Trans)
    You say "TransAtlantic"
  See also: @edit.

& U()

  Function: u([<obj>/]<attr>[,<arg>]...)
 
  The u function evaluates an attribute, either from the object performing the
  function or from another object you own, passing in arguments and returning
  the result.

  When evaluating the fetched attribute, %# refers to the original enactor and
  not the 'calling' object, and 'me' refers to the object that supplied the
  attribute.
 
  Examples:
    > @va me=Word is [extract(v(vb),add(%0,1),1)], arg2 is %1.
    > @vb me=This is a test of the u function.
    > say u(va,4,Testing 123)
    You say "Word is of, arg2 is Testing 123."
    > say u(va,7)
    You say "Word is function., arg2 is ."
    > say u(me/va,6,Foobar)
    You say "Word is u, arg2 is Foobar."
  See also: s(), v(), get(), get_eval(), map().

& SWITCH()

  Function: switch(<str>[,<pat1>,<res1>]...[,<dflt>])
 
  The switch function compares <str> against <pat1>, <pat2>, etc (allowing *
  to match any number of characters and ? to match any 1 character), and
  returns the corresponding <resN> parameter for the first <patN> pattern
  that matches.  If none match, then the default result <dflt> is returned.
 
  Example:
    > say switch(c,*a*,A,*b*,B,*c*,C,*d*,D,E)
    You say "C"
    > say switch(f,*a*,A,*b*,B,*c*,C,*d*,D,E)
    You say "E"
    > say switch(cab,*a*,A,*b*,B,*c*,C,*d*,D,E)
    You say "A"
    > say switch(f,*a*,A,*b*,B,*c*,C,*d*,D)  
    You say ""
  See also: @switch, match(), ifelse(), case().

& CASE()

  Function: case(<str>[,<pat1>,<res1>]...[,<dflt>])
 
  case() is like switch() but does not do wildcard matching (i.e., using *).
  In cases where wildcards are not needed, it performs marginally faster.
 
  See also: @switch, match(), ifelse(), switch().

& IFELSE()

  Function: ifelse(<expression>,<true string>,<false string>)
 
  This function returns <true string> if <expression> is true (greater than
  0), <false string> otherwise. Much more efficient than an equivalent
  switch(). It can also return different messages based on whether
  <expression> is nothing or contains text. For example, 
      ifelse(v(test),Test exists!,Test doesn't exist.)
 
  See also: switch().
 
& SPACE()

  Function: space(<count>)
 
  Returns the number of indicated spaces.  If <count> is missing, negative,
  or cannot be converted to a number, one space is returned.  This function
  is useful when you want to pass a single space (or more than one) as a
  function to an argument, because normally leading and trailing spaces are
  stripped from function arguments.
 
  Examples:
    > say space(4)
    You say "    "
    > say edit(Foo bar bletch, space(), X)
    You say "FooXbarXbletch"

& PARENT()

  Function: parent(<obj>)
 
  Returns the parent of <obj>.  Returns #-1 if <obj> cannot be found or
  if you do not own <obj> and it is not set VISUAL.
 
  Example:
    > say parent(me)
    You say "#-1"
    > say My va is [v(va)].
    You say "My va is "
    > @parent me=test
    Parent set.
    > say parent(me)
    You say "#323"
    > say My va is [v(va)].
    You say "My va is Testing 123"
  See also: @parent, PARENT OBJECTS.

& SIGN()

  Function: sign(<number>)
 
  Returns -1, 0, or 1 depending on whether its argument is negative, zero, or
  positive (respectively).
 
  Example:
  > say sign(-4)
  You say "-1"
  > say sign(4)
  You say "1"
  > say sign(0)
  You say "0"
  > say sign(-1)
  You say "-1"

& CONN()

  Function: conn(<player>)
 
  Returns the number of seconds that <player> has been connected.  If <player>
  is not connected then -1 is returned.  If <player> is connected more than
  once, the longest connect time is returned.
 
  Example:
    > WHO
    Player Name          On For Idle  Doing
    Wizard                00:04   1m
    Mortal                00:11   0s  
    Evinar                00:12   6m  Idle. :)  
    frobozz               00:32   6s  
    4 Players logged in.
    > say conn(wiz)
    You say "251"
    > say conn(e)
    You say "770"
    > say conn(frobozz)
    You say "-1"
  See also: WHO, idle(), lwho().

& IDLE()

  Function: idle(<player>)
 
  Returns the number of seconds that <player> has been idle.  If <player>
  is not connected then -1 is returned.  If <player> is connected more than
  once, the smallest idle time is returned.
 
  Example:
    > WHO

    Player Name          On For Idle  Doing
    Wizard                00:04   1m
    Mortal                00:11   0s  
    Evinar                00:12   6m  
    frobozz               00:32   6s  
    4 Players logged in.
    > say idle(wiz)
    You say "6"
    > say idle(e)
    You say "371"
    > say idle(frobozz)
    You say "-1"
  See also: WHO, conn(), lwho().

& CONVSECS()

  Function: convsecs(<seconds> [, <zonename>])
 
  By default, this function converts an integer (representing a count
  of seconds from Jan 01 00:00:00 1970 UTC) to a local time string --
  where local time is the time at the machine running the MUX. This
  conversion includes a timezone/daylight savings time conversion
  between UTC and the local time zone.

  If a second argument is given, it is the <zonename>:

   local - indicates that a conversion for timezone/DST of the 'local'
           server time should be applied (the default).

   utc   - indicates that no timezone/DST conversions should be applied.
           When used this way, there is a unique one-to-one relationship
           between an integer and it's corresponding text-string which
           may be useful for handling other timezones and fictional
           settings.

  Example:
    > say secs()
    You say "957558109"
    > say secs(local)
    You say "957532909"
    > say convsecs(957558109)
    You say "Fri May 05 13:21:49 2000"
    > say convsecs(957532909, utc)
    You say "Fri May 05 13:21:49 2000"

  See also: convtime(), secs(), time().

& CONVTIME()

  Function: convtime(<time string> [, <zonename>])
 
  By default, this function converts a time string (of format
  [Ddd] Mmm DD HH:MM:SS YYYY) into an integer which represents a
  count of seconds since Jan 01 00:00:00 1970 UTC not including leap
  secs. Where Ddd, if given, is the day of the week. Mmm is the month
  name, DD is the day of the month, HH is the hour in 24-hour time,
  MM is the minutes, SS is the seconds, and YYYY is the year.

  Keep in mind that the year may not be exactly four characters and
  it can also be negative. This server provides a proleptic Gregorian
  calendar with a range of supported years between 27257 BC and
  30826 AD. Year 0 is 1 BC, -1 is 2 BC, ..., so 27257 BC should be
  given as -27256. This follows the astronomical conventions.

  If a second argument is given, it is the <zonename>:

   local - indicates that a conversion for timezone/DST of the 'local'
           server time should be applied (the default).

   utc   - indicates that no timezone/DST conversions should be applied.
           When used this way, there is a unique one-to-one relationship
           between an integer and it's corresponding text-string which
           may be useful for handling other timezones and fictional
           settings.
   
  Example:
    > say time()
    You say "Wed Jun 24 10:22:54 1992"
    > say convtime(Wed Jun 24 10:22:54 1992)
    You say "709395774"
    > say convtime(Wed Jun 24 10:22:54 1992, utc)
    You say "709381374"

  See also: convsecs(), secs(), time().

& SORT()

  Function: sort(<list>[, <sort type>[, <delim>]])
 
  Takes a list of words, numbers, or dbref, and sorts them into ascending
  order.  Lexicographic order is used for words, and numeric order is used
  for numbers and dbrefs.
 
  <sort type> may be used to specify the type of sort to perform (use d for
  dbref, n for integer numeric, f for floating numeric, and a for
  alphanumeric).  If omitted or left blank, the sort() function will
  automatically determine the type of sort to perform.
 
  If <delim> is specified, it (rather than a space) is used to separate items
  in the list.  You may specify an alternate delimiter without specifying
  a sort type by passing a null <sort type> parameter.
 
  Examples:
    > say sort(This is a test)
    You say "This a is test"
    > say sort(98 99 100 101)
    You say "98 99 100 102"
    > say sort(foo-bar-bletch,,-)
    You say "bar-bletch-foo"

& SETDIFF()

  Function: setdiff(<list1>, <list2>[, <delim>])
 
  This function returns the difference of two sets -- i.e., the elements in
  <list1> that aren't in <list2>. The list that is returned is sorted.
 
  If <delim> is specified, it (rather than a space) is used to separate items
  in the list.
 
  Example:
    > say setdiff(foo baz gleep bar, bar moof gleep)
    You say, "baz foo"
  See also: setinter(), setunion(), sort().

& SETINTER()

  Function: setinter(<list1>, <list2>[, <delim>])
 
  This function returns the intersection of two sets -- i.e., the elements
  that are in both <list1> and <list2>. The list that is returned is sorted.

  If <delim> is specified, it (rather than a space) is used to separate items
  in the list.
 
  Example:
    > say setinter(foo baz gleep bar, bar moof gleep)
    You say, "bar gleep"
  See also: setdiff(), setunion(), sort().

& SETUNION()

  Function: setunion(<list1>, <list2>[, <delim>])
 
  This function returns the union of two sets -- i.e., all the elements of
  both <list1> and <list2>, minus any duplicate elements. Think of it as
  CAT() without duplicated words.  The list returned is sorted.
 
  If <delim> is specified, it (rather than a space) is used to separate items
  in the list.
 
  Example:
    > say setunion(foo baz gleep bar, bar moof gleep)
    You say, "bar baz foo gleep moof"
  See also: setdiff(), setinter(), sort().

& MERGE()

  Function: merge(<string1>,<string2>,<character>)
  
  This function merges <string1> and <string2>, depending on <character>.
  If a character in <string1> is the same as <character>, it is replaced
  by the character in the corresponding position in <string2>.  The two
  strings must be of the same length.
  
  Spaces need to be treated specially. A null character is considered to
  equal a space, for <character>.
  
  Examples:
    > say merge(AB--EF,abcdef,-)
    You say, "ABcdEF"
    > say merge(AB[space(2)]EF,abcdef,)
    You say, "ABcdEF"
  See also: splice().

& REPEAT()

  Function: repeat(<string>,<number>)
  
  This function simply repeats <string>, <number> times.  No spaces are
  inserted between each repetition.
  
  Example:
    > say repeat(Test, 5)
    You say, "TestTestTestTestTest"

& SPLICE()

  Function: splice(<list1>, <list2>, <word>[, <delim>])
  
  This function splices <list1> and <list2> together. <list1> and <list2>
  are space-separated lists of words
  
  If a word in <list1> is the same as <word>, it is replaced by the word
  in the corresponding position in <list2>.  Both lists must have the
  same number of words.

  <delim> may be used to specify a delimiter other than a space.  
 
  Example:
    > say splice(foo bar baz,eek moof gleep,bar)
    You say, "foo moof baz"
  See also: merge().

& PI()

  Function: pi()
 
  Returns the value of the trigonometric constant pi to nine decimal places.
 
  Example:
    > say pi()
    You say "3.141592654"
  See also: acos(), asin(), atan(), cos(), sin(), tan().

& E()

  Function: e()
  Returns the value of the numeric constant e to nine decimal places.
 
  Example:
    > say e()
    You say "2.718281828"
  See also: exp(), ln(), log(), power().

& SIN()

  Function: sin(<number>)
 
  Returns the sine of <number>, expressed in radians.
 
  Examples:
    > say sin(0)
    You say "0"
    > say sin(fdiv(pi(),2))
    You say "1"
    > say sin(fdiv(pi(),4))
    You say "0.707107"
    > say sin(fdiv(pi(),6))
    You say "0.5"
  See also: acos(), asin(), atan(), cos(), pi(), tan().

& COS()

  Function: cos(<number>)
 
  Returns the cosine of <number>, expressed in radians.
 
  Examples:
    > say cos(0)
    You say "1"
    > say cos(fdiv(pi(),2))
    You say "0"
    > say cos(fdiv(pi(),4))
    You say "0.707107"
    > say cos(fdiv(pi(),6))
    You say "0.866025"
  See also: acos(), asin(), atan(), pi(), sin(), tan().

& TAN()

  Function: tan(<number>)
 
  Returns the tangent of <number>, expressed in radians.
 
  Examples:
    > say tan(0)
    You say "0"
    > say tan(1)
    You say "1.557408"
    > say tan(fdiv(pi(),4))
    You say "1"
  See also: acos(), asin(), atan(), cos(), pi(), sin().

& ASIN()

  Function: asin(<number>)
 
  Returns the arcsine of <number>, expressed in radians.
 
  Examples:
    > say asin(0)
    You say "0"
    > say asin(1)
    You say "1.570796"
    > say asin(0.707101)
    You say "0.78539"
    > say asin(0.5)
    You say "0.523599"
  See also: acos(), atan(), cos(), pi(), sin(), tan().

& ACOS()

  Function: acos(<number>)
 
  Returns the arc-cosine of <number>, expressed in radians.
 
  Examples:
    > say acos(0)
    You say "1.570796"
    > say acos(1)
    You say "0"
    > say acos(0.707101)
    You say "0.785406"
    > say acos(0.866025)
    You say "0.5236"
  See also: asin(), atan(), cos(), pi(), sin(), tan().

& ATAN()

  Function: atan(<number>)
 
  Returns the arctangent of <number>, expressed in radians.
 
  Examples:
    > say atan(0)
    You say "0"
    > say atan(1)
    You say "0.785398"
    > say atan(1.557408)
    You say "1"
  See also: acos(), asin(), cos(), pi(), sin(), tan().

& FLOOR()

  Function: floor(<number>)
 
  Returns the largest integer less than or equal to <number>.  <number> may be
  a floating point number, and an integer result is returned.
 
  Examples:
    > say floor(5)
    You say "5"
    > say floor(5.2)
    You say "5"
    > say floor(5.8)
    You say "5"
    > say floor(-5)
    You say "-5"
    > say floor(-5.2)
    You say "-6"
  See also: ceil(), div(), mod(), round(), trunc().

& CEIL()

  Function: ceil(<number>)
 
  Returns the smallest integer greater than or equal to <number>.  <number>
  may be a floating point number, and an integer result is returned.
 
  Examples:
    > say ceil(5)
    You say "5"
    > say ceil(5.2)
    You say "6"
    > say ceil(5.8)
    You say "6"
    > say ceil(-5)
    You say "-5"
    > say ceil(-5.2)
    You say "-5"
  See also: div(), floor(), mod(), round(), trunc().

& TRUNC()

  Function: trunc(<number>)
 
  Returns the value of <number> after truncating off any fractional value.
  <number> may be a floating point number, and an integer result is returned.
 
  Examples:
    > say trunc(5)
    You say "5"
    > say trunc(5.2)
    You say "5"
    > say trunc(5.8)
    You say "5"
    > say trunc(-5)
    You say "-5"
    > say trunc(-5.2)
    You say "-5"
  See also: div(), floor(), mod(), round().

& ROUND()

  Function: round(<number>,<places>)
 
  Rounds <number> to <places> decimal places.  <number> may be
  a floating point number, and an integer result is returned.
 
  Examples:
    > say round(5,0)
    You say "5"
    > say round(5.123,1)
    You say "5.1"
    > say round(9.8765,3)
    You say "9.877"
    > say round(5.5,0)
    You say "6"
    > say round(-5.5,0)
    You say "-6"
  See also: div(), floor(), mod(), trunc().

& SQRT()

  Function: sqrt(<number>)
 
  Returns the square root of <number>.  <number> may be a floating point
  number, and a floating point result is returned.  <number> may not be
  negative.
 
  Examples:
    > say sqrt(2)
    You say "1.414214"
    > say sqrt(100)
    You say "10"
    > say sqrt(0)
    You say "0"
    > say sqrt(-1)
    You say "#-1 SQUARE ROOT OF NEGATIVE"
  See also: power().

& SQUISH()
 
  Function: squish(<text>)
 
  This function literally 'squishes' the given text, reducing multiple
  instances of spaces to a single space, after evaluating everything
  normally.

& POWER()

  Function: power(<number>, <power>)
 
  Returns the result of raising <number> to the <power>'th power.
  <number> may not be negative.  <number> and <power> may be floating point
  numbers, and a floating point result is returned.
 
  Examples:
    > say power(2,3)
    You say "8"
    > say power(9, 0.5)
    You say "3"
    > say power(100,pi())
    You say "1919487.587204"
    > say power(5, 0)
    You say "1"
    > say power(0, 0)
    You say "1"
    > say power(2,-3)
    You say "0.125"
    > say power(-2,3)
    You say "#-1 POWER OF NEGATIVE"
  See also: exp(), ln(), log(), sqrt()

& LN()

  Function: ln(<number>)
 
  Returns the result of taking the natural logarithm (base e) of <number>.
  <number> may be a floating point number, and a floating point result
  is returned.
 
  Examples:
    > say ln(0)
    You say "#-1 LN OF NEGATIVE OR ZERO"
    > say ln(1)
    You say "0"
    > say ln(e())
    You say "1"
    > say ln(10)
    You say "2.302585"
  See also: e(), exp(), log(), power().

& LOG()

  Function: log(<number>)
 
  Returns the result of taking the common logarithm (base 10) of <number>.
  <number> may be a floating point number, and a floating point result
  is returned.
 
  Examples:
    > say log(0)
    You say "#-1 LOG OF NEGATIVE OR ZERO"
    > say log(1)
    You say "0"
    > say log(10)
    You say "1"
    > say log(e())
    You say "0.434294"
  See also: e(), exp(), ln(), power().

& EXP()

  Function: exp(<power>)
 
  Returns the result of raising the numeric constant e to <power>.
  <power> may be a floating point number, and a floating point result
  is returned.
 
  Examples: 
    > say exp(0)
    You say "1"
    > say exp(1)
    You say "2.718282"
    > say exp(2)
    You say "7.389056"
  See also: e(), log(), ln(), power().
& PARSE()

  Function: parse(<list>,<eval>[,<delimiter>])

  This function takes each element of <list>, evaluates <eval> after
  substituting it for ##, and constructs a space-separated list of the
  results.

  Examples:
    > say parse(1 2 3 4 5,add(##,1))
    You say "2 3 4 5 6"
    > say parse(This|is|a|string|length|test,strlen(##),|)
    You say "4 2 1 6 6 4"
  See also: @dolist, iter(), map().

& CONTROLS()

  Function: controls(<object>,<victim>)
 
  Returns 1 if <object> controls <victim>, 0 otherwise.
 
  Examples:
  > say controls(me,me)
  You say "1"
  > say controls(me,#1)
  You say "0"
  > say controls(#1,me)
  You say "1"
 
  See also: CONTROL.

& map()

  Function: map([<obj>/]<attr>, <list>[, <delim>])
  
  This function is nearly identical to an iter() operating on u() function.
  Each member of <list> is passed to the result of fetching <attr> as %0, and
  the results are used to form a new list, separated by the delimiter
  character.
  
  <delimiter> may be used to specify a delimiter other than space.
  
  Examples: 
  > &ADD_ONE object=add(%0,1)
  > say map(object/add_one,1 2 3 4 5)
  You say "2 3 4 5 6"
  
  See also: filter(), fold(), iter(), parse(), u().

& filter()

  Function: filter([<obj>/]<attr>, <list>[, <delim>])

  This function evaluates the contents of <attr> for each element of <list>,
  passing it in as %0.  A <delimiter>-separated list is returned of those
  elements for which the evaluation returns the value 1.

  <delimiter> may be used to specify a delimiter other than space.
  
  Examples:
    > &IS_ODD object=mod(%0,2)
    > say filter(object/is_odd,1 2 3 4 5)
    You say "1 3 5"
  See also: u(), map(), fold()

& fold()

  Function: fold([<obj>/]<attr>, <list>[, <base-case>[, <delim>])

  This function iteratively processes a list through a function, feeding
  the result of one step into the next step as %0, passing in the next element
  from the list as %1.

  If a base case is provided, it is used as the initial %0.  If not, the first
  list element is passed as %0 and the second is passed as %1, and subsequent
  iterations proceed normally.
  
  <delimiter> may be used to specify a delimiter other than space, but you
  must specify a base case in order to specify the delimiter.
 
  Examples:
    > &REP_NUM object=[%0][repeat(%1,%1)]
    > say fold(object/rep_num,1 2 3 4 5,->)
    You say "->122333444455555"
    > &ADD_NUMS object=add(%0,%1)
    > say fold(object/add_nums,1 2 3 4 5)
    You say "15"
  See also: u(), iter(), map(), filter()

& RJUST()

  Function: rjust(<string>, <length>[, <fill>])
 
  This function pads a string with leading <fill> characters, or with spaces
  if no fill character is given) ("right-justifies") so it is <length> long.
  If <string> is longer than <length>, the <string> is returned; it is not
  truncated.
 
  Examples:
    > say -[rjust(foo,6)]-
    You say "-   foo-"
    > say %r0[rjust(foo,6)]7%r01234567
    You say "
    0   foo7
    01234567"
    > say =[rjust(bar,5,.)]=
    You say "=..bar="
  See also: ljust(), strlen().

& LJUST()

  Functions: ljust(<string>, <length>[, <fill>])
 
  This function pads a string with trailing <fill> characters, or with spaces
  if no fill character is given) ("left-justifies") so it is <length> long.
  If <string> is longer than <length>, the <string> is returned; it is not
  truncated.
 
  Examples:
    > say -[ljust(foo,6)]-
    You say "-foo   -"
    > say %r0[ljust(foo,6)]7%r01234567
    You say "
    0foo   7
    01234567"
    > say =[ljust(bar,5,.)]=
    You say "=bar..="
  See also: rjust(), strlen().

& R()

  Function: r(<number>)
 
  The r() function is used to access "local registers", and returns
  the contents of the specified register. There are ten such registers,
  numbered 0 through 9.  The local registers are normally cleared at the
  start of each command, but are preserved across the commands that compose
  an actionlist, as well as commands that directly trigger actionlists, such
  as @switch, @trigger, and @dolist.
 
  See also: setq(), setr().

& SETQ()

  Function: setq(<number>,<string>)
 
  The setq() function is used to copy strings into local registers.
  It returns a null string; it is a purely "side effect" function.

  There are ten local registers, numbered 0 through 9. They are cleared
  at the start of each interactive command, but are preserved across the
  command queue. They are most useful for storing complex function
  evaluations which are used repeatedly within a single command.
  The local registers may be read via the r() function, and a common use
  of setq()/r() is to temporarily store the result of a complex evaluation
  whose result is needed more than once.
 
  setq() can be used to improve the readability of MUX code, as well as to
  cut down the amount of time needed to do complex evaluations.
 
  Example:
    > &TEST me=Test on [mudname()] at [time()].
    > say [setq(0,u(TEST))]'[r(0)]' has length [strlen(r(0))].
    You say "'Test on TestMUX at Tue Feb 23 17:00:51 1993.' has length 45."
  See also: r(), setr().

& SETR()

  Function: setr(<number>,<string>)
 
  This function is identical to setq(), but returns <string>.
 
  See also: setq(), r().
 
& SHUFFLE()

  Function:  shuffle(<word1> <word2> <...<wordN>[,<delimiter>])
 
  This function shuffles the order of words in a list, returning a random
  permutation of its elements.
 
  Example:
    > say shuffle(foo bar baz gleep)
    You say "baz foo gleep bar"
 
& SCRAMBLE()

  Function:  scramble(<string>)
 
  This function scrambles a string, returning a random permutation of its
  characters. Note that this function does not pay any attention to spaces
  or other special characters; it will scramble these characters just like
  normal characters.
 
  Example:
    > say scramble(abcdef)
    You say "cfaedb"
 
  See also:  SHUFFLE()

& SORTBY()

  Function: sortby([<obj>/]<attrib>,<list>[,<delimiter>])
 
  This sorts an arbitrary list according to the u-function <obj>/<attrib>.
  This u-function should compare two arbitrary elements, %0 and %1, and
  return zero (equal), a negative integer (element 1 is less than element 2)
  or a positive integer (element 1 is greater than element 2).
 
  A simple example, which imitates a normal alphabetic sort:
    > &ALPHASORT test=[comp(%0,%1)]
    > say [sortby(test/ALPHASORT,foo bar baz)]
    You say "bar baz foo"
 
  A slightly more complicated sort. #1 is "God", #2 is "Amby", "#3" is "Bob":
    > &NAMESORT me=[comp(name(%0),name(%1))]
    > say [sortby(NAMESORT,#1 #2 #3)]
    You say "#2 #3 #1"
 
  Warning: the function invocation limit applies to this function. If
  this limit is exceeded, the function will fail _silently_. List and
  function sizes should be kept reasonable.
 
& TRANSLATE()
 
  Function: translate(<string>, <type>)
 
  This function takes <string>, and converts all raw ANSI color codes and
  carriage returns to either MUX substitutions, or to spaces. If <type> is
  0 or 's', the raw codes are converted to spaces, if it is 1 or 'p', the
  codes are converted to MUX %x and %r substitutions.

& TRIM()

  Function: trim(<string> [,<trim style> [,<trim character>]])
 
  This function will trim trailing and/or lead characters on the string
  that you specify.  <trim character> specifies the character to trim (default
  is space), and <trim style> tells the kind of trimming to perform (default
  is trim both sides of the string).
 
  The following values for <trim style> are recognized:
      'b' :   Trim both ends of the string (default)
      'l' :   Trim the left end of the string.
      'r' :   Trim the right end of the string.
  Note: anything else specified for <trim style> will trim both sides.
 
  Example:
    > say trim(;;;Wacka;;;,,;)
    You say "Wacka"
    > say trim(%b%b%b Polly Parrot %b%b%b%b,,r)
    You say "    Polly Parrot"
    > say trim(---Trim Rules!---,-,l)
    You say "Trim Rules!---"
  See also: center(), ljust(), rjust().

& CENTER()

  Function: center(<string>,<width>[,<fill>])
 
  This function will center a string in a string <width> characters wide,
  using <fil> characters for padding on either end of the string for
  centering.  If no fill character is specified then a space is used.
  If <string> is longer than <width> characters, the string is returned
  unmodified.
 
  Example:
    > say center(a,5,-)
    You say "--a--"
    > say center(*BAMF*,15)
    You say "    *BAMF*     "

& INSERT()

  Function: insert(<list>, <pos>, <word>[, <sep>])
 
  This function inserts a word into <list> so that the word becomes the
  <pos>'th element of the list, and all subsequent list elements are moved
  down.  This means that it appears between the <pos-1>'th and <pos>'th
  elements of the original list.  This function may also be used to append
  a word to a list.
 
  <delim> may be used to specify a delimiter other than a space.
 
  Examples:
    > say insert(This is a test, 4, new)
    You say "This is a new test"
    > say insert(Yet@Another@List, 3, Funky, @)
    You say "Yet@Another@Funky@List"
  See also: extract(), ldelete(), replace().

& REPLACE()

  Function: replace(<list>, <pos>, <word>[, <sep>])
 
  This function inserts a word into <list> so that the word becomes the
  <pos>'th element of the list, and the word previously in that position
  is removed.  This means that it appears between the <pos-1>'th and
  <pos+1>'th elements of the original list, replacing the word at that
  position.  This function may not be used to append a word to a list.
 
  <delim> may be used to specify a delimiter other than a space.
 
  Examples:
    > say replace(This is a test, 4, quiz)
    You say "This is a quiz"
    > say replace(Yet@Another@Mundane@List, 3, Funky, @)
    You say "Yet@Another@Funky@List"
  See also: extract(), insert(), ldelete().

& LDELETE()

  Function: ldelete(<list>, <pos>[, <sep>])
 
  This function removes a word from <list> by position.
  <delim> may be used to specify a delimiter other than a space.
 
  Examples:
    > say ldelete(This is not a test, 3)
    You say "This is a test"
    > say ldelete(Yet@Another@Mundane@List, 3, @)
    You say "Yet@Another@List"
  See also: extract(), insert(), replace().

& ISDBREF()

  Function: isdbref(<string>)
 
  This function will return 1 if the string passed to it is a valid dbref.
  To be a valid dbref the string must begin with '#' and be followed by an
  interger.  Also, the dbref must exist in the current database as a valid
  object.  If the object fails either of these criteria, then a 0 is
  returned.
 
  Example:
     > say isdbref(#-1)
     You say "0"
     > say isdbref(#1)
     You say "1"
     > say isdbref(This is not a dbref)
     You say "0"

& ISNUM()
 
  Function: isnum(<string>)
 
  This function will return return 1 if the argument is a valid number and 0
  if it is not.
 
  Example:
     > say isnum(22223.0000)
     You say "1"
     > say isnum(77)
     You say "1"
     > say isnum(22 L)
     You say "0"
     >say isnum(Bad Numbers!)
     You say "0"
 
& ZONE()

  Function: zone(<object>)
 
  Returns the object's 'zone'. This is the dbref of the master object
  which defines the zone.

& ZWHO()

  Function: zwho(<object>)
 
  Returns a list of players who are in the zone defined by <object>.
  Currently a wizard/royalty only function.
 
& INZONE()

  Function: inzone(<object>)
 
  Returns a list of rooms in the zone defined by <object>. Currently a
  wizard/royalty only function.
  
& CHILDREN()

  Function: children(<object>)
 
  Returns a list of objects that are parented to <object>. Currently a
  wizard/royalty only function.
 
& ENCRYPT()

  Function: encrypt(<text>,<key>)
 
  Encrypts <text> using <key>. The text can only be unlocked with <key>, and
  <key> is case-sensitive.
 
& DECRYPT()

  Function: decrypt(<text>,<key>)
 
  Decrypts <text> using <key>. <key> should be the same one used to encrypt
  the text, and is case sensitive.
 
& MAIL()

  mail(<mail message #>)
  mail(<player name>)
  mail(<player>, <mail message #>)
  mail()

  The first form returns a message corresponding to that mail message
  number in your MUX mailbox. This function can be used to forward
  mail, or as a way to simply transfer mail messages to attributes
  on an object.
 
  The second form returns three numbers, corresponding to the number of
  read, unread, and cleared messages <player> has.
  The third form returns <player>'s <mail message #>. It works like
  the first form except it applies to another player.
  The last form returns the number of messages the evaluating player has.
  Only wizards can use the second and third forms of the function
  on other players.
 
& MAILFROM()

  Function: mailfrom(<msg #>)
 
  Returns the dbref # of the player who sent you <msg #>. Wizards may
  specify mailfrom(<player>,<msg #>).
 
& DEFAULT()

  Function:  default(<obj>/<attr>,<default case>)
 
  This function returns the value of <obj>/<attr>, as if retrieved via
  the get() function, if the attribute exists and is readable by you.
  Otherwise, it evaluates the default case, and returns that.
  Note that the default case is only evaluated if the attribute does
  not exist or cannot be read.
 
  This is useful for code that needs to return the value of an attribute,
  or an error message or default case, if that attribute does not exist.
 
  Examples:
    > &TEST me=apple orange banana
    > say default(me/Test, No fruits!)
    You say "apple orange banana"
    > &TEST ME
    > say default(me/Test, No fruits!)
    You say "No fruits!"
 
  See also:  get(), get_eval(), u(), edefault(), udefault().
 
& EDEFAULT()

  Function:  edefault(<obj>/<attr>,<default case>)
 
  This function returns the evaluated value of <obj>/<attr>, as if
  retrieved via the get_eval() function, if the attribute exists and
  is readable by you. Otherwise, it evaluates the default case, and
  returns that. The default case is only evaluated if the attribute
  does not exist or cannot be read.
 
  Example:
    > &TEST me=You have lost [rand(10)] marbles.
    > say edefault(me/Test,You have no marbles.)
    You say "You have lost 6 marbles."
    > &TEST me
    > say edefault(me/Test,You have no marbles.)
    You say "You have no marbles."
  
  See also:  get(), get_eval(), u(), default(), udefault().
 
& UDEFAULT()

  Function:  udefault([<obj>/]<attr>,<default case>[,<arg>]...)
 
  This function returns the value of the user-defined function
  as defined by <attr> (or <obj>/<attr>), as if retrieved via
  the u() function, with <args>, if the attribute exists and is
  readable by you.
 
  Otherwise, it evaluates the default case, and returns that. The
  default case is only evaluated if the attribute does not exist
  or cannot be read.
 
  Examples:
    > &TEST me=[center(%0,5,*)]
    > say udefault(Test,-- BOOM --,ACK)
    You say "*ACK*"
    > &TEST me
    > say udefault(me/Test,-- BOOM --,ACK)
    You say "-- BOOM --"
 
  See also:  get(), get_eval(), u(), default(), edefault().


& ULOCAL()

  Function:  ulocal([<obj>/]<attr>[,<arg>]...)
 
  The ulocal() function is almost identical to u() in function:  it
  evaluates an attribute, either from the object performing the function,
  or another object that you control or has the same owner as you, passing
  in arguments and returning the result. When evaluating the fetched
  attribute, %# refers to the original enactor and not the 'calling' object;
  'me' refers to the object that supplied the attribute.
 
  However, unlike the u() function, the global registers r(0) through r(9)
  (%q0 - %q9) are preserved in their initial state. This means that functions
  "below" the level of the u() can reset global registers for temporary
  calculations, without needing to worry about "clobbering" the original
  values.
 
  This makes ulocal() particularly useful for global or shared code which
  calls arbitrary u() functions, where global register values need to be
  preserved from accidental user clobbering.
 
  See "help ulocal2" for examples.
 
& ULOCAL2

  Example of ulocal():
    > &FRUIT me=apples bananas oranges pears
    > &SUB-FUNCTION me=[setq(0,v(FRUIT))][extract(%q0,match(%q0,%0),1)]
    > &TOP-FUNCTION me=[setq(0,are delicious!)][ulocal(SUB-FUNCTION,%0)] %q0
    > say u(TOP-FUNCTION,b*)
    You say "bananas are delicious!"
 
  If SUB-FUNCTION had been called with u() instead of ulocal():
    > &TOP-FUNCTION me=[setq(0,are delicious!)][u(SUB-FUNCTION,%0)] %q0
    > say u(TOP-FUNCTION,b*)
    You say "bananas apples bananas oranges pears"
 
  In this second example, in SUB-FUNCTION, %q0 was set to "apples bananas
  oranges pears", so that when the u() "returned" and TOP-FUNCTION evaluated
  %q0, this is what was printed. In the first example, ulocal() reset the
  value of %q0 to its original "are delicious!"
 
  See also:  u(), setq(), r()

& FINDABLE()

  Function:  findable(<object>,<victim>)
 
  Returns 1 if <object> can locate <victim>, or 0 otherwise. This checks
  wizard status of <object>, UNFINDABLE status of <victim>, and other
  related factors. If <object> would not be able to see <victim> were 
  they in the same location a 0 will be returned.
 
& VISIBLE()

  Function:  visible(<object>,<victim>[/<attr>])
 
  Returns 1 if <object> can examine <victim>, or 0 otherwise. If
  <object> or <victim> do not exist, 0 is returned.
 
  If an object-attribute pair is provided, 1 is returned if <object>
  can see <attr> on <victim>. If <attr> is not present on <victim>,
  1 is returned if <object> can examine <victim>.
 
& LAST()

  Function: last(<string>[, <delim>])
 
  Returns the last word of a string, that is, everything to the right
  of the last space in the string, or the entire string if there are no 
  spaces in the string.
 
  <delim> may be used to specify a word delimiter other than a space.
 
  Example:
    > say last(This is a test)
    You say "test"
    > say last(Happy-Fun-Test-Thing,-)
    You say "Thing"
 
  See also:  first(), rest().

& MATCHALL()

  Function: matchall(<string>,<pattern>[,<delim>])
 
  This function works identically to the match() function, save that it
  returns all matches, not just the first: It returns the index numbers of
  all words in the list <string> which match <pattern>.
 
  Examples:
 
  > say matchall(This is a test of a test,test)
  You say "4 7"
  > say matchall(This is testing a test,tes*)
  You say "3 5"
 
  See also: LISTS, match(), strmatch(). 

& PORTS()

  ports(<player name>)
 
  This function returns the list of descriptors ("ports") that a player,
  specified by full player name, or by dbref, is connected to. Wizards
  can use this function on anyone, but mortals can only use it on
  themselves.

  If the <player> is not connected, an empty list is returned. Otherwise,
  a list of ports is returned in order of most recent connection to least
  recent connection. These ports correspond to those given by the SESSION
  command.
  
& ELEMENTS()

  elements(<list of words>,<list of numbers>[,<delim>])
 
  This function returns the words in <list of words> that are in the
  positions specified by <list of numbers>. Optionally, a list delimiter
  other than a space can be separated.
 
  Examples:
    > say elements(Foo Ack Beep Moo Zot,2 4)
    You say "Ack Moo"
    > say elements(Foof|Ack|Beep|Moo,3 1,|)
    You say "Beep|Foof"

& GRAB()

  Function:  grab(<list>, <pattern>[, <delim>])
  
  This function matches <pattern> against each word in <list>, returning
  the first word that matches. If no words match, then an empty string
  is returned. The match is not case-sensitive, and wildcard characters
  are permitted. <delim> may be used to specify a list delimiter other
  than a space.
 
  Examples:
    > say grab(This is a new test,?e*)
    You say "new"
    > say grab(Holodeck:#10~Airlock:#58~Dorm:#12~Brig:#83,Airlock:*,~)
    You say "Airlock:#58"
 
  See also: LISTS, match().
 
& PEMIT()
 
  Function: pemit(<list of objects>, <message>)
 
  A side effect function, with the same effect as @pemit/list <list of
  objects> = <message>.
 
  See also: @pemit.
 
& EMPTY()
  
  Function: empty([<object>])
  
  This function completely empties the stack for the calling object. If
  <object> is specified, and you control it, it empties the stack for
  <object>.
 
  See also: lstack(), items(), peek(), pop(), push(), OBJECT STACK.
 
& ITEMS()
 
  Function: items([<object>])
 
  items() returns the number of items that the stack of the calling object
  contains. If <object> is specified and you control it, then it returns the
  number of items in the stack of that object.
 
  See also: lstack(), empty(), peek(), pop(), push(), OBJECT STACK.
 
& LSTACK()
 
  Function: lstack([<object>])
 
  This function returns the contents of an object's stack as a list. If
  <object> is not specified, then it returns the stack of the executing
  object.
  See also: push(), pop(), peek(), empty(), items(), OBJECT STACK.
 
& PEEK()
 
  Function: peek([<object>], [<position>])
 
  peek() returns an item from the caller's stack without removing it from
  the stack. If <position> is specified, it returns the item from that
  position in the stack (items in the stack are numbered with 0 being the most
  recently push()ed item), otherwise, it returns position 0. If <object> is
  specified and you control it, then it returns an item from <object>'s
  stack.
 
  See also: lstack(), empty(), items(), pop(), push(), OBJECT STACK.
 
& POP()
 
  Function: pop([<object>], [<position>])
 
  pop() returns an item from the caller's stack and removes it from
  the stack. If <position> is specified, it returns the item from that
  position in the stack (items in the stack are numbered with 0 being the most
  recently push()ed item) and removes it, otherwise, it returns position 0.
  If <object> is specified and you control it, then it returns an item from
  <object>'s stack.
 
  See also: lstack(), empty(), items(), peek(), push(), OBJECT STACK.
 
& PUSH()
 
  Function: push(<data>)
            push(<object>, <data>)
 
  push() places <data> onto the calling object's stack. If the second form
  is used, it places data onto <object>'s stack.
 
  See also: lstack(), empty(), items(), peek(), pop(), OBJECT STACK.
 
& COMALIAS()
 
  Function: comalias(<player>, <channel>)
 
  comalias() returns the alias the player uses to access the named channel.
  Non-wizards can only use it to return their own alias.
 
  See also: comtitle()
 
& CHANNELS()
 
  Function: channels()
 
  This function lists all the channels known to the MUX (that you can see).
 
& COMTITLE()
 
  Function: comtitle(<player>, <channel>)

  comtitle() returns the comtitle the player has set on the named channel.
  Non-wizards can only use it to return their own comtitles.
 
  See also: comalias()
 
& DOING()
 
  Function: doing(<player>)
 
  doing() returns the connected player's @doing entry.
 
  See also: poll()
 
& MOTD()
 
  Function: motd()
 
  motd() returns the current MOTD as set using @motd.
 
& POLL()
 
  Function: poll()
 
  poll() returns the current poll (the top of the @doing column in WHO) as
  set with the @poll command.
 
  See also: doing()

& OBJECT STACK
 
  NOTE: The object stack is completely different from the command stack
  ('help stack').
 
  A stack is a LIFO structure, meaning that the last, most recent thing you
  place into it is the first thing you get out of it. You 'push' an item
  onto the stack, and you can 'pop' it off, or merely take a 'peek' at it.
  If you pushed the word 'foo', and then the word 'bar', and popped
  something off the stack, you would first pop 'bar', then 'foo'. You pop
  or peek in the reverse order that you pushed.
 
  The object stack can hold any kind of information. In this manner they are
  similar to r-registers, but are more flexible. There is a high limit to the
  number of stack entries you can have (usually 100), and stack entries are
  preserved until you pop them off or empty the stack.
 
{ 'help OBJECT STACK2' for more }
 
& OBJECT STACK2
  
  Example:
  
  > say [push(world!)][push(Hello)]We'll print these...
  We'll print these...
  > say [pop()] [pop()]
  Hello world!
 
  empty() is used to clear the stack, items() shows the number of entries in
  the stack.
 
  See also: lstack(), empty(), items(), push(), peek(), pop().
 
& OBF

  The OBF Flag is used to denote someone using a form of invisibility,
  most commonly the vampiric discipline of Obfuscate. They must also have 
  an attribute set on them, OBF_LEVEL, which denotes the level of
  invisibility they posses. When this attribute is present and the flag is
  set on them they do not show up in the contents list of rooms. If a
  player moves through an exit and has OBF_LEVEL of 1 then they will no
  longer be invisible and will trigger the exit message. OBF_LEVEL of 2 or
  higher will no longer do this. At OBF_LEVEL is 3 or higher they can set
  their true desc in the attribute OBFDESC so that it will only be seen by
  those with the ability to see through their disguise.
  See also: HSS

& HSS

  The HSS flag denotes someone who can see through certain levels of 
  invisibility. They must have the HSS_LEVEL attribute set. If they have
  this flag and attribute set they will see anyone with a lower OBF_LEVEL
  then their HSS_LEVEL attribute, they will also see the OBFDESC if it
  is present, showing the invisible character's true appearance. However,
  if HSS_LEVEL is equal to OBF_LEVEL then there is a random chance that 
  they will see through the invisibility.
  See also: OBF

& UMBRA
 
  The UMBRA flag is used to denote an object which is in the umbra. They
  will see the room's UMBRADESC if it is present and will not see or be
  seen by those not set UMBRA.

& SHROUD

  The SHROUD flag is used to denote an object who is in the shroud. They
  can be heard by those set MEDIUM but not seen. They see the WRAITHDESC
  of the room if it is present and they see anything set SHROUD as
  well as other normally visible objects.

& MEDIUM

  The MEDIUM flag denotes a player who is a medium. With this flag set
  they can hear what is said by those set SHROUD but not see them. They
  can see those who are visible normally only.

& MATRIX

  The MATRIX flag is used to denote an object who is in the Matrix or
  Digital Web. Rooms will list contents as |Icons| and will only list
  players and objects also set MATRIX. MATRIXDESC can be set on a
  player or object as the description of their icon.

& FAE

  The FAE flag is used to denote an object which is visible to others with
  a regular description but see's FAEDESC's and those set CHIMERA. Most
  commonly used for Changelings and those who have been Enchanted by one.

& CHIMERA

  The CHIMERA flag is used to denote an object who is invisible to all but
  those set CHIMERA and FAE.

& PEERING

  The PEERING flag is used to denote an object which is looking into
  another realm but is not visible there. It requires the attribute
  PEERING_REALM be set with a value of the realm being watched. The
  value MUST be in all uppercase letters.

& CANSEE()

  Syntax: CANSEE(looker, lookee[,lookee_action])

  This is useful for wizard code in the master room, help it decide
  who/what should be able to see who/what, and saves the softcoders the hassle of
  duplicating these rules in softcode. The third parameter is optional,
  but if present should be 0 for standing still, 1 for moving, and 2 for
  talking. CANSEE returns 1 or 0 depending on whether it's possible or not
  to see, respectively. 

  
& LINK()
LINK()

  Function: link(<name>,<destination>)
  Works the same as @link, <name> and <destination> are equivalent to what
  comes before and after the '=' sign. Returns nothing. This is a side
  effect function, and should only be used when necessary.

  Related Topics: @link

& SUBEVAL()
SUBEVAL()

  Function: subeval(<string>)
  This function's usefulness is primarily useful in conjunction with
  v() as a way to control when evalution occurs. Escapes are
  evaluated, but and functions are not. The location escape is also
  not evaluated.

  When used from the command line, it's use is limited to nil because
  evaluation of subeval's parameters occurs before the subeval()
  function is called.

& TEL()
TEL()

  Function: tel(<name>,<destination>)
  Works the same as @tel, <name> and <destination> are equivalent to what
  comes before and after the '=' sign. Returns nothing. This is a side
  effect function, and should only be used when necessary.

  Related Topics: @teleport


& VALID()
VALID()

  Function: valid(<name>,<argument>)
  This returns true or false depending on whether the characters and
  arrangement of characters in <argument> satisfy the restrictions
  implied by <name>

  For example, A <name> of 'name' causes <argument> to be validated as
  an object name. Valid() does not check the database for existance and
  it does not guarantee that if you try to create such an object that
  the attempt will succeed. It only looks at <argument> as a string
  of characters.

& CMDS()
  Function: cmds(<player>)
  
  Example:
    > say cmds(me)
    You say "100"
    > say cmds(me)
    You say "101"
  
  Returns the number of commands entered by a connected 'player'.
  This function returns -1 if the enactor has insufficient permission
  (i.e., not self and no Wizard_Who power).

& LCMDS()
  Function: lcmds(<object>)

  Returns the attribute names of any commands on a specific <object>
  
  Example:
    > &CMD1 me=$command1:@pemit me=blah
    Set.
    > &CMD2 me=$command2:@pemit me=blah blah
    Set.
    > say lcmds(me)
    You say "command1 command2"
  
  See also: lattrcmds().

& STARTSECS()
  Function: startsecs()
  
  Returns the number of seconds that represents the time the MUX last
  rebooted. The time is measured in the same way as the secs()
  function. This is easier and more efficient than using
  convtime(starttime()).
  
  Example:
    > say startsecs()
    You say "959093815"
  
  See also: secs().

& LATTRCMDS()
  Function: lattrcmds(<object>)

  Returns the names of the attributes that contain commands on a
  specific <object>.
  
  Example:
    > &CMD1 me=$command1:@pemit me=blah
    Set.
    > &CMD2 me=$command2:@pemit me=blah blah
    Set.
    > say lcmds(me)
    You say "CMD1 CMD2"
  
  See also: lcmds().
  
& DIGITTIME()
  Function: digittime(<seconds>)
  
  This function converts a number of <seconds> to a digital time
  string and prepends the number of days if the time is greater than
  23:59.
  
  Example:
    > say digittime(2345)
    You say "00:39"
    > say digittime(123456)
    You say "1d 10:18"
  
  See also: writetime(), singletime(), exptime(), secs(), time().

& WRITETIME()
  Function: writetime(<seconds>)
  
  This function converts seconds to a number of time elements (hours,
  minutes, seconds) that is equivalent to the given number of
  <seconds>.
  
  This is very similar to the exptime() function, but the elements
  are given their long names instead of short names.
  
  Example:
    > say writetime(45)
    You say "45 seconds"
    > say writetime(12345)
    You say "3 hours 25 minutes 45 seconds"
    > say writetime(123456)
    You say "1 day 10 hours 17 minutes 36 seconds"
  
  See also: exptime(), singletime(), digittime(), secs(), time().
  
& EXPTIME()
  Function: exptime(<seconds>)
  
  This function converts seconds to a number of time elements (hours,
  minutes, seconds) that is equivalent to the given number of
  <seconds>.
  
  This is very similar to the writetime() function, but the elements
  are given their short names instead of long names.
  
  Example:
    > say exptime(45)
    You say "45s"
    > say exptime(12345)
    You say "3h 25m 45s"
    > say exptime(123456)
    You say "1d 10h 17m 36s"
  
  See also: writetime(), singletime(), digittime(), secs(), time().
  
& SINGLETIME()
  Function: singletime(<seconds>)
  
  This function converts seconds to a single time element which is
  the lowest approximation to the given number of <seconds>.
  
  Example:
    > say singletime(45)
    You say "45s"
    > say singletime(12345)
    You say "3h"
    > say singletime(123456)
    You say "1d"
  
  See also: writetime(), exptime(), digittime(), secs(), time().

& LFLAGS()
  Function lflags(<object>)
  
  Returns the flags of <object> written out with their actual names.
  
  Example:
    > say flags(me)
    You say "PXNWcis"
    > say lflags(me)
    You say "ANSI NOSPOOF WIZARD CONNECTED IMMORTAL SAFE"
  
  See also: flags(), type().
  
& CONNTOTAL()
  Function conntotal(<player>)
  
  Returns the number of seconds that <player> has been connected to
  the MUX. This also includes the current connection time.
  
  See also: connmax(), connlast(), connnum(), connleft(), secs(),
            conn().

& CONNMAX()
  Function connmax(<player>)
  
  Returns the longest connection time that <player> has been
  connected to the MUX -- perhaps even the current session.
  
  See also: conntotal(), connlast(), connnum(), connleft(), secs(),
            conn().

& CONNLAST()
  Function connlast(<player>)
  
  Returns the number of seconds that <player>'s last connection to
  the MUX was.
  
  See also: conntotal(), connmax(), connnum(), connleft(), secs(),
            conn().
  
& CONNNUM()
  Function connnum(<player>)
  
  Returns the number connections that <player> has had to the MUX
  including the current connection.
  
  See also: conntotal(), connmax(), connlast(), connleft(), secs(),
            conn().
  
& CONNLEFT()
  Function connleft(<player>)
  
  Returns the time stamp (number of seconds elapsed since midnight,
  January 1, 1970) that represents when the <player> last
  disconnected from the MUX.
  
  See also: conntotal(), connmax(), connlast(), connnum(), secs(),
            conn().
