/*! \file stringutil.cpp
 * \brief String utility functions.
 *
 * $Id$
 *
 */

#include "copyright.h"
#include "autoconf.h"
#include "config.h"
#include "externs.h"

#include "ansi.h"
#include "pcre.h"

const bool mux_isprint_ascii[256] =
{
//  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
//
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 0
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 1
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 2
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 3
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 4
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 5
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 6
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,  // 7

    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 8
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 9
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // A
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // B
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // C
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // D
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // E
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0   // F
};

const bool mux_isprint_latin1[256] =
{
//  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
//
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 0
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 1
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 2
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 3
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 4
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 5
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 6
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,  // 7

    0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0,  // 8
    0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1,  // 9
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // A
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // B
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // C
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // D
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // E
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1   // F
};

const bool mux_isdigit[256] =
{
//  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
//
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 0
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 1
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 2
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,  // 3
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 4
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 5
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 6
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 7

    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 8
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 9
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // A
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // B
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // C
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // D
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // E
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0   // F
};

const bool mux_isxdigit[256] =
{
//  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
//
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 0
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 1
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 2
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,  // 3
    0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 4
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 5
    0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 6
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 7

    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 8
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 9
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // A
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // B
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // C
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // D
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // E
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0   // F
};

const bool mux_isazAZ[256] =
{
//  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
//
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 0
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 1
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 2
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 3
    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 4
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,  // 5
    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 6
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,  // 7

    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 8
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 9
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // A
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // B
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // C
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // D
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // E
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0   // F
};

const bool mux_isalpha[256] =
{
//  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
//
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 0
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 1
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 2
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 3
    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 4
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,  // 5
    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 6
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,  // 7

    0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0,  // 8
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1,  // 9
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,  // A
    0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,  // B
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // C
    1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1,  // D
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // E
    1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0   // F
};

const bool mux_isalnum[256] =
{
//  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
//
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 0
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 1
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 2
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,  // 3
    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 4
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,  // 5
    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 6
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,  // 7

    0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0,  // 8
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1,  // 9
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,  // A
    0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,  // B
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // C
    1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1,  // D
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // E
    1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0   // F
};

const bool mux_isupper_latin1[256] =
{
//  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
//
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 0
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 1
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 2
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 3
    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 4
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,  // 5
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 6
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 7

    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0,  // 8
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,  // 9
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // A
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // B
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // C
    1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0,  // D
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // E
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0   // F
};

const bool mux_islower_latin1[256] =
{
//  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
//
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 0
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 1
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 2
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 3
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 4
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 5
    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 6
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,  // 7

    0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 8
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0,  // 9
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,  // A
    0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,  // B
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // C
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,  // D
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // E
    1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0   // F
};

const bool mux_isspace[256] =
{
//  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
//
    0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0,  // 0
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 1
    1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 2
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 3
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 4
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 5
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 6
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 7

    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 8
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 9
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // A
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // B
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // C
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // D
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // E
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0   // F
};

// The first character of an attribute name must be either alphabetic,
// '_', '#', '.', or '~'. It's handled by the following table.
//
// Characters thereafter may be letters, numbers, and characters from
// the set {'?!`/-_.@#$^&~=+<>()}. Lower-case letters are turned into
// uppercase before being used, but lower-case letters are valid input.
//
bool mux_AttrNameInitialSet_latin1[256] =
{
//  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
//
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 0
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 1
    0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,  // 2
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 3
    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 4
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1,  // 5
    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 6
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0,  // 7

    0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0,  // 8
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1,  // 9
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,  // A
    0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,  // B
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // C
    1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1,  // D
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // E
    1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0   // F
};

// Valid characters for an object name are all printable
// characters except those from the set {=&|}.
//
const bool mux_ObjectNameSet[256] =
{
//  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
//
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 0
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 1
    1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 2
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1,  // 3
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 4
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 5
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 6
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0,  // 7

    0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0,  // 8
    0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1,  // 9
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // A
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // B
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // C
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // D
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // E
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0   // F
};

// Valid characters for a player name are all alphanumeric plus
// {`$_-.,'} plus SPACE depending on configuration.
//
bool mux_PlayerNameSet[256] =
{
//  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
//
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 0
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 1
    1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0,  // 2
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,  // 3
    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 4
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1,  // 5
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 6
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,  // 7

    0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0,  // 8
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1,  // 9
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,  // A
    0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,  // B
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // C
    1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1,  // D
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // E
    1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0   // F
};

// Characters which should be escaped for the secure()
// function: '%$\[](){},;'.
//
const bool mux_issecure[256] =
{
//  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
//
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 0
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 1
    0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0,  // 2
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,  // 3
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 4
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0,  // 5
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 6
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0,  // 7

    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 8
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 9
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // A
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // B
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // C
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // D
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // E
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0   // F
};

// Characters which should be escaped for the escape()
// function: '%\[]{};,()^$'.
//
const bool mux_isescape[256] =
{
//  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
//
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 0
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 1
    0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0,  // 2
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,  // 3
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 4
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0,  // 5
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 6
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0,  // 7

    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 8
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 9
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // A
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // B
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // C
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // D
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // E
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0   // F
};

const bool ANSI_TokenTerminatorTable[256] =
{
//  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
//
    1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 0
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 1
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 2
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 3
    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 4
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,  // 5
    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 6
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,  // 7

    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 8
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 9
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // A
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // B
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // C
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // D
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // E
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0   // F
};

const unsigned char mux_hex2dec[256] =
{
//  0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
//
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // 0
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // 1
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // 2
    0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  0,  0,  0,  0,  0,  0,  // 3
    0, 10, 11, 12, 13, 14, 15,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // 4
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // 5
    0, 10, 11, 12, 13, 14, 15,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // 6
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // 7

    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // 8
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // A
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // B
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // C
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // D
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // E
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0   // F
};

const unsigned char mux_toupper_ascii[SCHAR_MAX+1] =
{
//   0     1     2     3     4     5     6     7     8     9     A     B     C     D     E     F
//
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, // 0
    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, // 1
    0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, // 2
    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, // 3
    0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, // 4
    0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F, // 5
    0x60, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, // 6
    0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F, // 7
};

const unsigned char mux_toupper_latin1[UCHAR_MAX+1] =
{
//   0     1     2     3     4     5     6     7     8     9     A     B     C     D     E     F
//
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, // 0
    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, // 1
    0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, // 2
    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, // 3
    0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, // 4
    0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F, // 5
    0x60, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, // 6
    0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F, // 7

    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F, // 8
    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x8A, 0x9B, 0x8C, 0x9D, 0x8E, 0x9F, // 9
    0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF, // A
    0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF, // B
    0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, // C
    0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF, // D
    0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, // E
    0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xF7, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xFF  // F
};

const unsigned char mux_tolower_ascii[SCHAR_MAX+1] =
{
//   0     1     2     3     4     5     6     7     8     9     A     B     C     D     E     F
//
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, // 0
    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, // 1
    0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, // 2
    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, // 3
    0x40, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, // 4
    0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F, // 5
    0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, // 6
    0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F, // 7
};

const unsigned char mux_tolower_latin1[UCHAR_MAX+1] =
{
//   0     1     2     3     4     5     6     7     8     9     A     B     C     D     E     F
//
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, // 0
    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, // 1
    0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, // 2
    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, // 3
    0x40, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, // 4
    0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F, // 5
    0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, // 6
    0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F, // 7

    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x9A, 0x8B, 0x9C, 0x8D, 0x9E, 0x8F, // 8
    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0xFF, // 9
    0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF, // A
    0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF, // B
    0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, // C
    0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xD7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xDF, // D
    0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, // E
    0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF  // F
};

const unsigned char mux_StripAccents[256] =
{
//   0     1     2     3     4     5     6     7     8     9     A     B     C     D     E     F
//
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, // 0
    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, // 1
    0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, // 2
    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, // 3
    0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, // 4
    0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F, // 5
    0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, // 6
    0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F, // 7

    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F, // 8
    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F, // 9
    0xA0, 0x21, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0x22, 0xAC, 0xAD, 0xAE, 0xAF, // A
    0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0x22, 0xBC, 0xBD, 0xBE, 0x3F, // B
    0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0xC6, 0x43, 0x45, 0x45, 0x45, 0x45, 0x49, 0x49, 0x49, 0x49, // C
    0x44, 0x4E, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0xD7, 0x4F, 0x55, 0x55, 0x55, 0x55, 0x59, 0x50, 0x42, // D
    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0xE6, 0x63, 0x65, 0x65, 0x65, 0x65, 0x69, 0x69, 0x69, 0x69, // E
    0x6F, 0x6E, 0x6F, 0x6F, 0x6F, 0x6F, 0x6F, 0xF7, 0x6F, 0x75, 0x75, 0x75, 0x75, 0x79, 0x70, 0x79, // F
};

// This will help decode UTF-8 sequences.
//
// 0xxxxxxx ==> 00000000-01111111 ==> 00-7F 1 byte sequence.
// 10xxxxxx ==> 10000000-10111111 ==> 80-BF continue
// 110xxxxx ==> 11000000-11011111 ==> C0-DF 2 byte sequence.
// 1110xxxx ==> 11100000-11101111 ==> E0-EF 3 byte sequence.
// 11110xxx ==> 11110000-11110111 ==> F0-F7 4 byte sequence.
//              11111000-11111111 illegal
//
// Also, RFC 3629 specifies that 0xC0, 0xC1, and 0xF5-0xFF never
// appear in a valid sequence.
//
// The first byte gives the length of a sequence (UTF8_SIZE1 - UTF8_SIZE4).
// Bytes in the middle of a sequence map to UTF8_CONTINUE.  Bytes which should
// not appear map to UTF8_ILLEGAL.
//
const unsigned char utf8_FirstByte[256] =
{
//  0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
//
    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 0
    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 1
    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 2
    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 3
    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 4
    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 5
    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 6
    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 7

    5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  // 8
    5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  // 9
    5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  // A
    5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  // B
    6,  6,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  // C
    2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  // D
    3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  // E
    4,  4,  4,  4,  4,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6   // F
};

// The following table maps existing 8-bit characters to their corresponding
// UTF8 sequences.
//
const UTF8 *latin1_utf8[256] =
{
   T(""),             T("\x01"),         T("\x02"),         T("\x03"),
   T("\x04"),         T("\x05"),         T("\x06"),         T("\x07"),
   T("\x08"),         T("\x09"),         T("\x0A"),         T("\x0B"),
   T("\x0C"),         T("\x0D"),         T("\x0E"),         T("\x0F"),
   T("\x10"),         T("\x11"),         T("\x12"),         T("\x13"),
   T("\x14"),         T("\x15"),         T("\x16"),         T("\x17"),
   T("\x18"),         T("\x19"),         T("\x1A"),         T("\x1B"),
   T("\x1C"),         T("\x1D"),         T("\x1E"),         T("\x1F"),
   T("\x20"),         T("\x21"),         T("\x22"),         T("\x23"),
   T("\x24"),         T("\x25"),         T("\x26"),         T("\x27"),
   T("\x28"),         T("\x29"),         T("\x2A"),         T("\x2B"),
   T("\x2C"),         T("\x2D"),         T("\x2E"),         T("\x2F"),
   T("\x30"),         T("\x31"),         T("\x32"),         T("\x33"),
   T("\x34"),         T("\x35"),         T("\x36"),         T("\x37"),
   T("\x38"),         T("\x39"),         T("\x3A"),         T("\x3B"),
   T("\x3C"),         T("\x3D"),         T("\x3E"),         T("\x3F"),
   T("\x40"),         T("\x41"),         T("\x42"),         T("\x43"),
   T("\x44"),         T("\x45"),         T("\x46"),         T("\x47"),
   T("\x48"),         T("\x49"),         T("\x4A"),         T("\x4B"),
   T("\x4C"),         T("\x4D"),         T("\x4E"),         T("\x4F"),
   T("\x50"),         T("\x51"),         T("\x52"),         T("\x53"),
   T("\x54"),         T("\x55"),         T("\x56"),         T("\x57"),
   T("\x58"),         T("\x59"),         T("\x5A"),         T("\x5B"),
   T("\x5C"),         T("\x5D"),         T("\x5E"),         T("\x5F"),
   T("\x60"),         T("\x61"),         T("\x62"),         T("\x63"),
   T("\x64"),         T("\x65"),         T("\x66"),         T("\x67"),
   T("\x68"),         T("\x69"),         T("\x6A"),         T("\x6B"),
   T("\x6C"),         T("\x6D"),         T("\x6E"),         T("\x6F"),
   T("\x70"),         T("\x71"),         T("\x72"),         T("\x73"),
   T("\x74"),         T("\x75"),         T("\x76"),         T("\x77"),
   T("\x78"),         T("\x79"),         T("\x7A"),         T("\x7B"),
   T("\x7C"),         T("\x7D"),         T("\x7E"),         T("\x7F"),
   T("\xE2\x82\xAC"), T("\xEF\xBF\xBD"), T("\xE2\x80\x9A"), T("\xC6\x92"),
   T("\xE2\x80\x9E"), T("\xE2\x80\xA6"), T("\xE2\x80\xA0"), T("\xE2\x80\xA1"),
   T("\xCB\x86"),     T("\xE2\x80\xB0"), T("\xC5\xA0"),     T("\xE2\x80\xB9"),
   T("\xC5\x92"),     T("\xEF\xBF\xBD"), T("\xC5\xBD"),     T("\xEF\xBF\xBD"),
   T("\xEF\xBF\xBD"), T("\xE2\x80\x98"), T("\xE2\x80\x99"), T("\xE2\x80\x9C"),
   T("\xE2\x80\x9D"), T("\xE2\x80\xA2"), T("\xE2\x80\x93"), T("\xE2\x80\x94"),
   T("\xCB\x9C"),     T("\xE2\x84\xA2"), T("\xC5\xA1"),     T("\xE2\x80\xBA"),
   T("\xC5\x93"),     T("\xEF\xBF\xBD"), T("\xC5\xBE"),     T("\xC5\xB8"),
   T("\xC2\xA0"),     T("\xC2\xA1"),     T("\xC2\xA2"),     T("\xC2\xA3"),
   T("\xC2\xA4"),     T("\xC2\xA5"),     T("\xC2\xA6"),     T("\xC2\xA7"),
   T("\xC2\xA8"),     T("\xC2\xA9"),     T("\xC2\xAA"),     T("\xC2\xAB"),
   T("\xC2\xAC"),     T("\xC2\xAD"),     T("\xC2\xAE"),     T("\xC2\xAF"),
   T("\xC2\xB0"),     T("\xC2\xB1"),     T("\xC2\xB2"),     T("\xC2\xB3"),
   T("\xC2\xB4"),     T("\xC2\xB5"),     T("\xC2\xB6"),     T("\xC2\xB7"),
   T("\xC2\xB8"),     T("\xC2\xB9"),     T("\xC2\xBA"),     T("\xC2\xBB"),
   T("\xC2\xBC"),     T("\xC2\xBD"),     T("\xC2\xBE"),     T("\xC2\xBF"),
   T("\xC3\x80"),     T("\xC3\x81"),     T("\xC3\x82"),     T("\xC3\x83"),
   T("\xC3\x84"),     T("\xC3\x85"),     T("\xC3\x86"),     T("\xC3\x87"),
   T("\xC3\x88"),     T("\xC3\x89"),     T("\xC3\x8A"),     T("\xC3\x8B"),
   T("\xC3\x8C"),     T("\xC3\x8D"),     T("\xC3\x8E"),     T("\xC3\x8F"),
   T("\xC3\x90"),     T("\xC3\x91"),     T("\xC3\x92"),     T("\xC3\x93"),
   T("\xC3\x94"),     T("\xC3\x95"),     T("\xC3\x96"),     T("\xC3\x97"),
   T("\xC3\x98"),     T("\xC3\x99"),     T("\xC3\x9A"),     T("\xC3\x9B"),
   T("\xC3\x9C"),     T("\xC3\x9D"),     T("\xC3\x9E"),     T("\xC3\x9F"),
   T("\xC3\xA0"),     T("\xC3\xA1"),     T("\xC3\xA2"),     T("\xC3\xA3"),
   T("\xC3\xA4"),     T("\xC3\xA5"),     T("\xC3\xA6"),     T("\xC3\xA7"),
   T("\xC3\xA8"),     T("\xC3\xA9"),     T("\xC3\xAA"),     T("\xC3\xAB"),
   T("\xC3\xAC"),     T("\xC3\xAD"),     T("\xC3\xAE"),     T("\xC3\xAF"),
   T("\xC3\xB0"),     T("\xC3\xB1"),     T("\xC3\xB2"),     T("\xC3\xB3"),
   T("\xC3\xB4"),     T("\xC3\xB5"),     T("\xC3\xB6"),     T("\xC3\xB7"),
   T("\xC3\xB8"),     T("\xC3\xB9"),     T("\xC3\xBA"),     T("\xC3\xBB"),
   T("\xC3\xBC"),     T("\xC3\xBD"),     T("\xC3\xBE"),     T("\xC3\xBF"),
};

// utf/cl_Printable.txt
//
// 95007 included, 1019105 excluded, 0 errors.
// 149 states, 98 columns, 14858 bytes
//
const unsigned char cl_print_itt[256] =
{
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
       1,   1,   1,   1,   1,   1,   1,   1,    1,   1,   1,   1,   1,   1,   1,   1,
       1,   1,   1,   1,   1,   1,   1,   1,    1,   1,   1,   1,   1,   1,   1,   1,
       1,   1,   1,   1,   1,   1,   1,   1,    1,   1,   1,   1,   1,   1,   1,   1,
       1,   1,   1,   1,   1,   1,   1,   1,    1,   1,   1,   1,   1,   1,   1,   1,
       1,   1,   1,   1,   1,   1,   1,   1,    1,   1,   1,   1,   1,   1,   1,   1,
       1,   1,   1,   1,   1,   1,   1,   1,    1,   1,   1,   1,   1,   1,   1,   0,

       2,   3,   4,   5,   6,   7,   8,   9,   10,  11,  12,  13,  14,  15,  16,  17,
      18,  19,  20,  21,  22,  23,  24,  25,   26,  27,  28,  29,  30,  31,  32,  33,
      34,  35,  36,  37,  38,  39,  40,  41,   42,  43,  44,  45,  46,  47,  48,  49,
      50,  51,  52,  53,  54,  55,  56,  57,   58,  59,  60,  61,  62,  63,  64,  65,
       0,   0,  66,  67,  67,  67,  67,  67,   68,  69,  70,  71,  67,  72,  73,  74,
      67,  67,  75,  76,  77,  78,  79,  80,   81,  82,  67,  83,  84,  85,  86,   0,
      87,  88,  89,  90,  91,  92,  92,  92,   92,  93,  94,  92,  92,  95,   0,  96,
      97,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0

};

const unsigned char cl_print_stt[149][98] =
{
    { 149, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,  14,  15,  16,  17,  18,  19,  20,  21,  22,  50,  78, 100, 109, 111, 112, 114, 117, 119, 130},
    { 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 150, 150, 149, 149, 149, 149, 150, 149, 149, 149, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 149, 149, 149, 149, 150, 150, 150, 150, 150, 150, 150, 149, 150, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 150, 150, 150, 150, 150, 150, 150, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 149, 150, 150, 149, 149, 149, 149, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 150, 149, 149, 149, 150, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149,  23,  24,  25,  26,  27,  28,  29,  30,  31,  32,  33,  34,  35,  36,  37,  38,  39,  40,  41,  42,  43,  44,  45,  46,   2,  47,  48,  49, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 149, 150, 150, 150, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 150, 150, 150, 150, 150, 149, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 149, 150, 150, 150, 149, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 150, 150, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 150, 150, 150, 150, 150, 150, 150, 149, 150, 149, 149, 149, 150, 150, 150, 150, 149, 149, 150, 149, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 149, 149, 150, 150, 149, 149, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 150, 149, 149, 149, 149, 150, 150, 149, 150, 150, 150, 150, 150, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 149, 149, 150, 149, 149, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 150, 150, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 150, 150, 150, 150, 150, 150, 150, 149, 150, 150, 149, 150, 150, 149, 150, 150, 149, 149, 150, 149, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 149, 149, 149, 149, 150, 150, 149, 149, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 150, 150, 150, 150, 149, 150, 149, 149, 149, 149, 149, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 149, 150, 150, 150, 149, 150, 150, 150, 150, 150, 150, 150, 149, 150, 149, 150, 150, 150, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 150, 150, 150, 150, 150, 150, 150, 149, 150, 150, 149, 150, 150, 150, 150, 150, 149, 149, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 149, 150, 150, 150, 149, 150, 150, 150, 149, 149, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 150, 149, 149, 149, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 149, 150, 150, 150, 149, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 150, 150, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 150, 150, 150, 150, 150, 150, 150, 149, 150, 150, 149, 149, 150, 150, 150, 150, 149, 149, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 149, 149, 149, 150, 150, 149, 149, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 150, 150, 149, 149, 149, 149, 150, 150, 149, 150, 150, 150, 149, 149, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 149, 149, 150, 150, 149, 150, 150, 150, 150, 150, 150, 149, 149, 149, 150, 150, 150, 149, 150, 150, 150, 150, 149, 149, 149, 150, 150, 149, 150, 149, 150, 150, 149, 149, 149, 150, 150, 149, 149, 149, 150, 150, 150, 149, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 149, 150, 150, 150, 149, 149, 149, 149, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 149, 149, 149, 150, 150, 150, 149, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 149, 150, 150, 150, 149, 150, 150, 150, 150, 150, 150, 150, 150, 149, 150, 150, 150, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 150, 150, 150, 150, 150, 149, 149, 149, 149, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 149, 150, 150, 150, 149, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 150, 150, 149, 149, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 149, 149, 150, 150, 149, 150, 150, 150, 150, 150, 150, 150, 150, 149, 150, 150, 150, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 150, 150, 150, 150, 150, 149, 149, 149, 149, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 149, 150, 150, 150, 149, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 150, 150, 149, 149, 149, 149, 149, 149, 149, 150, 149, 150, 150, 149, 149, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 149, 149, 150, 150, 149, 150, 150, 150, 150, 150, 150, 150, 150, 149, 150, 150, 150, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 149, 149, 150, 150, 150, 149, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 150, 149, 149, 149, 149, 149, 149, 149, 149, 150, 150, 149, 149, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 149, 149, 150, 150, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 150, 149, 149, 149, 149, 150, 150, 150, 150, 150, 150, 149, 150, 149, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 149, 150, 150, 149, 150, 149, 149, 150, 150, 149, 150, 149, 149, 150, 149, 149, 149, 149, 149, 149, 150, 150, 150, 150, 149, 150, 150, 150, 150, 150, 150, 150, 149, 150, 150, 150, 149, 150, 149, 150, 149, 149, 150, 150, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 149, 150, 149, 150, 150, 150, 150, 150, 150, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149,  51,  52,   1,  53,   2,  54,  55,  56,  10,  57,  58,  59,  60,  61,   1,  62,  63,   2,   2,   2,   2,   2,   2,   2,   2,  64,  65,  66,  67,  68,   2,  69,  70,  71,  72, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149,   2,   2,  73,  56,  74,  75,  76,  77, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 150, 150, 150, 150, 150, 149, 150, 150, 149, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 149, 150, 149, 150, 150, 150, 150, 149, 149, 150, 150, 150, 150, 150, 150, 150, 149, 150, 149, 150, 150, 150, 150, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 149, 150, 149, 150, 150, 150, 150, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 150, 149, 150, 150, 150, 150, 149, 149, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 149, 150, 150, 150, 150, 149, 149, 150, 150, 150, 150, 150, 150, 150, 149, 150, 150, 150, 150, 150, 150, 150, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 150, 149, 150, 150, 150, 150, 149, 149, 150, 150, 150, 150, 150, 150, 150, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 150, 150, 150, 149, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 150, 150, 150, 150, 150, 150, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 149, 149, 150, 150, 150, 150, 150, 150, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 149, 150, 149, 150, 149, 150, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 150, 150, 150, 150, 150, 150, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 150, 150, 150, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149,  79,  80,  81,  82,  83,  84,  85,   2,   2,   2,   2,   2,   2,   2,   2,  86,  87,  88,   2,  89,   2,   2,   2,   2,  90,  91,  92, 149,  93,  94,  95,  96,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149,  97,  98,   2,   2,   2,  99, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 150, 149, 149, 149, 149, 149, 149, 149, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 150, 150, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 150, 150, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 149, 150, 150, 150, 150, 149, 150, 150, 150, 150, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 150, 149, 150, 150, 150, 150, 149, 149, 149, 150, 149, 150, 150, 150, 150, 150, 150, 150, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149,   2,  63, 101,   2, 102,   2, 103, 104,  65, 105,   2, 106,   2, 107,   2, 108,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 149, 149, 149, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2, 110, 149,   2,   2,   2,   2,   2,   2,   2,   2, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2, 113, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2, 115, 116, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2, 118, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149,   2,   2,   2,   2,   5, 120, 149, 149, 121, 122,  21, 123,   2,   2,   2,   2,   2,   4, 124, 125, 126, 127,   2, 128,  63,   2,  89, 129, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 150, 150, 150, 150, 150, 149, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 149, 150, 150, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 150, 150, 150, 150, 149, 149, 149, 149, 150, 150, 150, 150, 150, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 149, 149, 150, 150, 150, 150, 150, 150, 149, 149, 150, 150, 150, 150, 150, 150, 149, 149, 150, 150, 150, 150, 150, 150, 149, 149, 150, 150, 150, 149, 149, 149, 150, 150, 150, 150, 150, 150, 150, 149, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 131, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 135, 149, 149, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 146, 149, 149, 149, 149, 148, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 132,  20, 149, 149, 133, 134, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149,   2,   2,   2, 110, 136, 137,   2, 138, 149, 149, 149, 149, 149, 149, 149, 149,   2, 139, 140, 141, 142, 143,   2,   2,   2,   2, 144,   2,   2,   2,   2, 145, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 150, 150, 149, 149, 150, 149, 149, 150, 150, 149, 149, 150, 150, 150, 150, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 150, 149, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 149, 150, 150, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 149, 150, 150, 150, 150, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 149, 150, 150, 150, 150, 150, 150, 150, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 149, 150, 149, 149, 149, 150, 150, 150, 150, 150, 150, 150, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2, 147, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149},
    { 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149,   2,   2,   2,   2,   2,   2,   2,   2, 138, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149}
};


// 129 included, 1113983 excluded, 0 errors.
// 5 states, 10 columns, 306 bytes
//
const unsigned char cl_attrnameinitial_itt[256] =
{
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   1,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   1,   0,
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
       0,   1,   1,   1,   1,   1,   1,   1,    1,   1,   1,   1,   1,   1,   1,   1,
       1,   1,   1,   1,   1,   1,   1,   1,    1,   1,   1,   0,   0,   0,   0,   1,
       0,   1,   1,   1,   1,   1,   1,   1,    1,   1,   1,   1,   1,   1,   1,   1,
       1,   1,   1,   1,   1,   1,   1,   1,    1,   1,   1,   0,   0,   0,   1,   0,

       2,   2,   2,   2,   2,   2,   2,   2,    2,   2,   2,   2,   2,   2,   2,   2,
       2,   2,   3,   4,   2,   2,   2,   0,    2,   2,   2,   2,   2,   2,   2,   2,
       4,   4,   2,   2,   2,   2,   2,   2,    2,   2,   5,   2,   2,   2,   2,   2,
       2,   2,   2,   2,   2,   5,   2,   0,    4,   2,   5,   2,   2,   4,   4,   2,
       0,   0,   6,   7,   0,   8,   9,   0,    0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0

};

const unsigned char cl_attrnameinitial_stt[5][10] =
{
    {   5,   6,   5,   5,   5,   5,   1,   2,   3,   4},
    {   5,   5,   5,   5,   5,   6,   5,   5,   5,   5},
    {   5,   5,   6,   6,   6,   6,   5,   5,   5,   5},
    {   5,   5,   5,   6,   6,   5,   5,   5,   5,   5},
    {   5,   5,   5,   6,   5,   5,   5,   5,   5,   5}
};

// 155 included, 1113957 excluded, 0 errors.
// 5 states, 10 columns, 306 bytes
//
const unsigned char cl_attrname_itt[256] =
{
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
       0,   1,   0,   1,   1,   0,   1,   1,    1,   1,   0,   1,   0,   1,   1,   1,
       1,   1,   1,   1,   1,   1,   1,   1,    1,   1,   0,   0,   1,   1,   1,   1,
       1,   1,   1,   1,   1,   1,   1,   1,    1,   1,   1,   1,   1,   1,   1,   1,
       1,   1,   1,   1,   1,   1,   1,   1,    1,   1,   1,   0,   0,   0,   1,   1,
       1,   1,   1,   1,   1,   1,   1,   1,    1,   1,   1,   1,   1,   1,   1,   1,
       1,   1,   1,   1,   1,   1,   1,   1,    1,   1,   1,   0,   0,   0,   1,   0,

       2,   2,   2,   2,   2,   2,   2,   2,    2,   2,   2,   2,   2,   2,   2,   2,
       2,   2,   3,   4,   2,   2,   2,   0,    2,   2,   2,   2,   2,   2,   2,   2,
       4,   4,   2,   2,   2,   2,   2,   2,    2,   2,   5,   2,   2,   2,   2,   2,
       2,   2,   2,   2,   2,   5,   2,   0,    4,   2,   5,   2,   2,   4,   4,   2,
       0,   0,   6,   7,   0,   8,   9,   0,    0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0

};

const unsigned char cl_attrname_stt[5][10] =
{
    {   5,   6,   5,   5,   5,   5,   1,   2,   3,   4},
    {   5,   5,   5,   5,   5,   6,   5,   5,   5,   5},
    {   5,   5,   6,   6,   6,   6,   5,   5,   5,   5},
    {   5,   5,   5,   6,   6,   5,   5,   5,   5,   5},
    {   5,   5,   5,   6,   5,   5,   5,   5,   5,   5}
};

// utf/cl_Upper.txt
//
// 56 included, 1114056 excluded, 0 errors.
// 2 states, 4 columns, 264 bytes
//
const unsigned char cl_upper_itt[256] =
{
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
       0,   1,   1,   1,   1,   1,   1,   1,    1,   1,   1,   1,   1,   1,   1,   1,
       1,   1,   1,   1,   1,   1,   1,   1,    1,   1,   1,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,

       2,   2,   2,   2,   2,   2,   2,   2,    2,   2,   2,   2,   2,   2,   2,   2,
       2,   2,   2,   2,   2,   2,   2,   0,    2,   2,   2,   2,   2,   2,   2,   0,
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   3,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0

};

const unsigned char cl_upper_stt[2][4] =
{
    {   2,   3,   2,   1},
    {   2,   2,   3,   2}
};

// utf/cl_Lower.txt
//
// 58 included, 1114054 excluded, 0 errors.
// 2 states, 4 columns, 264 bytes
//
const unsigned char cl_lower_itt[256] =
{
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
       0,   1,   1,   1,   1,   1,   1,   1,    1,   1,   1,   1,   1,   1,   1,   1,
       1,   1,   1,   1,   1,   1,   1,   1,    1,   1,   1,   0,   0,   0,   0,   0,

       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   2,
       2,   2,   2,   2,   2,   2,   2,   2,    2,   2,   2,   2,   2,   2,   2,   2,
       2,   2,   2,   2,   2,   2,   2,   0,    2,   2,   2,   2,   2,   2,   2,   2,
       0,   0,   0,   3,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0

};

const unsigned char cl_lower_stt[2][4] =
{
    {   2,   3,   2,   1},
    {   2,   2,   3,   2}
};

// utf/tr_utf8_latin1.txt
//
// 1503 code points.
// 71 states, 190 columns, 27236 bytes
//
const unsigned char tr_latin1_itt[256] =
{
       0,   0,   0,   0,   0,   0,   0,   1,    2,   3,   4,   0,   0,   5,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   6,   0,   0,   0,   0,
       7,   8,   9,  10,  11,  12,  13,  14,   15,  16,  17,  18,  19,  20,  21,  22,
      23,  24,  25,  26,  27,  28,  29,  30,   31,  32,  33,  34,  35,  36,  37,   0,
      38,  39,  40,  41,  42,  43,  44,  45,   46,  47,  48,  49,  50,  51,  52,  53,
      54,  55,  56,  57,  58,  59,  60,  61,   62,  63,  64,  65,  66,  67,  68,  69,
      70,  71,  72,  73,  74,  75,  76,  77,   78,  79,  80,  81,  82,  83,  84,  85,
      86,  87,  88,  89,  90,  91,  92,  93,   94,  95,  96,  97,  98,  99, 100,   0,

     101, 102, 103, 104, 105, 106, 107, 108,  109, 110, 111, 112, 113, 114, 115, 116,
     117, 118, 119, 120, 121, 122, 123, 124,  125, 126, 127, 128, 129, 130, 131, 132,
     133, 134, 135, 136, 137, 138, 139, 140,  141, 142, 143, 144, 145, 146, 147, 148,
     149, 150, 151, 152, 153, 154, 155, 156,  157, 158, 159, 160, 161, 162, 163, 164,
       0,   0, 165, 166, 167, 168, 169, 170,  171, 172, 173, 174,   0,   0,   0,   0,
     175, 176, 177, 178,   0, 179, 180,   0,    0, 181,   0, 182,   0,   0,   0, 183,
     184, 185, 186,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0, 187,
     188,   0,   0, 189,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0

};

const unsigned short tr_latin1_stt[71][190] =
{
    { 134,  78,  79,  80,  81,  84,  98, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,  14,  15,  16,  17,  18,  19,  20,  23,  34,  53,  59,  67},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 136, 168, 136, 168, 136, 168, 138, 170, 138, 170, 138, 170, 138, 170, 139, 171, 139, 171, 140, 172, 140, 172, 140, 172, 140, 172, 140, 172, 142, 174, 142, 174, 142, 174, 142, 174, 143, 175, 143, 175, 144, 176, 144, 176, 144, 176, 144, 176, 144, 134, 134, 134, 145, 177, 146, 178, 134, 147, 179, 147, 179, 147, 179, 147, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 179, 147, 179, 149, 181, 149, 181, 149, 181, 181, 134, 134, 150, 182, 150, 182, 150, 182, 134, 134, 153, 185, 153, 185, 153, 185, 154, 186, 154, 186, 154, 186, 154, 186, 155, 187, 155, 187, 155, 187, 156, 188, 156, 188, 156, 188, 156, 188, 156, 188, 156, 188, 158, 190, 160, 192, 326, 161, 193, 161, 193, 193, 193, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 169, 137, 137, 169, 134, 134, 134, 138, 170, 134, 139, 139, 171, 134, 134, 134, 134, 141, 202, 142, 134, 134, 134, 144, 146, 178, 179, 134, 134, 149, 181, 150, 150, 182, 134, 134, 151, 183, 134, 134, 134, 134, 134, 187, 155, 187, 155, 156, 188, 134, 157, 160, 192, 161, 193, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 104, 134, 134, 134, 134, 134, 134, 134, 134, 134, 136, 168, 144, 176, 150, 182, 156, 188, 156, 188, 156, 188, 156, 188, 156, 188, 134, 136, 168, 136, 168, 134, 301, 142, 174, 142, 174, 146, 178, 150, 182, 150, 182, 134, 134, 177, 134, 134, 134, 142, 174, 134, 134, 149, 181, 136, 168, 134, 301, 150, 182, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 136, 168, 136, 168, 140, 172, 140, 172, 144, 176, 144, 176, 150, 182, 150, 182, 153, 185, 153, 185, 156, 188, 156, 188, 154, 186, 155, 187, 134, 134, 143, 175, 149, 171, 134, 134, 161, 193, 136, 168, 140, 172, 150, 182, 150, 182, 150, 182, 150, 182, 160, 192, 179, 181, 187, 134, 134, 134, 136, 138, 170, 147, 155, 186, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 193, 134, 134, 137, 156, 134, 140, 172, 145, 177, 134, 184, 153, 185, 160, 192, 134, 134, 134, 169, 134, 170, 171, 171, 134, 134, 134, 134, 134, 134, 134, 134, 174, 134, 134, 134, 134, 134, 175, 134, 176, 134, 134, 179, 179, 179, 179, 134, 134, 180, 181, 181, 134, 134, 134, 134, 134, 134, 134, 134, 185, 185, 185, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 186, 134, 134, 134, 134, 134, 187, 188, 134, 189, 134, 134, 134, 134, 193, 193, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 177, 134, 134, 184, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 207, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 223, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 140, 134, 144, 134, 134, 134, 134, 134, 134, 144, 134, 134, 136, 134, 134, 134, 134, 134, 134, 134, 144, 134, 134, 134, 134, 134, 150, 134, 134, 134, 134, 156, 134, 134, 134, 134, 134, 134, 134, 134, 134, 140, 134, 134, 168, 134, 134, 134, 134, 134, 134, 134, 176, 134, 134, 134, 134, 134, 182, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 188, 134, 134, 134, 134, 134, 134, 134, 134, 134, 172, 134, 134, 134, 134, 134, 134, 172, 134, 176, 134, 134, 134, 134, 134, 134, 176, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 150, 182, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 143, 175, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 136, 168, 136, 168, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 144, 176, 144, 176, 150, 182, 134, 134, 134, 134, 140, 172, 156, 188, 156, 188, 156, 188, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 104, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 116, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 104, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134,  21, 134,  21, 134,  21, 134,  21, 134,  21, 134,  21, 134,  21, 134,  21, 134,  21, 134, 134, 134,  22, 134,  22,  17, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134,  24, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134,  25, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134,  17,  26, 134, 134, 134, 134,  27, 134,  22, 134, 134, 134, 134, 134,  22, 134, 134, 134, 134, 134, 134, 134,  28,  29, 134,  30,  31,  32,  33, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 120, 121, 122, 123, 124, 125, 126, 127, 128, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 244, 134, 134, 134, 134, 134, 134, 134, 134, 134, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 104, 134, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 176, 185, 188, 189, 134, 134, 134, 134, 134, 134, 169, 171, 173, 180, 181, 183, 185, 185, 186, 187, 193, 134, 134, 134, 134, 144, 134, 183, 156, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 169, 171, 173, 174, 178, 179, 180, 181, 183, 185, 186, 134, 189, 191, 193, 168, 134, 171, 172, 134, 134, 134, 176, 134, 134, 188, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 136, 168, 137, 169, 137, 169, 137, 169, 138, 170, 139, 171, 139, 171, 139, 171, 139, 171, 139, 171, 140, 172, 140, 172, 140, 172, 140, 172, 140, 172, 141, 173, 142, 174, 143, 175, 143, 175, 143, 175, 143, 175, 143, 175, 144, 176, 144, 176, 146, 178, 146, 178, 146, 178, 147, 179, 147, 179, 147, 179, 147, 179, 148, 180, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 148, 180, 148, 180, 149, 181, 149, 181, 149, 181, 149, 181, 150, 182, 150, 182, 150, 182, 150, 182, 151, 183, 151, 183, 153, 185, 153, 185, 153, 185, 153, 185, 154, 186, 154, 186, 154, 186, 154, 186, 154, 186, 155, 187, 155, 187, 155, 187, 155, 187, 156, 188, 156, 188, 156, 188, 156, 188, 156, 188, 157, 189, 157, 189, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 158, 190, 158, 190, 158, 190, 158, 190, 158, 190, 159, 191, 159, 191, 160, 192, 161, 193, 161, 193, 161, 193, 175, 187, 190, 192, 168, 134, 134, 134, 134, 134, 136, 168, 136, 168, 136, 168, 136, 168, 136, 168, 136, 168, 136, 168, 136, 168, 136, 168, 136, 168, 136, 168, 136, 168, 140, 172, 140, 172, 140, 172, 140, 172, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 140, 172, 140, 172, 140, 172, 140, 172, 144, 176, 144, 176, 150, 182, 150, 182, 150, 182, 150, 182, 150, 182, 150, 182, 150, 182, 150, 182, 150, 182, 150, 182, 150, 182, 150, 182, 156, 188, 156, 188, 156, 188, 156, 188, 156, 188, 156, 188, 156, 188, 160, 192, 160, 192, 160, 192, 160, 192, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134,  35,  36,  37, 134,  38, 134, 134, 134,  39, 134,  40, 134,  41, 134, 134, 134, 134,  42,  43,  44, 134, 134, 134, 134, 134, 134, 134, 134,  45,  46,  47, 134, 134, 134, 134, 134, 134, 134, 134, 134,  48, 134, 134,  49, 134, 134, 134, 134,  50,  51,  52, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 116, 116, 134, 221, 222, 134, 134, 134, 216, 217, 201, 201, 218, 219, 203, 203, 205, 206, 220, 134, 134, 134, 204, 134, 134, 134, 134, 134, 134, 134, 134, 134, 208, 134, 134, 134, 134, 134, 134, 134, 134, 210, 226, 134, 104, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 116, 134, 134, 134, 134, 104, 134, 134, 134, 134, 134, 134, 134, 134, 134, 116, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 119, 176, 134, 134, 123, 124, 125, 126, 127, 128, 134, 244, 134, 134, 134, 181, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 134, 244, 134, 134, 134, 134, 168, 172, 182, 191, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 199, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 224, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 116, 134, 134, 118, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 113, 134, 134, 134, 134, 134, 134, 134, 134, 116, 134, 118, 134, 134, 134, 134, 134, 134, 116, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 243, 134, 134, 134, 134, 134, 134, 134, 134, 243, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 120, 121, 122, 123, 124, 125, 126, 127, 128, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 120, 121, 122, 123, 124, 125, 126, 127, 128, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 120, 121, 122, 123, 124, 125, 126, 127, 128, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 119, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 120, 121, 122, 123, 124, 125, 126, 127, 128, 134, 119, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 113, 113, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 104, 104, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 210, 226, 134, 134, 134, 134, 134, 134, 120, 121, 122, 123, 124, 125, 126, 127, 128, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 120, 121, 122, 123, 124, 125, 126, 127, 128, 134, 120, 121, 122, 123, 124, 125, 126, 127, 128, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 113, 113, 134, 134, 113, 113, 113, 113, 118, 134, 134, 113, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 113, 113, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 243, 243, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 144, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 176, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 147, 179, 147, 151, 153, 168, 187, 143, 175, 146, 178, 161, 193, 134, 134, 134, 134, 134, 134, 134, 189, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 150, 182, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134,  54,  55, 134, 134,  56,  57, 134,  58, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 104, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 104, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 116, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 104, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 116, 134, 134, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 134, 134, 134, 134, 134, 134, 134, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 233, 234, 243, 134, 237, 236, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134,  60, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134,  64, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134,  61,  62,  17, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134,  63, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 143, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 279, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 175, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 311, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 120, 121, 122, 123, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134,  65, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134,  66, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 120, 121, 122, 123, 124, 125, 126, 127, 128, 120, 121, 122, 123, 124, 125, 126, 127, 128, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134,  68, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134,  69,  70, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 104, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 116, 134, 134, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134},
    { 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 134, 134, 134, 134, 134, 134, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134}
};

// utf/tr_utf8_ascii.txt
//
// 1446 code points.
// 67 states, 190 columns, 12986 bytes
//
const unsigned char tr_ascii_itt[256] =
{
       0,   0,   0,   0,   0,   0,   0,   1,    2,   3,   4,   0,   0,   5,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   6,   0,   0,   0,   0,
       7,   8,   9,  10,  11,  12,  13,  14,   15,  16,  17,  18,  19,  20,  21,  22,
      23,  24,  25,  26,  27,  28,  29,  30,   31,  32,  33,  34,  35,  36,  37,   0,
      38,  39,  40,  41,  42,  43,  44,  45,   46,  47,  48,  49,  50,  51,  52,  53,
      54,  55,  56,  57,  58,  59,  60,  61,   62,  63,  64,  65,  66,  67,  68,  69,
      70,  71,  72,  73,  74,  75,  76,  77,   78,  79,  80,  81,  82,  83,  84,  85,
      86,  87,  88,  89,  90,  91,  92,  93,   94,  95,  96,  97,  98,  99, 100,   0,

     101, 102, 103, 104, 105, 106, 107, 108,  109, 110, 111, 112, 113, 114, 115, 116,
     117, 118, 119, 120, 121, 122, 123, 124,  125, 126, 127, 128, 129, 130, 131, 132,
     133, 134, 135, 136, 137, 138, 139, 140,  141, 142, 143, 144, 145, 146, 147, 148,
     149, 150, 151, 152, 153, 154, 155, 156,  157, 158, 159, 160, 161, 162, 163, 164,
       0,   0, 165, 166, 167, 168, 169, 170,  171, 172, 173, 174,   0,   0,   0,   0,
     175, 176, 177, 178,   0, 179, 180,   0,    0, 181,   0, 182,   0,   0,   0, 183,
     184, 185, 186,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0, 187,
     188,   0,   0, 189,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0

};

const unsigned char tr_ascii_stt[67][190] =
{
    { 130,  74,  75,  76,  77,  80,  94,  99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,  14,  15,  16,  17,  18,  19,  20,  23,  34,  51,  56,  63},
    { 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130,  99, 100, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 112, 130, 130, 130, 130, 117, 118, 130, 130, 130, 130, 130, 116, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130},
    { 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 132, 132, 132, 132, 132, 132, 130, 134, 136, 136, 136, 136, 140, 140, 140, 140, 130, 145, 146, 146, 146, 146, 146, 109, 146, 152, 152, 152, 152, 156, 130, 130, 164, 164, 164, 164, 164, 164, 130, 166, 168, 168, 168, 168, 172, 172, 172, 172, 130, 177, 178, 178, 178, 178, 178, 114, 178, 184, 184, 184, 184, 188, 130, 188, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130},
    { 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 132, 164, 132, 164, 132, 164, 134, 166, 134, 166, 134, 166, 134, 166, 135, 167, 135, 167, 136, 168, 136, 168, 136, 168, 136, 168, 136, 168, 138, 170, 138, 170, 138, 170, 138, 170, 139, 171, 139, 171, 140, 172, 140, 172, 140, 172, 140, 172, 140, 130, 130, 130, 141, 173, 142, 174, 130, 143, 175, 143, 175, 143, 175, 143, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130},
    { 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 175, 143, 175, 145, 177, 145, 177, 145, 177, 177, 130, 130, 146, 178, 146, 178, 146, 178, 130, 130, 149, 181, 149, 181, 149, 181, 150, 182, 150, 182, 150, 182, 150, 182, 151, 183, 151, 183, 151, 183, 152, 184, 152, 184, 152, 184, 152, 184, 152, 184, 152, 184, 154, 186, 156, 188, 156, 157, 189, 157, 189, 157, 189, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130},
    { 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 165, 133, 133, 165, 130, 130, 130, 134, 166, 130, 135, 135, 167, 130, 130, 130, 130, 137, 169, 138, 130, 130, 130, 140, 142, 174, 175, 130, 130, 145, 177, 146, 146, 178, 130, 130, 147, 179, 130, 130, 130, 130, 130, 183, 151, 183, 151, 152, 184, 130, 153, 156, 188, 157, 189, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130},
    { 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 100, 130, 130, 130, 130, 130, 130, 130, 130, 130, 132, 164, 140, 172, 146, 178, 152, 184, 152, 184, 152, 184, 152, 184, 152, 184, 130, 132, 164, 132, 164, 130, 130, 138, 170, 138, 170, 142, 174, 146, 178, 146, 178, 130, 130, 173, 130, 130, 130, 138, 170, 130, 130, 145, 177, 132, 164, 130, 130, 146, 178, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130},
    { 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 132, 164, 132, 164, 136, 168, 136, 168, 140, 172, 140, 172, 146, 178, 146, 178, 149, 181, 149, 181, 152, 184, 152, 184, 150, 182, 151, 183, 130, 130, 139, 171, 145, 167, 130, 130, 157, 189, 132, 164, 136, 168, 146, 178, 146, 178, 146, 178, 146, 178, 156, 188, 175, 177, 183, 130, 130, 130, 132, 134, 166, 143, 151, 182, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130},
    { 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 189, 130, 130, 133, 152, 130, 136, 168, 141, 173, 130, 180, 149, 181, 156, 188, 130, 130, 130, 165, 130, 166, 167, 167, 130, 130, 130, 130, 130, 130, 130, 130, 170, 130, 130, 130, 130, 130, 171, 130, 172, 130, 130, 175, 175, 175, 175, 130, 130, 176, 177, 177, 130, 130, 130, 130, 130, 130, 130, 130, 181, 181, 181, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130},
    { 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 182, 130, 130, 130, 130, 130, 183, 184, 130, 185, 130, 130, 130, 130, 189, 189, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 173, 130, 130, 180, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130},
    { 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 193, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130},
    { 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 136, 130, 140, 130, 130, 130, 130, 130, 130, 140, 130, 130, 132, 130, 130, 130, 130, 130, 130, 130, 140, 130, 130, 130, 130, 130, 146, 130, 130, 130, 130, 152, 130, 130, 130, 130, 130, 130, 130, 130, 130, 136, 130, 130, 164, 130, 130, 130, 130, 130, 130, 130, 172, 130, 130, 130, 130, 130, 178, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130},
    { 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 184, 130, 130, 130, 130, 130, 130, 130, 130, 130, 168, 130, 130, 130, 130, 130, 130, 168, 130, 172, 130, 130, 130, 130, 130, 130, 172, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130},
    { 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 146, 178, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 139, 171, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130},
    { 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 132, 164, 132, 164, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 140, 172, 140, 172, 146, 178, 130, 130, 130, 130, 136, 168, 152, 184, 152, 184, 152, 184, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130},
    { 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 100, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130},
    { 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 112, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130},
    { 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130},
    { 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130},
    { 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 100, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130},
    { 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130,  21, 130,  21, 130,  21, 130,  21, 130,  21, 130,  21, 130,  21, 130,  21, 130,  21, 130, 130, 130,  22, 130,  22,  17, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130},
    { 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130},
    { 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130},
    { 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130,  24, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130,  25, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130,  17,  26, 130, 130, 130, 130,  27, 130,  22, 130, 130, 130, 130, 130,  22, 130, 130, 130, 130, 130, 130, 130,  28,  29, 130,  30,  31,  32,  33, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130},
    { 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130},
    { 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 116, 117, 118, 119, 120, 121, 122, 123, 124, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130},
    { 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 112, 130, 130, 130, 130, 130, 130, 130, 130, 130, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130},
    { 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 100, 130, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130},
    { 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 172, 181, 184, 185, 130, 130, 130, 130, 130, 130, 165, 167, 169, 176, 177, 179, 181, 181, 182, 183, 189, 130, 130, 130, 130, 140, 130, 179, 152, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130},
    { 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 165, 167, 169, 170, 174, 175, 176, 177, 179, 181, 182, 130, 185, 187, 189, 164, 130, 167, 168, 130, 130, 130, 172, 130, 130, 184, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130},
    { 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 132, 164, 133, 165, 133, 165, 133, 165, 134, 166, 135, 167, 135, 167, 135, 167, 135, 167, 135, 167, 136, 168, 136, 168, 136, 168, 136, 168, 136, 168, 137, 169, 138, 170, 139, 171, 139, 171, 139, 171, 139, 171, 139, 171, 140, 172, 140, 172, 142, 174, 142, 174, 142, 174, 143, 175, 143, 175, 143, 175, 143, 175, 144, 176, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130},
    { 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 144, 176, 144, 176, 145, 177, 145, 177, 145, 177, 145, 177, 146, 178, 146, 178, 146, 178, 146, 178, 147, 179, 147, 179, 149, 181, 149, 181, 149, 181, 149, 181, 150, 182, 150, 182, 150, 182, 150, 182, 150, 182, 151, 183, 151, 183, 151, 183, 151, 183, 152, 184, 152, 184, 152, 184, 152, 184, 152, 184, 153, 185, 153, 185, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130},
    { 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 154, 186, 154, 186, 154, 186, 154, 186, 154, 186, 155, 187, 155, 187, 156, 188, 157, 189, 157, 189, 157, 189, 171, 183, 186, 188, 164, 130, 130, 130, 130, 130, 132, 164, 132, 164, 132, 164, 132, 164, 132, 164, 132, 164, 132, 164, 132, 164, 132, 164, 132, 164, 132, 164, 132, 164, 136, 168, 136, 168, 136, 168, 136, 168, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130},
    { 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 136, 168, 136, 168, 136, 168, 136, 168, 140, 172, 140, 172, 146, 178, 146, 178, 146, 178, 146, 178, 146, 178, 146, 178, 146, 178, 146, 178, 146, 178, 146, 178, 146, 178, 146, 178, 152, 184, 152, 184, 152, 184, 152, 184, 152, 184, 152, 184, 152, 184, 156, 188, 156, 188, 156, 188, 156, 188, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130},
    { 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130,  35,  36,  37, 130, 130, 130, 130, 130,  38, 130,  39, 130, 130, 130, 130, 130, 130,  40,  41,  42, 130, 130, 130, 130, 130, 130, 130, 130,  43,  44,  45, 130, 130, 130, 130, 130, 130, 130, 130, 130,  46, 130, 130,  47, 130, 130, 130, 130,  48,  49,  50, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130},
    { 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 112, 112, 130, 112, 112, 130, 130, 130, 106, 106, 106, 106, 101, 101, 101, 101, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 100, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130},
    { 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 112, 130, 130, 130, 130, 100, 130, 130, 130, 130, 130, 130, 130, 130, 130, 112, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 115, 172, 130, 130, 119, 120, 121, 122, 123, 124, 130, 112, 130, 130, 130, 177, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130},
    { 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 130, 112, 130, 130, 130, 130, 164, 168, 178, 187, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130},
    { 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 112, 130, 130, 114, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130},
    { 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 109, 130, 130, 130, 130, 130, 130, 130, 130, 112, 130, 114, 130, 130, 130, 130, 130, 130, 112, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130},
    { 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 116, 117, 118, 119, 120, 121, 122, 123, 124, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 116, 117, 118, 119, 120, 121, 122, 123, 124, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130},
    { 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 116, 117, 118, 119, 120, 121, 122, 123, 124, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130},
    { 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 115, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 116, 117, 118, 119, 120, 121, 122, 123, 124, 130, 115, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130},
    { 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 109, 109, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130},
    { 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 100, 100, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 116, 117, 118, 119, 120, 121, 122, 123, 124, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130},
    { 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 116, 117, 118, 119, 120, 121, 122, 123, 124, 130, 116, 117, 118, 119, 120, 121, 122, 123, 124, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130},
    { 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 109, 109, 130, 130, 109, 109, 109, 109, 114, 130, 130, 109, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130},
    { 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 109, 109, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130},
    { 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 140, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 172, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130},
    { 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 143, 175, 143, 147, 149, 164, 183, 139, 171, 142, 174, 157, 189, 130, 130, 130, 130, 130, 130, 130, 185, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130},
    { 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 146, 178, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130},
    { 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130,  52,  53, 130, 130,  54,  55, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130},
    { 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 100, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130},
    { 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 100, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 112, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130},
    { 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 100, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 112, 130, 130, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 130, 130, 130, 130, 130, 130, 130, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130},
    { 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130},
    { 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130,  57, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130,  60, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130},
    { 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130,  58, 130,  17, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130,  59, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130},
    { 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 139, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 171, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130},
    { 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 116, 117, 118, 119, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130},
    { 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130,  61, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130,  62, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130},
    { 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 116, 117, 118, 119, 120, 121, 122, 123, 124, 116, 117, 118, 119, 120, 121, 122, 123, 124, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130},
    { 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130},
    { 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130,  64, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130},
    { 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130,  65,  66, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130},
    { 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 100, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 112, 130, 130, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130},
    { 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 130, 130, 130, 130, 130, 130, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130}
};

// utf/tr_tolower.txt
//
// 56 code points.
// 1 states, 2 columns, 258 bytes
//
const unsigned char tr_tolower_itt[256] =
{
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,

       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   1,   1,   1,   1,   1,    1,   1,   1,   1,   1,   1,   1,   1,
       1,   1,   1,   1,   1,   1,   1,   1,    1,   1,   1,   1,   1,   1,   1,   1,
       1,   1,   1,   1,   1,   1,   1,   1,    1,   1,   1,   1,   1,   1,   1,   1,
       1,   1,   1,   1,   1,   1,   1,   1,    1,   1,   1,   1,   1,   1,   1,   1

};

const unsigned char tr_tolower_stt[1][2] =
{
    {   1,   2}
};

const char *tr_tolower_ott[2] =
{
    " ",
    ""
};

// utf/tr_toupper.txt
//
// 57 code points.
// 1 states, 4 columns, 260 bytes
//
const unsigned char tr_toupper_itt[256] =
{
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,

       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
       1,   1,   1,   1,   1,   1,   1,   1,    1,   1,   1,   1,   1,   1,   1,   1,
       1,   1,   1,   1,   1,   1,   1,   1,    1,   1,   1,   1,   1,   1,   1,   2,
       2,   2,   2,   3,   3,   3,   3,   3,    3,   3,   3,   3,   3,   3,   3,   3,
       3,   3,   3,   3,   3,   3,   3,   3,    3,   3,   3,   3,   3,   3,   3,   3,
       3,   3,   3,   3,   3,   3,   3,   3,    3,   3,   3,   3,   3,   3,   3,   3,
       3,   3,   3,   3,   3,   3,   3,   3,    3,   3,   3,   3,   3,   3,   3,   3

};

const unsigned char tr_toupper_stt[1][4] =
{
    {   1,   2,   3,   0}
};

const char *tr_toupper_ott[3] =
{
    " ",
    "",
    "\x06\x07"
};

// utf/tr_Color.txt
//
// 517 code points.
// 5 states, 11 columns, 311 bytes
//
#define TR_COLOR_START_STATE (0)
#define TR_COLOR_ACCEPTING_STATES_START (5)

const unsigned char tr_color_itt[256] =
{
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,

       1,   2,   3,   4,   5,   6,   7,   8,    9,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,  10,   0,
       0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0

};

const unsigned char tr_color_stt[5][11] =
{
    {   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   1},
    {   5,   2,   5,   5,   5,   3,   5,   5,   5,   4,   5},
    {   5,   6,   7,   5,   5,   8,   9,   5,  10,   5,   5},
    {   5,  11,  12,  13,  14,  15,  16,  17,  18,   5,   5},
    {   5,  19,  20,  21,  22,  23,  24,  25,  26,   5,   5}
};

/*! \brief Validates UTF8 string and returns number of code points contained therein.
 *
 * \param pString   UTF8 string.
 * \param nString   Resulting number of code points in pString.
 * \return          true for valid, false for invalid.
 */

bool utf8_strlen(const UTF8 *pString, size_t &nString)
{
    nString = 0;
    int i = 0;
    while ('\0' != pString[i])
    {
        unsigned char t = utf8_FirstByte[pString[i]];
        if (UTF8_CONTINUE <= t)
        {
            return false;
        }

        int j;
        for (j = i + 1; j < i + t; j++)
        {
            if (  '\0' == pString[j]
               || UTF8_CONTINUE != utf8_FirstByte[pString[j]])
            {
                return false;
            }
        }
        nString++;
        i = i + t;
    }
    return true;
}

bool utf8_strlen(const UTF8 *pString, mux_cursor &nString)
{
    LBUF_OFFSET nPoints = 0;
    LBUF_OFFSET nBytes  = 0;
    while ('\0' != pString[nBytes])
    {
        unsigned char t = utf8_FirstByte[pString[nBytes]];
        if (UTF8_CONTINUE <= t)
        {
            nString(nBytes, nPoints);
            return false;
        }

        int j;
        for (j = nBytes + 1; j < nBytes + t; j++)
        {
            if (  '\0' == pString[j]
               || UTF8_CONTINUE != utf8_FirstByte[pString[j]])
            {
                nString(nBytes, nPoints);
                return false;
            }
        }
        nPoints++;
        nBytes = nBytes + t;
    }
    nString(nBytes, nPoints);
    return true;
}

/*! \brief Convert UTF8 to latin1 with '?' for all unsupported characters.
 *
 * \param pString   UTF8 string.
 * \return          Equivalent string in latin1 codeset.
 */

const char *ConvertToLatin(const UTF8 *pString)
{
    static char buffer[LBUF_SIZE];
    char *q = buffer;

    while ('\0' != *pString)
    {
        const UTF8 *p = pString;
        int iState = TR_LATIN1_START_STATE;
        do
        {
            unsigned char ch = *p++;
            iState = tr_latin1_stt[iState][tr_latin1_itt[(unsigned char)ch]];
        } while (iState < TR_LATIN1_ACCEPTING_STATES_START);
        *q++ = (char)(iState - TR_LATIN1_ACCEPTING_STATES_START);
        pString = utf8_NextCodePoint(pString);
    }
    *q = '\0';
    return buffer;
}

/*! \brief Convert UTF8 to ASCII with '?' for all unsupported characters.
 *
 * \param pString   UTF8 string.
 * \return          Equivalent string in ASCII codeset.
 */

const char *ConvertToAscii(const UTF8 *pString)
{
    static char buffer[LBUF_SIZE];
    char *q = buffer;

    while ('\0' != *pString)
    {
        const UTF8 *p = pString;
        int iState = TR_ASCII_START_STATE;
        do
        {
            unsigned char ch = *p++;
            iState = tr_ascii_stt[iState][tr_ascii_itt[(unsigned char)ch]];
        } while (iState < TR_ASCII_ACCEPTING_STATES_START);
        *q++ = (char)(iState - TR_ASCII_ACCEPTING_STATES_START);
        pString = utf8_NextCodePoint(pString);
    }
    *q = '\0';
    return buffer;
}

#define CS_FOREGROUND ((UINT16)0x000F)
#define CS_FG_BLACK   ((UINT16)0x0000)
#define CS_FG_RED     ((UINT16)0x0001)
#define CS_FG_GREEN   ((UINT16)0x0002)
#define CS_FG_YELLOW  ((UINT16)0x0003)
#define CS_FG_BLUE    ((UINT16)0x0004)
#define CS_FG_MAGENTA ((UINT16)0x0005)
#define CS_FG_CYAN    ((UINT16)0x0006)
#define CS_FG_WHITE   ((UINT16)0x0007)
#define CS_FG_DEFAULT ((UINT16)0x0008)
#define CS_BACKGROUND ((UINT16)0x00F0)
#define CS_BG_BLACK   ((UINT16)0x0000)
#define CS_BG_RED     ((UINT16)0x0010)
#define CS_BG_GREEN   ((UINT16)0x0020)
#define CS_BG_YELLOW  ((UINT16)0x0030)
#define CS_BG_BLUE    ((UINT16)0x0040)
#define CS_BG_MAGENTA ((UINT16)0x0050)
#define CS_BG_CYAN    ((UINT16)0x0060)
#define CS_BG_WHITE   ((UINT16)0x0070)
#define CS_BG_DEFAULT ((UINT16)0x0080)
#define CS_INTENSE    ((UINT16)0x0100)
#define CS_INVERSE    ((UINT16)0x0200)
#define CS_UNDERLINE  ((UINT16)0x0400)
#define CS_BLINK      ((UINT16)0x0800)
#define CS_ATTRS      ((UINT16)0x0F00)
#define CS_ALLBITS    ((UINT16)0xFFFF)

#define CS_NORMAL     (CS_FG_DEFAULT|CS_BG_DEFAULT)
#define CS_NOBLEED    (CS_FG_WHITE|CS_BG_DEFAULT)

static struct
{
    ColorState csClear;
    ColorState csSet;
} csMasks[COLOR_LAST_CODE+1] =
{
    { 0, 0 },                         //  0 (Not used)
    { CS_ALLBITS,    CS_NORMAL     }, //  1 (COLOR_RESET)
    { 0,             CS_INTENSE    }, //  2 (COLOR_INTENSE)
    { 0,             CS_UNDERLINE  }, //  3 (COLOR_UNDERLINE)
    { 0,             CS_BLINK      }, //  4 (COLOR_BLINK)
    { 0,             CS_INVERSE    }, //  5 (COLOR_INVERSE)
    { CS_FOREGROUND, CS_FG_BLACK   }, //  6 (COLOR_FG_BLACK)
    { CS_FOREGROUND, CS_FG_RED     }, //  7 (COLOR_FG_RED)
    { CS_FOREGROUND, CS_FG_GREEN   }, //  8 (COLOR_FG_GREEN)
    { CS_FOREGROUND, CS_FG_YELLOW  }, //  9 (COLOR_FG_YELLOW)
    { CS_FOREGROUND, CS_FG_BLUE    }, // 10 (COLOR_FG_BLUE)
    { CS_FOREGROUND, CS_FG_MAGENTA }, // 11 (COLOR_FG_MAGENTA)
    { CS_FOREGROUND, CS_FG_CYAN    }, // 12 (COLOR_FG_CYAN)
    { CS_FOREGROUND, CS_FG_WHITE   }, // 13 (COLOR_FG_WHITE)
    { CS_BACKGROUND, CS_BG_BLACK   }, // 14 (COLOR_BG_BLACK)
    { CS_BACKGROUND, CS_BG_RED     }, // 15 (COLOR_BG_RED)
    { CS_BACKGROUND, CS_BG_GREEN   }, // 16 (COLOR_BG_GREEN)
    { CS_BACKGROUND, CS_BG_YELLOW  }, // 17 (COLOR_BG_YELLOW)
    { CS_BACKGROUND, CS_BG_BLUE    }, // 18 (COLOR_BG_BLUE)
    { CS_BACKGROUND, CS_BG_MAGENTA }, // 19 (COLOR_BG_MAGENTA)
    { CS_BACKGROUND, CS_BG_CYAN    }, // 20 (COLOR_BG_CYAN)
    { CS_BACKGROUND, CS_BG_WHITE   }, // 21 (COLOR_BG_WHITE)
};

inline ColorState UpdateColorState(ColorState cs, int iColorCode)
{
    return (cs & ~csMasks[iColorCode].csClear) | csMasks[iColorCode].csSet;
}

// Maximum binary transition length is:
//
//   COLOR_RESET      "\xEE\x80\x80"
// + COLOR_INTENSE    "\xEE\x80\x81"
// + COLOR_UNDERLINE  "\xEE\x80\x84"
// + COLOR_BLINK      "\xEE\x80\x85"
// + COLOR_INVERSE    "\xEE\x80\x87"
// + COLOR_FG_RED     "\xEE\x84\x81"
// + COLOR_BG_WHITE   "\xEE\x88\x87"
//
// Each of the seven codes is 3 bytes or 21 bytes total.
//
#define ANSI_MAXIMUM_BINARY_TRANSITION_LENGTH 21

// Generate the minimal ANSI sequence that will transition from one color state
// to another.
//
static UTF8 *ANSI_TransitionColorBinary
(
    ColorState csCurrent,
    ColorState csNext,
    size_t *nTransition,
    bool bNoBleed = false
)
{
    static UTF8 Buffer[ANSI_MAXIMUM_BINARY_TRANSITION_LENGTH+1];

    if (bNoBleed)
    {
        if ((csCurrent & CS_FOREGROUND) == CS_FG_DEFAULT)
        {
            csCurrent = (csCurrent & ~CS_FOREGROUND) | CS_FG_WHITE;
        }

        if ((csNext & CS_FOREGROUND) == CS_FG_DEFAULT)
        {
            csNext = (csNext & ~CS_FOREGROUND) | CS_FG_WHITE;
        }
    }

    if (csCurrent == csNext)
    {
        *nTransition = 0;
        Buffer[0] = '\0';
        return Buffer;
    }
    UTF8 *p = Buffer;

    // Do we need to go through the normal state?
    //
    if (  ((csCurrent & ~csNext) & CS_ATTRS)
       || (  (csNext & CS_BACKGROUND) == CS_BG_DEFAULT
          && (csCurrent & CS_BACKGROUND) != CS_BG_DEFAULT)
       || (  (csNext & CS_FOREGROUND) == CS_FG_DEFAULT
          && (csCurrent & CS_FOREGROUND) != CS_FG_DEFAULT))
    {
        memcpy(p, COLOR_RESET, sizeof(COLOR_RESET)-1);
        p += sizeof(COLOR_RESET)-1;
        csCurrent = CS_NORMAL;
    }

    UINT16 tmp = csCurrent ^ csNext;
    if (CS_ATTRS & tmp)
    {
        if (CS_INTENSE & tmp)
        {
            memcpy(p, COLOR_INTENSE, sizeof(COLOR_INTENSE)-1);
            p += sizeof(COLOR_INTENSE)-1;
        }

        if (CS_UNDERLINE & tmp)
        {
            memcpy(p, COLOR_UNDERLINE, sizeof(COLOR_UNDERLINE)-1);
            p += sizeof(COLOR_UNDERLINE)-1;
        }

        if (CS_BLINK & tmp)
        {
            memcpy(p, COLOR_BLINK, sizeof(COLOR_BLINK)-1);
            p += sizeof(COLOR_BLINK)-1;
        }

        if (CS_INVERSE & tmp)
        {
            memcpy(p, COLOR_INVERSE, sizeof(COLOR_INVERSE)-1);
            p += sizeof(COLOR_INVERSE)-1;
        }
    }

    if (CS_FOREGROUND & tmp)
    {
        UTF8 *aForegrounds[8] =
        {
            (UTF8 *)COLOR_FG_BLACK,
            (UTF8 *)COLOR_FG_RED,
            (UTF8 *)COLOR_FG_GREEN,
            (UTF8 *)COLOR_FG_YELLOW,
            (UTF8 *)COLOR_FG_BLUE,
            (UTF8 *)COLOR_FG_MAGENTA,
            (UTF8 *)COLOR_FG_CYAN,
            (UTF8 *)COLOR_FG_WHITE
        };
        int iForeground = (CS_FOREGROUND & csNext);
        memcpy(p, aForegrounds[iForeground], sizeof(COLOR_FG_BLACK)-1);
        p += sizeof(COLOR_FG_BLACK)-1;
    }

    if (CS_BACKGROUND & tmp)
    {
        UTF8 *aBackgrounds[8] =
        {
            (UTF8 *)COLOR_BG_BLACK,
            (UTF8 *)COLOR_BG_RED,
            (UTF8 *)COLOR_BG_GREEN,
            (UTF8 *)COLOR_BG_YELLOW,
            (UTF8 *)COLOR_BG_BLUE,
            (UTF8 *)COLOR_BG_MAGENTA,
            (UTF8 *)COLOR_BG_CYAN,
            (UTF8 *)COLOR_BG_WHITE
        };
        int iBackground = (CS_BACKGROUND & csNext) >> 4;
        memcpy(p, aBackgrounds[iBackground], sizeof(COLOR_BG_BLACK)-1);
        p += sizeof(COLOR_BG_BLACK)-1;
    }
    *p = '\0';
    *nTransition = p - Buffer;
    return Buffer;
}

// Maximum binary transition to normal is:
//
//   COLOR_RESET      "\xEE\x80\x80"
// + COLOR_FG_WHITE   "\xEE\x88\x87"
//
// Each of the two codes is 3 bytes or 6 bytes total.
//
#define COLOR_MAXIMUM_BINARY_NORMAL 6

// Generate the minimal color sequence that will transition from one color state
// to the normal state.
//
static const UTF8 *ColorBinaryNormal
(
    ColorState csCurrent,
    size_t *nTransition,
    bool bNoBleed = false
)
{
    static const UTF8 *aBleed = T(COLOR_RESET);
    static const UTF8 *aNoBleed = T(COLOR_RESET COLOR_FG_WHITE);

    if (  csCurrent == CS_NORMAL
       || (  bNoBleed 
          && csCurrent == CS_NOBLEED))
    {
        *nTransition = 0;
        return T("");
    }

    *nTransition = bNoBleed ? sizeof(aNoBleed)-1 : sizeof(aBleed)-1;
    return bNoBleed ? aNoBleed : aBleed;
}

// Maximum binary transition length is:
//
//   COLOR_RESET      "%xn"
// + COLOR_INTENSE    "%xh"
// + COLOR_UNDERLINE  "%xu"
// + COLOR_BLINK      "%xf"
// + COLOR_INVERSE    "%xi"
// + COLOR_FG_RED     "%xr"
// + COLOR_BG_WHITE   "%xW"
//
// Each of the seven codes is 3 bytes or 21 bytes total.
//
#define ANSI_MAXIMUM_ESCAPE_TRANSITION_LENGTH 21

// Generate the minimal color %-sequence that will transition from one color state
// to another.
//
static UTF8 *ANSI_TransitionColorEscape
(
    ColorState csCurrent,
    ColorState csNext,
    int *nTransition
)
{
    static UTF8 Buffer[ANSI_MAXIMUM_ESCAPE_TRANSITION_LENGTH+1];
    static const UTF8 cForegroundColors[9] = "xrgybmcw";
    static const UTF8 cBackgroundColors[9] = "XRGYBMCW";

    if (csCurrent == csNext)
    {
        *nTransition = 0;
        Buffer[0] = '\0';
        return Buffer;
    }
    int  i = 0;

    // Do we need to go through the normal state?
    //
    if (  ((csCurrent & ~csNext) & CS_ATTRS)
       || (  (csNext & CS_BACKGROUND) == CS_BG_DEFAULT
          && (csCurrent & CS_BACKGROUND) != CS_BG_DEFAULT)
       || (  (csNext & CS_FOREGROUND) == CS_FG_DEFAULT
          && (csCurrent & CS_FOREGROUND) != CS_FG_DEFAULT))
    {
        Buffer[i  ] = '%';
        Buffer[i+1] = 'x';
        Buffer[i+2] = 'n';
        i = i + 3;
        csCurrent = CS_NORMAL;
    }

    UINT16 tmp = csCurrent ^ csNext;
    if (CS_ATTRS & tmp)
    {
        if (CS_INTENSE & tmp)
        {
            Buffer[i  ] = '%';
            Buffer[i+1] = 'x';
            Buffer[i+2] = 'h';
            i = i + 3;
        }

        if (CS_UNDERLINE & tmp)
        {
            Buffer[i  ] = '%';
            Buffer[i+1] = 'x';
            Buffer[i+2] = 'u';
            i = i + 3;
        }

        if (CS_BLINK & tmp)
        {
            Buffer[i  ] = '%';
            Buffer[i+1] = 'x';
            Buffer[i+2] = 'f';
            i = i + 3;
        }

        if (CS_INVERSE & tmp)
        {
            Buffer[i  ] = '%';
            Buffer[i+1] = 'x';
            Buffer[i+2] = 'i';
            i = i + 3;
        }
    }

    if (CS_FOREGROUND & tmp)
    {
        int iForeground = (CS_FOREGROUND & csNext);
        Buffer[i  ] = '%';
        Buffer[i+1] = 'x';
        Buffer[i+2] = cForegroundColors[iForeground];
        i = i + 3;
    }

    if (CS_BACKGROUND & tmp)
    {
        int iBackground = (CS_BACKGROUND & csNext) >> 4;
        Buffer[i  ] = '%';
        Buffer[i+1] = 'x';
        Buffer[i+2] = cBackgroundColors[iBackground];
        i = i + 3;
    }
    Buffer[i] = '\0';
    *nTransition = i;
    return Buffer;
}

void ANSI_String_In_Init
(
    struct ANSI_In_Context *pacIn,
    const UTF8 *szString
)
{
    pacIn->m_cs = CS_NORMAL;
    pacIn->m_p  = szString;
    pacIn->m_n  = strlen((char *)szString);
}

void ANSI_String_Out_Init
(
    struct ANSI_Out_Context *pacOut,
    UTF8  *pField,
    size_t nField,
    size_t vwMax
)
{
    // Current ColorState.
    //
    pacOut->m_cs       = CS_NORMAL;

    // Physical field definition.
    //
    pacOut->m_p        = pField;
    pacOut->m_nMax     = nField;

    // Visual field definition.
    //
    pacOut->m_vwMax    = vwMax;

    // Current use of physical and visual resources.
    //
    pacOut->m_vw       = 0;
    pacOut->m_n        = 0;

    // Ready, set, go.
    //
    pacOut->m_bDone    = false;
}

#define KBA_UNKNOWN           0
#define KBA_ABOVE_MINIMUM     1
#define KBA_NEED_TRANSITIONS  2
#define KBA_NEED_CODEPOINT    3

// ANSI_String_Copy
//
// Move as many visible code points as possible from In to Out until either
// In is exhausted, Out physically fills up, or we reach the maximum visual
// width allowed to Out.
//
// Color is optimized to maximize room for visual code points. Color must not
// be allowed to bleed beyond the field boundaries. We are allowed to discard
// the trailing visible code points if necessary to make things fit.
//
// Several calls from different sources of In may be made, but when Out
// reaches one of its contraints, it's marked Done.
//
// pac->m_cs represents the ColorState of the code point at pacIn->m_p. In
// order to copy that code point to Out, Out's pacOut->m_cs must first agree
// or be made to agree.  The input contain pacIn->m_n bytes starting with
// pacIn->m_p.
//
// Likewise, the ColorState of the next code point to be added at pacOut->m_p
// is given by pacOut->m_cs. Out has many conflicting constraints.  Firstly,
// the final color state to achieve is given by pacOut->m_csFinal.  Secondly,
// We cannot add more visible character to Out than pacOut->m_vwMax.  Finally,
// the physical space in Out is limited to pacOut->m_nMax bytes.
//
void ANSI_String_Copy
(
    struct ANSI_Out_Context *pacOut,
    struct ANSI_In_Context  *pacIn
)
{
    if (pacOut->m_bDone)
    {
        // Out is full already (either visually or physically).
        //
        return;
    }

    // Knowledge of the binary transitions from pacIn->m_cs to pacOut->m_cs
    // and the transition from pacOut->m_cs to pacOut->m_csFinal that must
    // occur before any code points are added and when we are done,
    // respectively.
    //
    bool   bKnowTransitions = false;
    size_t nTransitionInitial = 0;
    size_t nTransitionFinal = 0;

    // Increasing knowledge of how far away we are from the constraints.
    //
    // We assume the longest possible transitions for both initial and
    // final (which is pessimisitic) plus a '\0' terminator.
    //
    int    iKnownAvailable = KBA_NEED_TRANSITIONS;
    size_t nMinimumCodePoints = 0;
    size_t nNeededBytes = ANSI_MAXIMUM_BINARY_TRANSITION_LENGTH
                        + COLOR_MAXIMUM_BINARY_NORMAL + 1;
    if (nNeededBytes + UTF8_SIZE4 - 1 < pacOut->m_nMax)
    {
        size_t nMinimumBytesAvailable = pacOut->m_nMax - nNeededBytes;
        nMinimumCodePoints = nMinimumBytesAvailable/UTF8_SIZE4;
        if (pacOut->m_vw < pacOut->m_vwMax)
        {
            size_t vwAvailable = pacOut->m_vwMax - pacOut->m_vw;
            if (vwAvailable < nMinimumCodePoints)
            {
                nMinimumCodePoints = vwAvailable;
            }
            iKnownAvailable = KBA_ABOVE_MINIMUM;
        }
    }

    while (  '\0' != *pacIn->m_p
          && !pacOut->m_bDone)
    {
        int iCode = mux_color(pacIn->m_p);
        if (COLOR_NOTCOLOR != iCode)
        {
            // With a run of color code points, we shouldn't recalculate the
            // transitions because they are constantly changing.  We may in
            // fact run out of input before we find anything visual to copy
            // to Out.
            //
            bKnowTransitions = false;
            pacIn->m_cs = UpdateColorState(pacIn->m_cs, iCode);

            size_t nInBytes = utf8_FirstByte[(unsigned char)*pacIn->m_p];
            pacIn->m_n -= nInBytes;
            pacIn->m_p += nInBytes;
        }
        else
        {
            do
            {
                size_t nCodePointBytes;
                if (KBA_NEED_TRANSITIONS <= iKnownAvailable)
                {
                    // The transitions are easy to figure out and aren't affected by
                    // visual code points.
                    //
                    if (!bKnowTransitions)
                    {
                        ANSI_TransitionColorBinary( pacIn->m_cs,
                                                    pacOut->m_cs,
                                                    &nTransitionInitial);
                        ColorBinaryNormal(pacIn->m_cs, &nTransitionFinal);
                        bKnowTransitions = true;
                    }
                }

                if (KBA_NEED_CODEPOINT == iKnownAvailable)
                {
                    nCodePointBytes = utf8_FirstByte[(unsigned char)*pacIn->m_p];
                    size_t nNeededBytes = nTransitionInitial + nTransitionFinal + nCodePointBytes + 1;
                    if (  pacOut->m_nMax < nNeededBytes
                       || pacOut->m_vwMax < pacOut->m_vw)
                    {
                        pacOut->m_bDone = true;
                        break;
                    }

                    // Emit initial transition.
                    //
                    UTF8 *pTransitionInitial =
                        ANSI_TransitionColorBinary( pacOut->m_cs,
                                                    pacIn->m_cs,
                                                    &nTransitionInitial);

                    if (0 < nTransitionInitial)
                    {
                        memcpy((char *)pacOut->m_p, (char *)pTransitionInitial, nTransitionInitial);
                        pacOut->m_p    += nTransitionInitial;
                        pacOut->m_n    += nTransitionInitial;
                        pacOut->m_nMax -= nTransitionInitial;
                        pacOut->m_cs = pacIn->m_cs;
                    }

                    // Handle single code point.
                    //
                    const UTF8 *p = utf8_NextCodePoint(pacIn->m_p);
                    iCode = mux_color(p);
                    pacOut->m_vw++;

                    // Copy visual code point.
                    //
                    size_t nBytes = p - pacIn->m_p;
                    memcpy((char *)pacOut->m_p, (char *)p, nBytes);
                    pacIn->m_p     += nBytes;
                    pacIn->m_n     -= nBytes;
                    pacOut->m_p    += nBytes;
                    pacOut->m_n    += nBytes;
                    pacOut->m_nMax -= nBytes;
                }
                else if (KBA_ABOVE_MINIMUM == iKnownAvailable)
                {
                    // Emit initial transition.
                    //
                    UTF8 *pTransitionInitial =
                        ANSI_TransitionColorBinary( pacOut->m_cs,
                                                    pacIn->m_cs,
                                                    &nTransitionInitial);

                    if (0 < nTransitionInitial)
                    {
                        memcpy((char *)pacOut->m_p, (char *)pTransitionInitial, nTransitionInitial);
                        pacOut->m_p    += nTransitionInitial;
                        pacOut->m_n    += nTransitionInitial;
                        pacOut->m_nMax -= nTransitionInitial;
                        pacOut->m_cs = pacIn->m_cs;
                    }

                    // Go into a tight loop and recognize code points until a
                    // color code point is seen, we run out of input, or we
                    // exhaust our best-case quota of code points.
                    //
                    const UTF8 *p = utf8_NextCodePoint(pacIn->m_p);
                    nMinimumCodePoints--;
                    pacOut->m_vw++;
                    while (  '\0' != *p
                          && 0 < nMinimumCodePoints)
                    {
                        iCode = mux_color(p);
                        if (COLOR_NOTCOLOR != iCode)
                        {
                            break;
                        }
                        nMinimumCodePoints--;
                        pacOut->m_vw++;
                        p = utf8_NextCodePoint(p);
                    }

                    // Copy run of visual code points.
                    //
                    size_t nBytes = p - pacIn->m_p;
                    memcpy((char *)pacOut->m_p, (char *)pacIn->m_p, nBytes);
                    pacIn->m_p     += nBytes;
                    pacIn->m_n     -= nBytes;
                    pacOut->m_p    += nBytes;
                    pacOut->m_n    += nBytes;
                    pacOut->m_nMax -= nBytes;

                    iKnownAvailable = KBA_NEED_TRANSITIONS;
                }
                else if (KBA_NEED_TRANSITIONS == iKnownAvailable)
                {
                    size_t nNeededBytes = nTransitionInitial + nTransitionFinal + 1;
                    if (nNeededBytes + UTF8_SIZE4 - 1 < pacOut->m_nMax)
                    {
                        size_t nMinimumBytesAvailable = pacOut->m_nMax - nNeededBytes;
                        nMinimumCodePoints = nMinimumBytesAvailable/UTF8_SIZE4;
                        if (pacOut->m_vw < pacOut->m_vwMax)
                        {
                            size_t vwAvailable = pacOut->m_vwMax - pacOut->m_vw;
                            if (vwAvailable < nMinimumCodePoints)
                            {
                                nMinimumCodePoints = vwAvailable;
                            }
                            iKnownAvailable = KBA_ABOVE_MINIMUM;
                        }
                        else
                        {
                            iKnownAvailable = KBA_NEED_CODEPOINT;
                        }
                    }
                    else
                    {
                        iKnownAvailable = KBA_NEED_CODEPOINT;
                    }
                }
            } while (  COLOR_NOTCOLOR == iCode
                    && '\0' != *pacIn->m_p
                    && !pacOut->m_bDone);
        }
    }
}

size_t ANSI_String_Finalize
(
    struct ANSI_Out_Context *pacOut,
    size_t *pnVisualWidth
)
{
    UTF8 *pField = pacOut->m_p;
    size_t nTransition = 0;
    const UTF8 *pTransition = ColorBinaryNormal(pacOut->m_cs, &nTransition);
    if (nTransition)
    {
        memcpy(pField, pTransition, nTransition);
        pField += nTransition;
    }
    *pField = '\0';
    pacOut->m_n += pField - pacOut->m_p;
    pacOut->m_p  = pField;
    *pnVisualWidth = pacOut->m_vw;
    return pacOut->m_n;
}

// Take an ANSI string and fit as much of the information as possible
// into a field of size nField. Truncate text. Also make sure that no color
// leaks out of the field.
//
size_t ANSI_TruncateToField
(
    const UTF8 *szString,
    size_t nField,
    UTF8 *pField0,
    size_t maxVisualWidth,
    size_t *pnVisualWidth
)
{
    if (!szString)
    {
        pField0[0] = '\0';
        return 0;
    }
    struct ANSI_In_Context aic;
    struct ANSI_Out_Context aoc;
    ANSI_String_In_Init(&aic, szString);
    ANSI_String_Out_Init(&aoc, pField0, nField, maxVisualWidth);
    ANSI_String_Copy(&aoc, &aic);
    return ANSI_String_Finalize(&aoc, pnVisualWidth);
}

UTF8 *ANSI_TruncateAndPad_sbuf(const UTF8 *pString, size_t nMaxVisualWidth, UTF8 fill)
{
    UTF8 *pStringModified = alloc_sbuf("ANSI_TruncateAndPad_sbuf");
    size_t nAvailable = SBUF_SIZE - nMaxVisualWidth;
    size_t nVisualWidth;
    size_t nLen = ANSI_TruncateToField(pString, nAvailable,
        pStringModified, nMaxVisualWidth, &nVisualWidth);
    for (size_t i = nMaxVisualWidth - nVisualWidth; i > 0; i--)
    {
        pStringModified[nLen] = fill;
        nLen++;
    }
    pStringModified[nLen] = '\0';
    return pStringModified;
}

#define COLOR_CODE_NORMAL       1
#define COLOR_CODE_FG_WHITE     13

static struct
{
    UTF8   *pAnsi;
    size_t  nAnsi;
} aColorSequences[COLOR_LAST_CODE+1] =
{
    {  NULL, 0 },
    { (UTF8 *)ANSI_NORMAL,   sizeof(ANSI_NORMAL) - 1   },
    { (UTF8 *)ANSI_HILITE,   sizeof(ANSI_HILITE) - 1   },
    { (UTF8 *)ANSI_UNDER,    sizeof(ANSI_UNDER) - 1    },
    { (UTF8 *)ANSI_BLINK,    sizeof(ANSI_BLINK) - 1    },
    { (UTF8 *)ANSI_INVERSE,  sizeof(ANSI_INVERSE) - 1  },
    { (UTF8 *)ANSI_BLACK,    sizeof(ANSI_BLACK) - 1    },
    { (UTF8 *)ANSI_RED,      sizeof(ANSI_RED) - 1      },
    { (UTF8 *)ANSI_GREEN,    sizeof(ANSI_GREEN) - 1    },
    { (UTF8 *)ANSI_YELLOW,   sizeof(ANSI_YELLOW) - 1   },
    { (UTF8 *)ANSI_BLUE,     sizeof(ANSI_BLUE) - 1     },
    { (UTF8 *)ANSI_MAGENTA,  sizeof(ANSI_MAGENTA) - 1  },
    { (UTF8 *)ANSI_CYAN,     sizeof(ANSI_CYAN) - 1     },
    { (UTF8 *)ANSI_WHITE,    sizeof(ANSI_WHITE) - 1    },
    { (UTF8 *)ANSI_BBLACK,   sizeof(ANSI_BBLACK) - 1   },
    { (UTF8 *)ANSI_BRED,     sizeof(ANSI_BRED) - 1     },
    { (UTF8 *)ANSI_BGREEN,   sizeof(ANSI_BGREEN) - 1   },
    { (UTF8 *)ANSI_BYELLOW,  sizeof(ANSI_BYELLOW) - 1  },
    { (UTF8 *)ANSI_BBLUE,    sizeof(ANSI_BBLUE) - 1    },
    { (UTF8 *)ANSI_BMAGENTA, sizeof(ANSI_BMAGENTA) - 1 },
    { (UTF8 *)ANSI_BCYAN,    sizeof(ANSI_BCYAN) - 1    },
    { (UTF8 *)ANSI_BWHITE,   sizeof(ANSI_BWHITE) - 1   }
};

UTF8 *convert_color(const UTF8 *pString, bool bNoBleed)
{
    static UTF8 aBuffer[2*LBUF_SIZE];
    UTF8 *pBuffer = aBuffer;
    while ('\0' != *pString)
    {
        unsigned int iCode = mux_color(pString);
        if (COLOR_NOTCOLOR == iCode)
        {
            utf8_safe_chr(pString, aBuffer, &pBuffer);
        }
        else
        {
            memcpy(pBuffer, aColorSequences[iCode].pAnsi, aColorSequences[iCode].nAnsi);
            pBuffer += aColorSequences[iCode].nAnsi;
        }
        pString = utf8_NextCodePoint(pString);

        if (  bNoBleed
           && COLOR_CODE_NORMAL == iCode
           && COLOR_CODE_FG_WHITE != mux_color(pString))
        {
            memcpy(pBuffer, aColorSequences[COLOR_CODE_FG_WHITE].pAnsi,
                    aColorSequences[COLOR_CODE_FG_WHITE].nAnsi);
            pBuffer += aColorSequences[COLOR_CODE_FG_WHITE].nAnsi;
        }
    }
    *pBuffer = '\0';
    return aBuffer;
}

UTF8 *strip_color(const UTF8 *pString, size_t *pnBytes, size_t *pnPoints)
{
    static UTF8 aBuffer[LBUF_SIZE];
    UTF8 *pBuffer = aBuffer;

    if (NULL == pString)
    {
        if (NULL != pnBytes)
        {
            *pnBytes = 0;
        }
        if (NULL != pnPoints)
        {
            *pnPoints = 0;
        }
        *pBuffer = '\0';
        return aBuffer;
    }

    size_t nPoints = 0;
    while ('\0' != *pString)
    {
        if (COLOR_NOTCOLOR == mux_color(pString))
        {
            utf8_safe_chr(pString, aBuffer, &pBuffer);
            nPoints++;
        }
        pString = utf8_NextCodePoint(pString);
    }
    *pBuffer = '\0';
    if (NULL != pnBytes)
    {
        *pnBytes = pBuffer - aBuffer;
    }
    if (NULL != pnPoints)
    {
        *pnPoints = nPoints;
    }
    return aBuffer;
}

typedef struct
{
    int len;
    const UTF8 *p;
} LITERAL_STRING_STRUCT;

#define NUM_MU_SUBS 14
static LITERAL_STRING_STRUCT MU_Substitutes[NUM_MU_SUBS] =
{
    { 1, T(" ")  },  // 0
    { 1, T(" ")  },  // 1
    { 2, T("%t") },  // 2
    { 2, T("%r") },  // 3
    { 0,         NULL },  // 4
    { 2, T("%b") },  // 5
    { 2, T("%%") },  // 6
    { 2, T("%(") },  // 7
    { 2, T("%)") },  // 8
    { 2, T("%[") },  // 9
    { 2, T("%]") },  // 10
    { 2, T("%{") },  // 11
    { 2, T("%}") },  // 12
    { 2, T("\\\\") } // 13
};

const unsigned char MU_EscapeConvert[256] =
{
//  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
//
    0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 0, 0, 4, 0, 0,  // 0
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 1
    1, 0, 0, 0, 0, 6, 0, 0, 7, 8, 0, 0, 0, 0, 0, 0,  // 2
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 3
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 4
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9,13,10, 0, 0,  // 5
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 6
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,11, 0,12, 0, 0,  // 7

    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 8
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 9
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // A
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // B
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // C
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // D
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // E
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0   // F
};

const unsigned char MU_EscapeNoConvert[256] =
{
//  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
//
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 4, 0, 0,  // 0
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 1
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 2
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 3
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 4
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 5
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 6
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 7

    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 8
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 9
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // A
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // B
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // C
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // D
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // E
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0   // F
};

// Convert raw character sequences into MUX substitutions (type = 1)
// or strips them (type = 0).
//
UTF8 *translate_string(const UTF8 *pString, bool bConvert)
{
    static UTF8 szTranslatedString[LBUF_SIZE];
    UTF8 *pTranslatedString = szTranslatedString;

    if (!pString)
    {
        *pTranslatedString = '\0';
        return szTranslatedString;
    }

    ColorState csCurrent = CS_NOBLEED;
    ColorState csPrevious = csCurrent;

    const UTF8 *MU_EscapeChar = (bConvert)? MU_EscapeConvert : MU_EscapeNoConvert;
    while ('\0' != *pString)
    {
        unsigned int iCode = mux_color(pString);
        if (COLOR_NOTCOLOR == iCode)
        {
            int nTransition = 0;
            if (bConvert)
            {
                UTF8 *pTransition = ANSI_TransitionColorEscape(csPrevious, csCurrent, &nTransition);
                safe_str(pTransition, szTranslatedString, &pTranslatedString);
                csPrevious = csCurrent;
            }

            UTF8 ch = pString[0];
            unsigned char code = MU_EscapeChar[ch];
            if (  0 < code
               && code < NUM_MU_SUBS)
            {
                if (ch == ' ' && pString[0] == ' ')
                {
                    code = 5;
                }
                safe_copy_buf_ascii(MU_Substitutes[code].p,
                    MU_Substitutes[code].len, szTranslatedString,
                    &pTranslatedString);
            }
            else
            {
                utf8_safe_chr(pString, szTranslatedString, &pTranslatedString);
            }
        }
        else
        {
            csCurrent = UpdateColorState(csCurrent, iCode);
        }
        pString = utf8_NextCodePoint(pString);
    }
    *pTranslatedString = '\0';
    return szTranslatedString;
}

/* ---------------------------------------------------------------------------
 * munge_space: Compress multiple spaces to one space, also remove leading and
 * trailing spaces.
 */
UTF8 *munge_space(const UTF8 *string)
{
    UTF8 *buffer = alloc_lbuf("munge_space");
    const UTF8 *p = string;
    UTF8 *q = buffer;

    if (p)
    {
        // Remove initial spaces.
        //
        while (mux_isspace(*p))
            p++;

        while (*p)
        {
            while (*p && !mux_isspace(*p))
                *q++ = *p++;

            while (mux_isspace(*p))
            {
                p++;
            }

            if (*p)
                *q++ = ' ';
        }
    }

    // Remove terminal spaces and terminate string.
    //
    *q = '\0';
    return buffer;
}

/* ---------------------------------------------------------------------------
 * trim_spaces: Remove leading and trailing spaces.
 */
UTF8 *trim_spaces(const UTF8 *string)
{
    UTF8 *buffer = alloc_lbuf("trim_spaces");
    const UTF8 *p = string;
    UTF8 *q = buffer;

    if (p)
    {
        // Remove initial spaces.
        //
        while (mux_isspace(*p))
        {
            p++;
        }

        while (*p)
        {
            // Copy non-space characters.
            //
            while (*p && !mux_isspace(*p))
            {
                *q++ = *p++;
            }

            // Compress spaces.
            //
            while (mux_isspace(*p))
            {
                p++;
            }

            // Leave one space.
            //
            if (*p)
            {
                *q++ = ' ';
            }
        }
    }

    // Terminate string.
    //
    *q = '\0';
    return buffer;
}

/*
 * ---------------------------------------------------------------------------
 * * grabto: Return portion of a string up to the indicated character.  Also
 * * returns a modified pointer to the string ready for another call.
 */

UTF8 *grabto(UTF8 **str, UTF8 targ)
{
    UTF8 *savec, *cp;

    if (!str || !*str || !**str)
        return NULL;

    savec = cp = *str;
    while (*cp && *cp != targ)
        cp++;
    if (*cp)
        *cp++ = '\0';
    *str = cp;
    return savec;
}

int string_compare(const UTF8 *s1, const UTF8 *s2)
{
    if (  mudstate.bStandAlone
       || mudconf.space_compress)
    {
        while (mux_isspace(*s1))
        {
            s1++;
        }
        while (mux_isspace(*s2))
        {
            s2++;
        }

        while (  *s1 && *s2
              && (  (mux_tolower(*s1) == mux_tolower(*s2))
                 || (mux_isspace(*s1) && mux_isspace(*s2))))
        {
            if (mux_isspace(*s1) && mux_isspace(*s2))
            {
                // skip all other spaces.
                //
                do
                {
                    s1++;
                } while (mux_isspace(*s1));

                do
                {
                    s2++;
                } while (mux_isspace(*s2));
            }
            else
            {
                s1++;
                s2++;
            }
        }
        if (  *s1
           && *s2)
        {
            return 1;
        }

        if (mux_isspace(*s1))
        {
            while (mux_isspace(*s1))
            {
                s1++;
            }
            return *s1;
        }
        if (mux_isspace(*s2))
        {
            while (mux_isspace(*s2))
            {
                s2++;
            }
            return *s2;
        }
        if (  *s1
           || *s2)
        {
            return 1;
        }
        return 0;
    }
    else
    {
        return mux_stricmp(s1, s2);
    }
}

int string_prefix(const UTF8 *string, const UTF8 *prefix)
{
    int count = 0;

    while (*string && *prefix
          && (mux_tolower(*string) == mux_tolower(*prefix)))
    {
        string++, prefix++, count++;
    }
    if (*prefix == '\0')
    {
        // Matched all of prefix.
        //
        return count;
    }
    else
    {
        return 0;
    }
}

/*
 * accepts only nonempty matches starting at the beginning of a word
 */

const UTF8 *string_match(const UTF8 *src, const UTF8 *sub)
{
    if ((*sub != '\0') && (src))
    {
        while (*src)
        {
            if (string_prefix(src, sub))
            {
                return src;
            }

            // else scan to beginning of next word
            //
            while (mux_isalnum(*src))
            {
                src++;
            }
            while (*src && !mux_isalnum(*src))
            {
                src++;
            }
        }
    }
    return 0;
}

/*
 * ---------------------------------------------------------------------------
 * * replace_string: Returns an lbuf containing string STRING with all occurances
 * * of OLD replaced by NEW. OLD and NEW may be different lengths.
 * * (mitch 1 feb 91)
 */

UTF8 *replace_string(const UTF8 *old, const UTF8 *new0, const UTF8 *s)
{
    if (!s)
    {
        return NULL;
    }
    size_t olen = strlen((char *)old);
    UTF8 *result = alloc_lbuf("replace_string");
    UTF8 *r = result;
    while (*s)
    {
        // Find next occurrence of the first character of OLD string.
        //
        const UTF8 *p = (UTF8 *)strchr((char *)s, old[0]);
        if (  olen
           && p)
        {
            // Copy up to the next occurrence of the first char of OLD.
            //
            size_t n = p - s;
            if (n)
            {
                safe_copy_buf_ascii(s, n, result, &r);
                s += n;
            }

            // If we are really at an complete OLD, append NEW to the result
            // and bump the input string past the occurrence of OLD.
            // Otherwise, copy the character and try matching again.
            //
            if (!strncmp((char *)old, (char *)s, olen))
            {
                safe_str(new0, result, &r);
                s += olen;
            }
            else
            {
                safe_chr(*s, result, &r);
                s++;
            }
        }
        else
        {
            // Finish copying source string. No matches. No further
            // work to perform.
            //
            safe_str(s, result, &r);
            break;
        }
    }
    *r = '\0';
    return result;
}

// ---------------------------------------------------------------------------
// replace_tokens: Performs ## and #@ substitution.
//
UTF8 *replace_tokens
(
    const UTF8 *s,
    const UTF8 *pBound,
    const UTF8 *pListPlace,
    const UTF8 *pSwitch
)
{
    if (!s)
    {
        return NULL;
    }
    UTF8 *result = alloc_lbuf("replace_tokens");
    UTF8 *r = result;

    while (*s)
    {
        // Find next '#'.
        //
        const UTF8 *p = (UTF8 *)strchr((char *)s, '#');
        if (p)
        {
            // Copy up to the next occurrence of the first character.
            //
            size_t n = p - s;
            if (n)
            {
                safe_copy_buf_ascii(s, n, result, &r);
                s += n;
            }

            if (  s[1] == '#'
               && pBound)
            {
                // BOUND_VAR
                //
                safe_str(pBound, result, &r);
                s += 2;
            }
            else if (  s[1] == '@'
                    && pListPlace)
            {
                // LISTPLACE_VAR
                //
                safe_str(pListPlace, result, &r);
                s += 2;
            }
            else if (  s[1] == '$'
                    && pSwitch)
            {
                // SWITCH_VAR
                //
                safe_str(pSwitch, result, &r);
                s += 2;
            }
            else
            {
                safe_chr(*s, result, &r);
                s++;
            }
        }
        else
        {
            // Finish copying source string. No matches. No further
            // work to perform.
            //
            safe_str(s, result, &r);
            break;
        }
    }
    *r = '\0';
    return result;
}

#if 0
// Returns the number of identical characters in the two strings.
//
int prefix_match(const UTF8 *s1, const UTF8 *s2)
{
    int count = 0;

    while (*s1 && *s2
          && (mux_tolower(*s1) == mux_tolower(*s2)))
    {
        s1++, s2++, count++;
    }

    // If the whole string matched, count the null.  (Yes really.)
    //
    if (!*s1 && !*s2)
    {
        count++;
    }
    return count;
}
#endif // 0

bool minmatch(const UTF8 *str, const UTF8 *target, int min)
{
    while (*str && *target
          && (mux_tolower(*str) == mux_tolower(*target)))
    {
        str++;
        target++;
        min--;
    }
    if (*str)
    {
        return false;
    }
    if (!*target)
    {
        return true;
    }
    return (min <= 0);
}

// --------------------------------------------------------------------------
// StringCloneLen: allocate memory and copy string
//
UTF8 *StringCloneLen(const UTF8 *str, size_t nStr)
{
    UTF8 *buff = (UTF8 *)MEMALLOC(nStr+1);
    if (buff)
    {
        memcpy(buff, str, nStr);
        buff[nStr] = '\0';
    }
    else
    {
        ISOUTOFMEMORY(buff);
    }
    return buff;
}

// --------------------------------------------------------------------------
// StringClone: allocate memory and copy string
//
UTF8 *StringClone(const UTF8 *str)
{
    return StringCloneLen(str, strlen((char *)str));
}

#if 0
// --------------------------------------------------------------------------
// BufferCloneLen: allocate memory and copy buffer
//
UTF8 *BufferCloneLen(const UTF8 *pBuffer, unsigned int nBuffer)
{
    UTF8 *buff = (UTF8 *)MEMALLOC(nBuffer);
    ISOUTOFMEMORY(buff);
    memcpy(buff, pBuffer, nBuffer);
    return buff;
}
#endif // 0

/* ---------------------------------------------------------------------------
 * safe_copy_str - Copy buffers, watching for overflows.
 */

void safe_copy_str(const UTF8 *src, UTF8 *buff, UTF8 **bufp, size_t nSizeOfBuffer)
{
    if (src == NULL) return;

    UTF8 *tp = *bufp;
    UTF8 *maxtp = buff + nSizeOfBuffer;
    while (tp < maxtp && *src)
    {
        *tp++ = *src++;
    }
    *bufp = tp;
}

void safe_copy_str_lbuf(const UTF8 *src, UTF8 *buff, UTF8 **bufp)
{
    if (src == NULL)
    {
        return;
    }

    UTF8 *tp = *bufp;
    UTF8 *maxtp = buff + LBUF_SIZE - 1;
    while (tp < maxtp && *src)
    {
        *tp++ = *src++;
    }
    *bufp = tp;
}

size_t safe_copy_buf_ascii(const UTF8 *src, size_t nLen, UTF8 *buff, UTF8 **bufc)
{
    size_t left = LBUF_SIZE - (*bufc - buff) - 1;
    if (left < nLen)
    {
        nLen = left;
    }
    memcpy(*bufc, src, nLen);
    *bufc += nLen;
    return nLen;
}

size_t safe_fill(UTF8 *buff, UTF8 **bufc, UTF8 chFill, size_t nSpaces)
{
    // Check for buffer limits.
    //
    size_t nBufferAvailable = LBUF_SIZE - (*bufc - buff) - 1;
    if (nSpaces > nBufferAvailable)
    {
        nSpaces = nBufferAvailable;
    }

    // Fill with spaces.
    //
    memset(*bufc, chFill, nSpaces);
    *bufc += nSpaces;
    return nSpaces;
}

void utf8_safe_chr(const UTF8 *src, UTF8 *buff, UTF8 **bufc)
{
    size_t nLen;
    size_t nLeft;
    if (  NULL == src
       || UTF8_CONTINUE <= (nLen = utf8_FirstByte[*src])
       || (nLeft = LBUF_SIZE - (*bufc - buff) - 1) < nLen)
    {
        return;
    }
    memcpy(*bufc, src, nLen);
    *bufc += nLen;
}

UTF8 *ConvertToUTF8
(
    UTF32  ch
)
{
    static UTF8 buffer[6];
    if (  UNI_SUR_HIGH_START <= ch
       && ch <= UNI_SUR_LOW_END)
    {
        buffer[0] = '\0';
        return buffer;
    }

    const UTF32 byteMask = 0xBF;
    const UTF32 byteMark = 0x80;

    if (ch < (UTF32)0x80)
    {
        // ASCII
        //
        buffer[1] = '\0';
        buffer[0] = static_cast<UTF8>(ch);
    }
    else if (ch < (UTF32)0x800)
    {
        buffer[2] = '\0';
        buffer[1] = static_cast<char>((ch | byteMark) & byteMask);
        ch >>= 6;
        buffer[0] = static_cast<char>(0xC0 | ch);
    }
    else if (ch < (UTF32)0x10000)
    {
        buffer[3] = '\0';
        buffer[2] =static_cast<char>((ch | byteMark) & byteMask);
        ch >>= 6;
        buffer[1] = static_cast<char>((ch | byteMark) & byteMask);
        ch >>= 6;
        buffer[0] = static_cast<char>(0xE0 | ch);
    }
    else if (ch <= UNI_MAX_LEGAL_UTF32)
    {
        buffer[4] = '\0';
        buffer[3] = static_cast<char>((ch | byteMark) & byteMask);
        ch >>= 6;
        buffer[2] = static_cast<char>((ch | byteMark) & byteMask);
        ch >>= 6;
        buffer[1] = static_cast<char>((ch | byteMark) & byteMask);
        ch >>= 6;
        buffer[0] = static_cast<char>(0xF8 | ch);
    }
    return buffer;
}

UTF32 ConvertFromUTF8(const UTF8 *pString)
{
    size_t t = utf8_FirstByte[*pString];
    if (UTF8_CONTINUE <= t)
    {
        return UNI_EOF;
    }

    UTF32 ch;
    if (1 == t)
    {
        // This is the most common case, and the value is always smaller than
        // UNI_SUR_HIGH_START.
        //
        return pString[0];
    }
    else if (2 == t)
    {
        if (UTF8_CONTINUE != utf8_FirstByte[pString[1]])
        {
            return UNI_EOF;
        }
        ch =  ((UTF32)(pString[0] & 0x1F) <<  6)
           |  ((UTF32)(pString[1] & 0x3F)      );
    }
    else if (3 == t)
    {
        if (  UTF8_CONTINUE != utf8_FirstByte[pString[1]]
           || UTF8_CONTINUE != utf8_FirstByte[pString[2]])
        {
            return UNI_EOF;
        }
        ch = ((UTF32)(pString[0] & 0x1F) << 12)
           | ((UTF32)(pString[1] & 0x3F) <<  6)
           | ((UTF32)(pString[2] & 0x3F)      );
    }
    else if (4 == t)
    {
        if (  UTF8_CONTINUE != utf8_FirstByte[pString[1]]
           || UTF8_CONTINUE != utf8_FirstByte[pString[2]]
           || UTF8_CONTINUE != utf8_FirstByte[pString[3]])
        {
            return UNI_EOF;
        }
        ch = ((UTF32)(pString[0] & 0x1F) << 18)
           | ((UTF32)(pString[1] & 0x3F) << 12)
           | ((UTF32)(pString[2] & 0x3F) <<  6)
           | ((UTF32)(pString[3] & 0x3F)      );
    }
    else
    {
        return UNI_EOF;
    }

    if (  ch < UNI_SUR_HIGH_START
       || (  UNI_SUR_LOW_END < ch
          && ch <= UNI_MAX_LEGAL_UTF32))
    {
        return ch;
    }
    else
    {
        return UNI_REPLACEMENT_CHAR;
    }
}

// We want to remove mal-formed ESC sequences completely and convert the
// well-formed ones.
//
UTF8 *ConvertToUTF8(const char *p, size_t *pn)
{
    *pn = 0;

    static UTF8 aBuffer[LBUF_SIZE];
    UTF8 *pBuffer = aBuffer;

    while ('\0' != *p)
    {
        if (ESC_CHAR != *p)
        {
            const UTF8 *q = latin1_utf8[(unsigned char)*p];
            utf8_safe_chr(q, aBuffer, &pBuffer);
            p++;
        }
        else
        {
            // We have an ANSI sequence.
            //
            p++;
            if ('[' == *p)
            {
                p++;
                const char *q = p;
                while (ANSI_TokenTerminatorTable[(unsigned char)*q] == 0)
                {
                    q++;
                }

                if ('\0' != q[0])
                {
                    // The segment [p,q) should contain a list of semi-color delimited codes.
                    //
                    const char *r = p;
                    while (r != q)
                    {
                        while (  r != q
                              && ';' != *r)
                        {
                            r++;
                        }

                        // The segment [p,r) should contain one code.
                        //
                        size_t n = r - p;
                        const UTF8 *s = NULL;
                        switch (n)
                        {
                        case 1:
                            if ('0' == *p)
                            {
                                s = (UTF8 *)COLOR_RESET;
                            }
                            else if ('1' == *p)
                            {
                                s = (UTF8 *)COLOR_INTENSE;
                            }
                            else if ('4' == *p)
                            {
                                s = (UTF8 *)COLOR_UNDERLINE;
                            }
                            else if ('5' == *p)
                            {
                                s = (UTF8 *)COLOR_BLINK;
                            }
                            else if ('7' == *p)
                            {
                                s = (UTF8 *)COLOR_INVERSE;
                            }
                            break;

                        case 2:
                            if ('3' == *p)
                            {
                                if ('0' == p[1])
                                {
                                    s = (UTF8 *)COLOR_FG_BLACK;
                                }
                                else if ('1' == p[1])
                                {
                                    s = (UTF8 *)COLOR_FG_RED;
                                }
                                else if ('2' == p[1])
                                {
                                    s = (UTF8 *)COLOR_FG_GREEN;
                                }
                                else if ('3' == p[1])
                                {
                                    s = (UTF8 *)COLOR_FG_YELLOW;
                                }
                                else if ('4' == p[1])
                                {
                                    s = (UTF8 *)COLOR_FG_BLUE;
                                }
                                else if ('5' == p[1])
                                {
                                    s = (UTF8 *)COLOR_FG_MAGENTA;
                                }
                                else if ('6' == p[1])
                                {
                                    s = (UTF8 *)COLOR_FG_CYAN;
                                }
                                else if ('7' == p[1])
                                {
                                    s = (UTF8 *)COLOR_FG_WHITE;
                                }
                            }
                            else if ('4' == *p)
                            {
                                if ('0' == p[1])
                                {
                                    s = (UTF8 *)COLOR_BG_BLACK;
                                }
                                else if ('1' == p[1])
                                {
                                    s = (UTF8 *)COLOR_BG_RED;
                                }
                                else if ('2' == p[1])
                                {
                                    s = (UTF8 *)COLOR_BG_GREEN;
                                }
                                else if ('3' == p[1])
                                {
                                    s = (UTF8 *)COLOR_BG_YELLOW;
                                }
                                else if ('4' == p[1])
                                {
                                    s = (UTF8 *)COLOR_BG_BLUE;
                                }
                                else if ('5' == p[1])
                                {
                                    s = (UTF8 *)COLOR_BG_MAGENTA;
                                }
                                else if ('6' == p[1])
                                {
                                    s = (UTF8 *)COLOR_BG_CYAN;
                                }
                                else if ('7' == p[1])
                                {
                                    s = (UTF8 *)COLOR_BG_WHITE;
                                }
                            }
                            break;
                        }

                        if (NULL != s)
                        {
                            utf8_safe_chr(s, aBuffer, &pBuffer);
                        }
                        p = r + 1;
                    }

                    // Eat trailing terminator.
                    //
                    p = q + 1;
                }
                else
                {
                    // Skip to end of mal-formed ANSI sequence.
                    //
                    p = q;
                }
            }
        }
    }
    *pBuffer = '\0';
    *pn = pBuffer - aBuffer;
    return aBuffer;
}

// mux_strncpy: Copies up to specified number of chars from source.
// Note: unlike strncpy(), this null-terminates after copying.
//
void mux_strncpy(UTF8 *dest, const UTF8 *src, size_t nSizeOfBuffer)
{
    if (src == NULL) return;

    UTF8 *tp = dest;
    UTF8 *maxtp = dest + nSizeOfBuffer;
    while (tp < maxtp && *src)
    {
        *tp++ = *src++;
    }
    *tp = '\0';
}

bool matches_exit_from_list(UTF8 *str, const UTF8 *pattern)
{
    UTF8 *s;

    while (*pattern)
    {
        for (s = str;   // check out this one
             ( *s
             && (mux_tolower(*s) == mux_tolower(*pattern))
             && *pattern
             && (*pattern != EXIT_DELIMITER));
             s++, pattern++) ;

        // Did we match it all?
        //
        if (*s == '\0')
        {
            // Make sure nothing afterwards
            //
            while (mux_isspace(*pattern))
            {
                pattern++;
            }

            // Did we get it?
            //
            if (  !*pattern
               || (*pattern == EXIT_DELIMITER))
            {
                return true;
            }
        }
        // We didn't get it, find next string to test
        //
        while (  *pattern
              && *pattern++ != EXIT_DELIMITER)
        {
            ; // Nothing.
        }
        while (mux_isspace(*pattern))
        {
            pattern++;
        }
    }
    return false;
}

const UTF8 Digits100[201] =
"001020304050607080900111213141516171819102122232425262728292\
031323334353637383930414243444546474849405152535455565758595\
061626364656667686960717273747576777879708182838485868788898\
09192939495969798999";

size_t mux_ltoa(long val, UTF8 *buf)
{
    UTF8 *p = buf;

    if (val < 0)
    {
        *p++ = '-';
        val = -val;
    }
    unsigned long uval = (unsigned long)val;

    UTF8 *q = p;

    const UTF8 *z;
    while (uval > 99)
    {
        z = Digits100 + ((uval % 100) << 1);
        uval /= 100;
        *p++ = *z;
        *p++ = *(z+1);
    }
    z = Digits100 + (uval << 1);
    *p++ = *z;
    if (uval > 9)
    {
        *p++ = *(z+1);
    }

    size_t nLength = p - buf;
    *p-- = '\0';

    // The digits are in reverse order with a possible leading '-'
    // if the value was negative. q points to the first digit,
    // and p points to the last digit.
    //
    while (q < p)
    {
        // Swap characters are *p and *q
        //
        UTF8 temp = *p;
        *p = *q;
        *q = temp;

        // Move p and first digit towards the middle.
        //
        --p;
        ++q;

        // Stop when we reach or pass the middle.
        //
    }
    return nLength;
}

UTF8 *mux_ltoa_t(long val)
{
    static UTF8 buff[I32BUF_SIZE];
    mux_ltoa(val, buff);
    return buff;
}

void safe_ltoa(long val, UTF8 *buff, UTF8 **bufc)
{
    static UTF8 temp[I32BUF_SIZE];
    size_t n = mux_ltoa(val, temp);
    safe_copy_buf_ascii(temp, n, buff, bufc);
}

size_t mux_i64toa(INT64 val, UTF8 *buf)
{
    UTF8 *p = buf;

    if (val < 0)
    {
        *p++ = '-';
        val = -val;
    }
    UINT64 uval = (UINT64)val;

    UTF8 *q = p;

    const UTF8 *z;
    while (uval > 99)
    {
        z = Digits100 + ((uval % 100) << 1);
        uval /= 100;
        *p++ = *z;
        *p++ = *(z+1);
    }
    z = Digits100 + (uval << 1);
    *p++ = *z;
    if (uval > 9)
    {
        *p++ = *(z+1);
    }

    size_t nLength = p - buf;
    *p-- = '\0';

    // The digits are in reverse order with a possible leading '-'
    // if the value was negative. q points to the first digit,
    // and p points to the last digit.
    //
    while (q < p)
    {
        // Swap characters are *p and *q
        //
        UTF8 temp = *p;
        *p = *q;
        *q = temp;

        // Move p and first digit towards the middle.
        //
        --p;
        ++q;

        // Stop when we reach or pass the middle.
        //
    }
    return nLength;
}

UTF8 *mux_i64toa_t(INT64 val)
{
    static UTF8 buff[I64BUF_SIZE];
    mux_i64toa(val, buff);
    return buff;
}

void safe_i64toa(INT64 val, UTF8 *buff, UTF8 **bufc)
{
    static UTF8 temp[I64BUF_SIZE];
    size_t n = mux_i64toa(val, temp);
    safe_copy_buf_ascii(temp, n, buff, bufc);
}

const UTF8 TableATOI[16][10] =
{
    {  0,  1,  2,  3,  4,  5,  6,  7,  8,  9},
    { 10, 11, 12, 13, 14, 15, 16, 17, 18, 19},
    { 20, 21, 22, 23, 24, 25, 26, 27, 28, 29},
    { 30, 31, 32, 33, 34, 35, 36, 37, 38, 39},
    { 40, 41, 42, 43, 44, 45, 46, 47, 48, 49},
    { 50, 51, 52, 53, 54, 55, 56, 57, 58, 59},
    { 60, 61, 62, 63, 64, 65, 66, 67, 68, 69},
    { 70, 71, 72, 73, 74, 75, 76, 77, 78, 79},
    { 80, 81, 82, 83, 84, 85, 86, 87, 88, 89},
    { 90, 91, 92, 93, 94, 95, 96, 97, 98, 99}
};

long mux_atol(const UTF8 *pString)
{
    long sum = 0;
    int LeadingCharacter = 0;

    // Convert ASCII digits
    //
    unsigned int c1;
    unsigned int c0 = pString[0];
    if (!mux_isdigit(c0))
    {
        while (mux_isspace(pString[0]))
        {
            pString++;
        }
        LeadingCharacter = pString[0];
        if (  LeadingCharacter == '-'
           || LeadingCharacter == '+')
        {
            pString++;
        }
        c0 = pString[0];
        if (!mux_isdigit(c0))
        {
            return 0;
        }
    }

    do
    {
        c1 = pString[1];
        if (mux_isdigit(c1))
        {
            sum = 100 * sum + TableATOI[c0-'0'][c1-'0'];
            pString += 2;
        }
        else
        {
            sum = 10 * sum + (c0-'0');
            break;
        }
    } while (mux_isdigit(c0 = pString[0]));

    // Interpret sign
    //
    if (LeadingCharacter == '-')
    {
        sum = -sum;
    }
    return sum;
}

INT64 mux_atoi64(const UTF8 *pString)
{
    INT64 sum = 0;
    int LeadingCharacter = 0;

    // Convert ASCII digits
    //
    unsigned int c1;
    unsigned int c0 = pString[0];
    if (!mux_isdigit(c0))
    {
        while (mux_isspace(pString[0]))
        {
            pString++;
        }
        LeadingCharacter = pString[0];
        if (  LeadingCharacter == '-'
           || LeadingCharacter == '+')
        {
            pString++;
        }
        c0 = pString[0];
        if (!mux_isdigit(c0))
        {
            return 0;
        }
    }

    do
    {
        c1 = pString[1];
        if (mux_isdigit(c1))
        {
            sum = 100 * sum + TableATOI[c0-'0'][c1-'0'];
            pString += 2;
        }
        else
        {
            sum = 10 * sum + (c0-'0');
            break;
        }
    } while (mux_isdigit(c0 = pString[0]));

    // Interpret sign
    //
    if (LeadingCharacter == '-')
    {
        sum = -sum;
    }
    return sum;
}

// Floating-point strings match one of the following patterns:
//
// [+-]?[0-9]?(.[0-9]+)([eE][+-]?[0-9]{1,3})?
// [+-]?[0-9]+(.[0-9]?)([eE][+-]?[0-9]{1,3})?
// +Inf
// -Inf
// Ind
// NaN
//
bool ParseFloat(PARSE_FLOAT_RESULT *pfr, const UTF8 *str, bool bStrict)
{
    memset(pfr, 0, sizeof(PARSE_FLOAT_RESULT));

    // Parse Input
    //
    UTF8 ch;
    pfr->pMeat = str;
    if (  !mux_isdigit(*str)
       && *str != '.')
    {
        while (mux_isspace(*str))
        {
            str++;
        }

        pfr->pMeat = str;
        if (*str == '-')
        {
            pfr->iLeadingSign = '-';
            str++;
        }
        else if (*str == '+')
        {
            pfr->iLeadingSign = '+';
            str++;
        }

        if (  !mux_isdigit(*str)
           && *str != '.')
        {
            // Look for three magic strings.
            //
            ch = mux_toupper(str[0]);
            if (ch == 'I')
            {
                // Could be 'Inf' or 'Ind'
                //
                ch = mux_toupper(str[1]);
                if (ch == 'N')
                {
                    ch = mux_toupper(str[2]);
                    if (ch == 'F')
                    {
                        // Inf
                        //
                        if (pfr->iLeadingSign == '-')
                        {
                            pfr->iString = IEEE_MAKE_NINF;
                        }
                        else
                        {
                            pfr->iString = IEEE_MAKE_PINF;
                        }
                        str += 3;
                        goto LastSpaces;
                    }
                    else if (ch == 'D')
                    {
                        // Ind
                        //
                        pfr->iString = IEEE_MAKE_IND;
                        str += 3;
                        goto LastSpaces;
                    }
                }
            }
            else if (ch == 'N')
            {
                // Could be 'Nan'
                //
                ch = mux_toupper(str[1]);
                if (ch == 'A')
                {
                    ch = mux_toupper(str[2]);
                    if (ch == 'N')
                    {
                        // Nan
                        //
                        pfr->iString = IEEE_MAKE_NAN;
                        str += 3;
                        goto LastSpaces;
                    }
                }
            }
            return false;
        }
    }

    // At this point, we have processed the leading sign, handled all
    // the magic strings, skipped the leading spaces, and best of all
    // we either have a digit or a decimal point.
    //
    pfr->pDigitsA = str;
    while (mux_isdigit(*str))
    {
        pfr->nDigitsA++;
        str++;
    }

    if (*str == '.')
    {
        str++;
    }

    pfr->pDigitsB = str;
    while (mux_isdigit(*str))
    {
        pfr->nDigitsB++;
        str++;
    }

    if (  pfr->nDigitsA == 0
       && pfr->nDigitsB == 0)
    {
        return false;
    }

    ch = mux_toupper(*str);
    if (ch == 'E')
    {
        // There is an exponent portion.
        //
        str++;
        if (*str == '-')
        {
            pfr->iExponentSign = '-';
            str++;
        }
        else if (*str == '+')
        {
            pfr->iExponentSign = '+';
            str++;
        }
        pfr->pDigitsC = str;
        while (mux_isdigit(*str))
        {
            pfr->nDigitsC++;
            str++;
        }

        if (  pfr->nDigitsC < 1
           || 4 < pfr->nDigitsC)
        {
            return false;
        }
    }

LastSpaces:

    pfr->nMeat = str - pfr->pMeat;

    // Trailing spaces.
    //
    while (mux_isspace(*str))
    {
        str++;
    }

    if (bStrict)
    {
        return (!*str);
    }
    else
    {
        return true;
    }
}

#define ATOF_LIMIT 100
static const double powerstab[10] =
{
            1.0,
           10.0,
          100.0,
         1000.0,
        10000.0,
       100000.0,
      1000000.0,
     10000000.0,
    100000000.0,
   1000000000.0
};

double mux_atof(const UTF8 *szString, bool bStrict)
{
    PARSE_FLOAT_RESULT pfr;
    if (!ParseFloat(&pfr, szString, bStrict))
    {
        return 0.0;
    }

    if (pfr.iString)
    {
        // Return the double value which corresponds to the
        // string when HAVE_IEEE_FORMAT.
        //
#ifdef HAVE_IEEE_FP_FORMAT
        return MakeSpecialFloat(pfr.iString);
#else // HAVE_IEEE_FP_FORMAT
        return 0.0;
#endif // HAVE_IEEE_FP_FORMAT
    }

    // See if we can shortcut the decoding process.
    //
    double ret;
    if (  pfr.nDigitsA <= 9
       && pfr.nDigitsC == 0)
    {
        if (pfr.nDigitsB <= 9)
        {
            if (pfr.nDigitsB == 0)
            {
                // This 'floating-point' number is just an integer.
                //
                ret = (double)mux_atol(pfr.pDigitsA);
            }
            else
            {
                // This 'floating-point' number is fixed-point.
                //
                double rA = (double)mux_atol(pfr.pDigitsA);
                double rB = (double)mux_atol(pfr.pDigitsB);
                double rScale = powerstab[pfr.nDigitsB];
                ret = rA + rB/rScale;

                // As it is, ret is within a single bit of what a
                // a call to atof would return. However, we can
                // achieve that last lowest bit of precision by
                // computing a residual.
                //
                double residual = (ret - rA)*rScale;
                ret += (rB - residual)/rScale;
            }
            if (pfr.iLeadingSign == '-')
            {
                ret = -ret;
            }
            return ret;
        }
    }

    const UTF8 *p = pfr.pMeat;
    size_t n = pfr.nMeat;

    // We need to protect certain libraries from going nuts from being
    // force fed lots of ASCII.
    //
    UTF8 *pTmp = NULL;
    if (n > ATOF_LIMIT)
    {
        pTmp = alloc_lbuf("mux_atof");
        memcpy(pTmp, p, ATOF_LIMIT);
        pTmp[ATOF_LIMIT] = '\0';
        p = pTmp;
    }

    ret = mux_strtod(p, NULL);

    if (pTmp)
    {
        free_lbuf(pTmp);
    }

    return ret;
}

UTF8 *mux_ftoa(double r, bool bRounded, int frac)
{
    static UTF8 buffer[100];
    UTF8 *q = buffer;
    UTF8 *rve = NULL;
    int iDecimalPoint = 0;
    int bNegative = 0;
    int mode = 0;
    int nRequestMaximum = 50;
    const int nRequestMinimum = -20;
    int nRequest = nRequestMaximum;

    // If float_precision is enabled, let it override nRequestMaximum.
    //
    if (0 <= mudconf.float_precision)
    {
        mode = 3;
        if (mudconf.float_precision < nRequestMaximum)
        {
            nRequestMaximum = mudconf.float_precision;
            nRequest        = mudconf.float_precision;
        }
    }

    if (bRounded)
    {
        mode = 3;
        nRequest = frac;
        if (nRequestMaximum < nRequest)
        {
            nRequest = nRequestMaximum;
        }
        else if (nRequest < nRequestMinimum)
        {
            nRequest = nRequestMinimum;
        }
    }

    UTF8 *p = mux_dtoa(r, mode, nRequest, &iDecimalPoint, &bNegative, &rve);
    size_t nSize = rve - p;
    if (nSize > 50)
    {
        nSize = 50;
    }

    if (bNegative)
    {
        *q++ = '-';
    }

    if (iDecimalPoint == 9999)
    {
        // Inf or NaN
        //
        memcpy(q, p, nSize);
        q += nSize;
    }
    else if (nSize <= 0)
    {
        // Zero
        //
        if (bNegative)
        {
            // If we laid down a minus sign, we should remove it.
            //
            q--;
        }
        *q++ = '0';
        if (  bRounded
           && 0 < nRequest)
        {
            *q++ = '.';
            memset(q, '0', nRequest);
            q += nRequest;
        }
    }
    else if (  iDecimalPoint <= -6
            || 18 <= iDecimalPoint)
    {
        *q++ = *p++;
        if (1 < nSize)
        {
            *q++ = '.';
            memcpy(q, p, nSize-1);
            q += nSize-1;
        }
        *q++ = 'E';
        q += mux_ltoa(iDecimalPoint-1, q);
    }
    else if (iDecimalPoint <= 0)
    {
        // iDecimalPoint = -5 to 0
        //
        *q++ = '0';
        *q++ = '.';
        memset(q, '0', -iDecimalPoint);
        q += -iDecimalPoint;
        memcpy(q, p, nSize);
        q += nSize;
        if (bRounded)
        {
            size_t nPad = nRequest - (nSize - iDecimalPoint);
            if (0 < nPad)
            {
                memset(q, '0', nPad);
                q += nPad;
            }
        }
    }
    else
    {
        // iDecimalPoint = 1 to 17
        //
        if (nSize <= static_cast<size_t>(iDecimalPoint))
        {
            memcpy(q, p, nSize);
            q += nSize;
            memset(q, '0', iDecimalPoint - nSize);
            q += iDecimalPoint - nSize;
            if (  bRounded
               && 0 < nRequest)
            {
                *q++ = '.';
                memset(q, '0', nRequest);
                q += nRequest;
            }
        }
        else
        {
            memcpy(q, p, iDecimalPoint);
            q += iDecimalPoint;
            p += iDecimalPoint;
            *q++ = '.';
            memcpy(q, p, nSize - iDecimalPoint);
            q += nSize - iDecimalPoint;
            if (bRounded)
            {
                size_t nPad = nRequest - (nSize - iDecimalPoint);
                if (0 < nPad)
                {
                    memset(q, '0', nPad);
                    q += nPad;
                }
            }
        }
    }
    *q = '\0';
    return buffer;
}

bool is_integer(const UTF8 *str, int *pDigits)
{
    LBUF_OFFSET i = 0;
    int nDigits = 0;
    if (pDigits)
    {
        *pDigits = 0;
    }

    // Leading spaces.
    //
    while (mux_isspace(str[i]))
    {
        i++;
    }

    // Leading minus or plus
    //
    if (str[i] == '-' || str[i] == '+')
    {
        i++;

        // Just a sign by itself isn't an integer.
        //
        if (!str[i])
        {
            return false;
        }
    }

    // Need at least 1 integer
    //
    if (!mux_isdigit(str[i]))
    {
        return false;
    }

    // The number (int)
    //
    do
    {
        i++;
        nDigits++;
    } while (mux_isdigit(str[i]));

    if (pDigits)
    {
        *pDigits = nDigits;
    }

    // Trailing Spaces.
    //
    while (mux_isspace(str[i]))
    {
        i++;
    }

    return (!str[i]);
}

bool is_rational(const UTF8 *str)
{
    LBUF_OFFSET i = 0;

    // Leading spaces.
    //
    while (mux_isspace(str[i]))
    {
        i++;
    }

    // Leading minus or plus sign.
    //
    if (str[i] == '-' || str[i] == '+')
    {
        i++;

        // But not if just a sign.
        //
        if (!str[i])
        {
            return false;
        }
    }

    // Need at least one digit.
    //
    bool got_one = false;
    if (mux_isdigit(str[i]))
    {
        got_one = true;
    }

    // The number (int)
    //
    while (mux_isdigit(str[i]))
    {
        i++;
    }

    // Decimal point.
    //
    if (str[i] == '.')
    {
        i++;
    }

    // Need at least one digit
    //
    if (mux_isdigit(str[i]))
    {
        got_one = true;
    }

    if (!got_one)
    {
        return false;
    }

    // The number (fract)
    //
    while (mux_isdigit(str[i]))
    {
        i++;
    }

    // Trailing spaces.
    //
    while (mux_isspace(str[i]))
    {
        i++;
    }

    // There must be nothing else after the trailing spaces.
    //
    return (!str[i]);
}

bool is_real(const UTF8 *str)
{
    PARSE_FLOAT_RESULT pfr;
    return ParseFloat(&pfr, str);
}

// mux_strtok_src, mux_strtok_ctl, mux_strtok_parse.
//
// These three functions work together to replace the functionality of the
// strtok() C runtime library function. Call mux_strtok_src() first with
// the string to parse, then mux_strtok_ctl() with the control
// characters, and finally mux_strtok_parse() to parse out the tokens.
//
// You may call mux_strtok_ctl() to change the set of control characters
// between mux_strtok_parse() calls, however keep in mind that the parsing
// may not occur how you intend it to as mux_strtok_parse() does not
// consume -all- of the controlling delimiters that separate two tokens.
// It consumes only the first one.
//
void mux_strtok_src(MUX_STRTOK_STATE *tts, UTF8 *arg_pString)
{
    if (!tts || !arg_pString) return;

    // Remember the string to parse.
    //
    tts->pString = arg_pString;
}

void mux_strtok_ctl(MUX_STRTOK_STATE *tts, const UTF8 *pControl)
{
    if (!tts || !pControl) return;

    // No character is a control character.
    //
    memset(tts->aControl, 0, sizeof(tts->aControl));

    // The NULL character is always a control character.
    //
    tts->aControl[0] = 1;

    // Record the user-specified control characters.
    //
    while (*pControl)
    {
        tts->aControl[(unsigned char)*pControl] = 1;
        pControl++;
    }
}

UTF8 *mux_strtok_parseLEN(MUX_STRTOK_STATE *tts, size_t *pnLen)
{
    *pnLen = 0;
    if (!tts)
    {
        return NULL;
    }
    UTF8 *p = tts->pString;
    if (!p)
    {
        return NULL;
    }

    // Skip over leading control characters except for the NUL character.
    //
    while (tts->aControl[(unsigned char)*p] && *p)
    {
        p++;
    }

    UTF8 *pReturn = p;

    // Skip over non-control characters.
    //
    while (tts->aControl[(unsigned char)*p] == 0)
    {
        p++;
    }

    // What is the length of this token?
    //
    *pnLen = p - pReturn;

    // Terminate the token with a NUL.
    //
    if (p[0])
    {
        // We found a non-NUL delimiter, so the next call will begin parsing
        // on the character after this one.
        //
        tts->pString = p+1;
    }
    else
    {
        // We hit the end of the string, so the end of the string is where
        // the next call will begin.
        //
        tts->pString = p;
    }

    // Did we find a token?
    //
    if (*pnLen > 0)
    {
        return pReturn;
    }
    else
    {
        return NULL;
    }
}

UTF8 *mux_strtok_parse(MUX_STRTOK_STATE *tts)
{
    size_t nLen;
    UTF8 *p = mux_strtok_parseLEN(tts, &nLen);
    if (p)
    {
        p[nLen] = '\0';
    }
    return p;
}

// This function will filter out any characters in the the set from
// the string.
//
UTF8 *RemoveSetOfCharacters(UTF8 *pString, const UTF8 *pSetToRemove)
{
    static UTF8 Buffer[LBUF_SIZE];
    UTF8 *pBuffer = Buffer;

    size_t nLen;
    size_t nLeft = sizeof(Buffer) - 1;
    UTF8 *p;
    MUX_STRTOK_STATE tts;
    mux_strtok_src(&tts, pString);
    mux_strtok_ctl(&tts, pSetToRemove);
    for ( p = mux_strtok_parseLEN(&tts, &nLen);
          p && nLeft;
          p = mux_strtok_parseLEN(&tts, &nLen))
    {
        if (nLeft < nLen)
        {
            nLen = nLeft;
        }
        memcpy(pBuffer, p, nLen);
        pBuffer += nLen;
        nLeft -= nLen;
    }
    *pBuffer = '\0';
    return Buffer;
}

void ItemToList_Init(ITL *p, UTF8 *arg_buff, UTF8 **arg_bufc,
    UTF8 arg_chPrefix, UTF8 arg_chSep)
{
    p->bFirst = true;
    p->chPrefix = arg_chPrefix;
    p->chSep = arg_chSep;
    p->buff = arg_buff;
    p->bufc = arg_bufc;
    p->nBufferAvailable = LBUF_SIZE - (*arg_bufc - arg_buff) - 1;
}

bool ItemToList_AddInteger(ITL *pContext, int i)
{
    UTF8 smbuf[SBUF_SIZE];
    UTF8 *p = smbuf;
    if (  !pContext->bFirst
       && pContext->chSep)
    {
        *p++ = pContext->chSep;
    }
    if (pContext->chPrefix)
    {
        *p++ = pContext->chPrefix;
    }
    p += mux_ltoa(i, p);
    size_t nLen = p - smbuf;
    if (nLen > pContext->nBufferAvailable)
    {
        // Out of room.
        //
        return false;
    }
    if (pContext->bFirst)
    {
        pContext->bFirst = false;
    }
    memcpy(*(pContext->bufc), smbuf, nLen);
    *(pContext->bufc) += nLen;
    pContext->nBufferAvailable -= nLen;
    return true;
}

bool ItemToList_AddInteger64(ITL *pContext, INT64 i64)
{
    UTF8 smbuf[SBUF_SIZE];
    UTF8 *p = smbuf;
    if (  !pContext->bFirst
       && pContext->chSep)
    {
        *p++ = pContext->chSep;
    }
    if (pContext->chPrefix)
    {
        *p++ = pContext->chPrefix;
    }
    p += mux_i64toa(i64, p);
    size_t nLen = p - smbuf;
    if (nLen > pContext->nBufferAvailable)
    {
        // Out of room.
        //
        return false;
    }
    if (pContext->bFirst)
    {
        pContext->bFirst = false;
    }
    memcpy(*(pContext->bufc), smbuf, nLen);
    *(pContext->bufc) += nLen;
    pContext->nBufferAvailable -= nLen;
    return true;
}

bool ItemToList_AddStringLEN(ITL *pContext, size_t nStr, const UTF8 *pStr)
{
    size_t nLen = nStr;
    if (  !pContext->bFirst
       && pContext->chSep)
    {
        nLen++;
    }
    if (pContext->chPrefix)
    {
        nLen++;
    }
    if (nLen > pContext->nBufferAvailable)
    {
        // Out of room.
        //
        return false;
    }
    UTF8 *p = *(pContext->bufc);
    if (pContext->bFirst)
    {
        pContext->bFirst = false;
    }
    else if (pContext->chSep)
    {
        *p++ = pContext->chSep;
    }
    if (pContext->chPrefix)
    {
        *p++ = pContext->chPrefix;
    }
    memcpy(p, pStr, nStr);
    *(pContext->bufc) += nLen;
    pContext->nBufferAvailable -= nLen;
    return true;
}

bool ItemToList_AddString(ITL *pContext, const UTF8 *pStr)
{
    size_t nStr = strlen((const char *)pStr);
    return ItemToList_AddStringLEN(pContext, nStr, pStr);
}

void ItemToList_Final(ITL *pContext)
{
    **(pContext->bufc) = '\0';
}

// mux_stricmp - Compare two strings ignoring case.
//
int mux_stricmp(const UTF8 *a, const UTF8 *b)
{
    while (  *a
          && *b
          && mux_tolower(*a) == mux_tolower(*b))
    {
        a++;
        b++;
    }
    int c1 = mux_tolower(*a);
    int c2 = mux_tolower(*b);
    if (c1 < c2)
    {
        return -1;
    }
    else if (c1 > c2)
    {
        return 1;
    }
    else
    {
        return 0;
    }
}

// mux_memicmp - Compare two buffers ignoring case.
//
int mux_memicmp(const void *p1_arg, const void *p2_arg, size_t n)
{
    UTF8 *p1 = (UTF8 *)p1_arg;
    UTF8 *p2 = (UTF8 *)p2_arg;
    while (  n
          && mux_tolower(*p1) == mux_tolower(*p2))
    {
        n--;
        p1++;
        p2++;
    }
    if (n)
    {
        int c1 = mux_tolower(*p1);
        int c2 = mux_tolower(*p2);
        if (c1 < c2)
        {
            return -1;
        }
        else if (c1 > c2)
        {
            return 1;
        }
    }
    return 0;
}

// mux_strlwr - Convert string to all lower case.
//
void mux_strlwr(UTF8 *a)
{
    while (*a)
    {
        *a = mux_tolower(*a);
        a++;
    }
}

// mux_strupr - Convert string to all upper case.
//
void mux_strupr(UTF8 *a)
{
    while (*a)
    {
        *a = mux_toupper(*a);
        a++;
    }
}


// mux_vsnprintf - Is an sprintf-like function that will not overflow
// a buffer of specific size. The size is give by count, and count
// should be chosen to include the '\0' termination.
//
// Returns: A number from 0 to count-1 that is the string length of
// the returned (possibly truncated) buffer.
//
size_t DCL_CDECL mux_vsnprintf(UTF8 *buff, size_t count, const char *fmt, va_list va)
{
    // From the manuals:
    //
    // vsnprintf returns the number of characters written, not
    // including the terminating '\0' character.
    //
    // It returns a -1 if an output error occurs.
    //
    // It can return a number larger than the size of the buffer
    // on some systems to indicate how much space it -would- have taken
    // if not limited by the request.
    //
    // On Win32, it can fill the buffer completely without a
    // null-termination and return -1.

    // To favor the Unix case, if there is an output error, but
    // vsnprint doesn't touch the buffer, we avoid undefined trash by
    // null-terminating the buffer to zero-length before the call.
    // Not sure that this happens, but it's a cheap precaution.
    //
    buff[0] = '\0';

    // If Unix version does start touching the buffer, null-terminates,
    // and returns -1, we are still safe. However, if Unix version
    // touches the buffer writes garbage, and then returns -1, we may
    // pass garbage, but this possibility seems very unlikely.
    //
    size_t len;
#if defined(WIN32)
#if !defined(__INTEL_COMPILER) && (_MSC_VER >= 1400)
    int cc = vsnprintf_s((char *)buff, count, _TRUNCATE, fmt, va);
#else // _MSC_VER
    int cc = _vsnprintf((char *)buff, count, fmt, va);
#endif // _MSC_VER
#else // WIN32
#ifdef NEED_VSPRINTF_DCL
    extern char *vsprintf(char *, char *, va_list);
#endif // NEED_VSPRINTF_DCL

    int cc = vsnprintf((char *)buff, count, fmt, va);
#endif // WIN32
    if (0 <= cc && static_cast<size_t>(cc) <= count-1)
    {
        len = cc;
    }
    else
    {
        if (buff[0] == '\0')
        {
            // vsnprintf did not touch the buffer.
            //
            len = 0;
        }
        else
        {
            len = count-1;
        }
    }
    buff[len] = '\0';
    return len;
}

void DCL_CDECL mux_sprintf(UTF8 *buff, size_t count, const char *fmt, ...)
{
    va_list ap;
    va_start(ap, fmt);
    (void)mux_vsnprintf(buff, count, fmt, ap);
    va_end(ap);
}

// This function acts like fgets except that any data on the end of the
// line past the buffer size is truncated instead of being returned on
// the next call.
//
size_t GetLineTrunc(UTF8 *Buffer, size_t nBuffer, FILE *fp)
{
    size_t lenBuffer = 0;
    if (fgets((char *)Buffer, static_cast<int>(nBuffer), fp))
    {
        lenBuffer = strlen((char *)Buffer);
    }
    if (lenBuffer <= 0)
    {
        memcpy(Buffer, "\n", 2);
        return 1;
    }
    if (Buffer[lenBuffer-1] != '\n')
    {
        // The line was too long for the buffer. Continue reading until the
        // end of the line.
        //
        UTF8 TruncBuffer[SBUF_SIZE];
        size_t lenTruncBuffer;
        do
        {
            if (!fgets((char *)TruncBuffer, sizeof(TruncBuffer), fp))
            {
                break;
            }
            lenTruncBuffer = strlen((char *)TruncBuffer);
        }
        while (TruncBuffer[lenTruncBuffer-1] != '\n');
    }
    return lenBuffer;
}

// Method: Boyer-Moore-Horspool
//
// This method is a simplification of the Boyer-Moore String Searching
// Algorithm, but a useful one. It does not require as much temporary
// storage, and the setup costs are not as high as the full Boyer-Moore.
//
// If we were searching megabytes of data instead of 8KB at most, then
// the full Boyer-Moore would make more sense.
//
#define BMH_LARGE 32767
void BMH_Prepare(BMH_State *bmhs, size_t nPat, const UTF8 *pPat)
{
    if (nPat <= 0)
    {
        return;
    }
    size_t k;
    for (k = 0; k < 256; k++)
    {
        bmhs->m_d[k] = nPat;
    }

    UTF8 chLastPat = pPat[nPat-1];
    bmhs->m_skip2 = nPat;
    for (k = 0; k < nPat - 1; k++)
    {
        bmhs->m_d[(unsigned char)pPat[k]] = nPat - k - 1;
        if (pPat[k] == chLastPat)
        {
            bmhs->m_skip2 = nPat - k - 1;
        }
    }
    bmhs->m_d[(unsigned char)chLastPat] = BMH_LARGE;
}

bool BMH_Execute(BMH_State *bmhs, size_t *pnMatched, size_t nPat, const UTF8 *pPat, size_t nSrc, const UTF8 *pSrc)
{
    if (nPat <= 0)
    {
        return false;
    }
    for (size_t i = nPat-1; i < nSrc; i += bmhs->m_skip2)
    {
        while ((i += bmhs->m_d[(unsigned char)(pSrc[i])]) < nSrc)
        {
            ; // Nothing.
        }
        if (i < BMH_LARGE)
        {
            break;
        }
        i -= BMH_LARGE;
        int j = static_cast<int>(nPat - 1);
        const UTF8 *s = pSrc + (i - j);
        while (--j >= 0 && s[j] == pPat[j])
        {
            ; // Nothing.
        }
        if (j < 0)
        {
            *pnMatched = s-pSrc;
            return true;
        }
    }
    return false;
}

bool BMH_StringSearch(size_t *pnMatched, size_t nPat, const UTF8 *pPat, size_t nSrc, const UTF8 *pSrc)
{
    BMH_State bmhs;
    BMH_Prepare(&bmhs, nPat, pPat);
    return BMH_Execute(&bmhs, pnMatched, nPat, pPat, nSrc, pSrc);
}

void BMH_PrepareI(BMH_State *bmhs, size_t nPat, const UTF8 *pPat)
{
    if (nPat <= 0)
    {
        return;
    }
    size_t k;
    for (k = 0; k < 256; k++)
    {
        bmhs->m_d[k] = nPat;
    }

    UTF8 chLastPat = pPat[nPat-1];
    bmhs->m_skip2 = nPat;
    for (k = 0; k < nPat - 1; k++)
    {
        bmhs->m_d[mux_toupper(pPat[k])] = nPat - k - 1;
        bmhs->m_d[mux_tolower(pPat[k])] = nPat - k - 1;
        if (pPat[k] == chLastPat)
        {
            bmhs->m_skip2 = nPat - k - 1;
        }
    }
    bmhs->m_d[mux_toupper(chLastPat)] = BMH_LARGE;
    bmhs->m_d[mux_tolower(chLastPat)] = BMH_LARGE;
}

bool BMH_ExecuteI(BMH_State *bmhs, size_t *pnMatched, size_t nPat, const UTF8 *pPat, size_t nSrc, const UTF8 *pSrc)
{
    if (nPat <= 0)
    {
        return false;
    }
    for (size_t i = nPat-1; i < nSrc; i += bmhs->m_skip2)
    {
        while ((i += bmhs->m_d[(unsigned char)(pSrc[i])]) < nSrc)
        {
            ; // Nothing.
        }
        if (i < BMH_LARGE)
        {
            break;
        }
        i -= BMH_LARGE;
        int j = static_cast<int>(nPat - 1);
        const UTF8 *s = pSrc + (i - j);
        while (  --j >= 0
              && mux_toupper(s[j]) == mux_toupper(pPat[j]))
        {
            ; // Nothing.
        }
        if (j < 0)
        {
            *pnMatched = s-pSrc;
            return true;
        }
    }
    return false;
}

bool BMH_StringSearchI(size_t *pnMatched, size_t nPat, const UTF8 *pPat, size_t nSrc, const UTF8 *pSrc)
{
    BMH_State bmhs;
    BMH_PrepareI(&bmhs, nPat, pPat);
    return BMH_ExecuteI(&bmhs, pnMatched, nPat, pPat, nSrc, pSrc);
}

// ---------------------------------------------------------------------------
// cf_art_except:
//
// Add an article rule to the ruleset.
//

CF_HAND(cf_art_rule)
{
    UNUSED_PARAMETER(pExtra);
    UNUSED_PARAMETER(nExtra);

    UTF8* pCurrent = str;

    while (mux_isspace(*pCurrent))
    {
        pCurrent++;
    }
    UTF8* pArticle = pCurrent;
    while (  !mux_isspace(*pCurrent)
          && *pCurrent != '\0')
    {
        pCurrent++;
    }
    if (*pCurrent == '\0')
    {
        cf_log_syntax(player, cmd, "No article or regexp specified.");
        return -1;
    }

    bool bUseAn = false;
    bool bOkay = false;

    if (pCurrent - pArticle <= 2)
    {
        if (mux_tolower(pArticle[0]) == 'a')
        {
            if (mux_tolower(pArticle[1]) == 'n')
            {
                bUseAn = true;
                bOkay = true;
            }

            if (mux_isspace(pArticle[1]))
            {
                bOkay = true;
            }
        }
    }

    if (!bOkay)
    {
        *pCurrent = '\0';
        cf_log_syntax(player, cmd, "Invalid article '%s'.", pArticle);
        return -1;
    }

    while (mux_isspace(*pCurrent))
    {
        pCurrent++;
    }

    if (*pCurrent == '\0')
    {
        cf_log_syntax(player, cmd, "No regexp specified.");
        return -1;
    }

    const char *errptr;
    int erroffset;
    pcre* reNewRegexp = pcre_compile((char *)pCurrent, 0, &errptr, &erroffset, NULL);
    if (!reNewRegexp)
    {
        cf_log_syntax(player, cmd, "Error processing regexp '%s':.",
              pCurrent, errptr);
        return -1;
    }

    pcre_extra *study = pcre_study(reNewRegexp, 0, &errptr);

    ArtRuleset** arRules = (ArtRuleset **) vp;

    ArtRuleset* arNewRule = NULL;
    try
    {
        arNewRule = new ArtRuleset;
    }
    catch (...)
    {
        ; // Nothing.
    }

    if (NULL != arNewRule)
    {
        // Push new rule at head of list.
        //
        arNewRule->m_pNextRule = *arRules;
        arNewRule->m_bUseAn = bUseAn;
        arNewRule->m_pRegexp = reNewRegexp;
        arNewRule->m_pRegexpStudy = study;
        *arRules = arNewRule;
    }
    else
    {
        MEMFREE(reNewRegexp);
        if (study)
        {
            MEMFREE(study);
        }
        cf_log_syntax(player, cmd, "Out of memory.");
        return -1;
    }

    return 0;
}

#if defined(FIRANMUX)

UTF8 *linewrap_general(UTF8 *strret, int field, const UTF8 *left, const UTF8 *right)
{
    int tabsets[] =
    {
        1, 9, 17, 25, 33, 41, 49, 57, 65, 73, 81
    };

    int leftmargin = 1;
    int rightmargin = 1+field;

    int position = 1;
    int index1 = 0;
    int spacesleft;
    bool space_eaten = true;
    bool line_indented = false;
    bool skip_out = false;

    UTF8 *str = alloc_lbuf("linewrap_desc");
    UTF8 *ostr = str;

    const UTF8 *original = strret;

    for (;;)
    {
        if (!original[index1])
        {
            break;
        }

        if (position == rightmargin)
        {
            line_indented = false;
            space_eaten = false;
            position = leftmargin;

            safe_str(right, str, &ostr);
            safe_str(T("\r\n"), str, &ostr);
            continue;
        }

        if (position == leftmargin)
        {
            if (!line_indented)
            {
                safe_str(left, str, &ostr);
                line_indented = true;
            }

            if (!space_eaten)
            {
                if (' ' == original[index1])
                {
                    index1++;
                    space_eaten = true;
                    continue;
                }
            }
        }

        spacesleft = rightmargin - position;
        int index3 = index1;
        while (original[index3])
        {
            if (ESC_CHAR == original[index3])
            {
                while (  original[index3]
                      && original[index3++] != 'm')
                {
                    ; // Nothing.
                }
                continue;
            }

            if (mux_isspace(original[index3]))
            {
                break;
            }
            spacesleft--;
            index3++;
        }

        if ((index3 - index1) > field)
        {
            skip_out = true;
        }

        if (mux_isspace(original[index1]))
        {
            skip_out = false;
        }

        if (!skip_out)
        {
            if (spacesleft < 0)
            {
                int loop;
                for (loop = rightmargin - position; loop; loop--)
                {
                    safe_chr(' ', str, &ostr);
                }
                position = rightmargin;
                continue;
            }
        }

        switch (original[index1])
        {
        case ESC_CHAR:
            do {
                safe_chr(original[index1], str, &ostr);
            } while (  original[index1++] != 'm'
                    && original[index1]);
            break;

        case '\r':
            {
                int loop;
                for (loop = rightmargin-position; loop; loop--)
                {
                    safe_chr(' ', str, &ostr);
                }
            }
            position = rightmargin;
            index1 = index1 + 2;
            break;

        case '\t':
            {
                int index3 = 0;
                int difference = 0;

                index1++;

                for (;;)
                {
                    if (position < tabsets[index3])
                    {
                        break;
                    }
                    index3++;
                }

                difference = (rightmargin < tabsets[index3]) ?
                    rightmargin - position : tabsets[index3] - position;

                position = (rightmargin < tabsets[index3]) ?
                    rightmargin : tabsets[index3];

                for (; difference; difference--)
                {
                    safe_chr(' ', str, &ostr);
                }

                if (position == rightmargin)
                {
                    continue;
                }
                break;
            }
        default:
            safe_chr(original[index1], str, &ostr);
            index1++;
            position++;
            break;
        }
    }

    int loop;
    for (loop = rightmargin - position; loop; loop--)
    {
        safe_chr(' ', str, &ostr);
    }

    safe_str(right, str, &ostr);
    *ostr = '\0';

    UTF8 *bp = strret;
    safe_str(str, strret, &bp);
    *bp = '\0';

    free_lbuf(str);
    return strret;
}

UTF8 *linewrap_desc(UTF8 *str)
{
    return linewrap_general(str, 70, T("     "), T(""));
}

#endif // FIRANMUX

#ifdef NEW_MUX_STRING
/*! \brief Constructs mux_string object.
 *
 * This constructor puts the mux_string object into an initial, reasonable,
 * and empty state.
 *
 * \return         None.
 */

mux_string::mux_string(void)
{
    m_iLast = CursorMin;
    m_autf[0] = '\0';
    m_ncs = 0;
    m_pcs = NULL;
}

/*! \brief Constructs mux_string object.
 *
 * This is a deep copy constructor.
 *
 * \param sStr     mux_string to be copied.
 * \return         None.
 */

mux_string::mux_string(const mux_string &sStr)
{
    m_ncs = 0;
    m_pcs = NULL;
    import(sStr);
}

/*! \brief Constructs mux_string object from an ANSI string.
 *
 * Parses the given ANSI string into a form which can be more-easily
 * navigated.
 *
 * \param pStr     ANSI string to be parsed.
 * \return         None.
 */

mux_string::mux_string(const UTF8 *pStr)
{
    m_ncs = 0;
    m_pcs = NULL;
    import(pStr);
}

/*! \brief Destructs mux_string object.
 *
 * This destructor deletes the m_pcs array if necessary.
 *
 * \return         None.
 */

mux_string::~mux_string(void)
{
    realloc_m_pcs(0);
}

void mux_string::append(dbref num)
{
    append_TextPlain(T("#"), 1);
    append_TextPlain(mux_ltoa_t(num));
}

void mux_string::append(INT64 iInt)
{
    append_TextPlain(mux_i64toa_t(iInt));
}

void mux_string::append(long lLong)
{
    append_TextPlain(mux_ltoa_t(lLong));
}

/*! \brief Extract and append a range of characters.
 *
 * \param sStr     mux_string from which to extract characters.
 * \param nStart   Beginning of range to extract and apend.
 * \param nLen     Length of range to extract and append.
 * \return         None.
 */

void mux_string::append(const mux_string &sStr, mux_cursor iStart, mux_cursor iEnd)
{
    if (  sStr.m_iLast <= iStart
       || iEnd <= iStart
       || LBUF_SIZE-1 == m_iLast.m_byte)
    {
        // The selection range is empty, or no buffer space is left.
        //
        return;
    }

    if (sStr.m_iLast < iEnd)
    {
        iEnd = sStr.m_iLast;
    }

    if (CursorMax - m_iLast < iEnd - iStart)
    {
        iEnd = iStart + CursorMax - m_iLast;
    }

    LBUF_OFFSET nBytes = iEnd.m_byte - iStart.m_byte;
    LBUF_OFFSET nPoints = iEnd.m_point - iStart.m_point;

    memcpy(m_autf + m_iLast.m_byte, sStr.m_autf + iStart.m_byte, nBytes);

    if (0 != m_ncs)
    {
        realloc_m_pcs(m_iLast.m_point + nPoints);
    }
    else if (0 != sStr.m_ncs)
    {
        realloc_m_pcs(m_iLast.m_point + nPoints);
        for (size_t i = 0; i < m_iLast.m_point; i++)
        {
            m_pcs[i] = CS_NORMAL;
        }
    }

    if (0 != sStr.m_ncs)
    {
        memcpy(m_pcs + m_iLast.m_point, sStr.m_pcs + iStart.m_point, nPoints * sizeof(m_pcs[0]));
    }
    else if (0 != m_ncs)
    {
        for (size_t i = 0; i < nPoints; i++)
        {
            m_pcs[m_iLast.m_byte + i] = CS_NORMAL;
        }
    }

    m_iLast(m_iLast.m_byte + nBytes, m_iLast.m_point + nPoints);
    m_autf[m_iLast.m_byte] = '\0';
}

void mux_string::append(const UTF8 *pStr)
{
    if (  NULL == pStr
       || '\0' == *pStr)
    {
        return;
    }

    size_t nAvail = (LBUF_SIZE-1) - m_iLast.m_byte;
    if (0 == nAvail)
    {
        // No room.
        //
        return;
    }

    size_t nLen = strlen((char *)pStr);
    if (nAvail < nLen)
    {
        nLen = nAvail;
    }

    mux_string *sNew = new mux_string;

    sNew->import(pStr, nLen);

    append(*sNew);
    delete sNew;
}

void mux_string::append(const UTF8 *pStr, size_t nLen)
{
    if (  NULL == pStr
       || '\0' == *pStr)
    {
        return;
    }

    size_t nAvail = (LBUF_SIZE-1) - m_iLast.m_byte;
    if (0 == nAvail)
    {
        // No room.
        //
        return;
    }
    if (nAvail < nLen)
    {
        nLen = nAvail;
    }

    mux_string *sNew = new mux_string;

    sNew->import(pStr, nLen);
    append(*sNew);
    delete sNew;
}

void mux_string::append_TextPlain(const UTF8 *pStr)
{
    if (  '\0' == *pStr
       || LBUF_SIZE-1 <= m_iLast.m_byte)
    {
        // The selection range is empty, or no buffer space is left.
        //
        return;
    }

    size_t nLen = strlen((char *)pStr);

    if ((LBUF_SIZE-1)-m_iLast.m_byte < nLen)
    {
        nLen = (LBUF_SIZE-1)-m_iLast.m_byte;
    }

    memcpy(m_autf + m_iLast.m_byte, pStr, nLen * sizeof(m_autf[0]));

    if (0 != m_ncs)
    {
        realloc_m_pcs(m_iLast.m_point + nLen);
        for (size_t i = 0; i < nLen; i++)
        {
            m_pcs[m_iLast.m_point + i] = CS_NORMAL;
        }
    }

    mux_cursor i = m_iLast, j = i;
    while (  cursor_next(i)
          && i.m_byte <= m_iLast.m_byte + nLen)
    {
        j = i;
    }

    m_iLast = j;
    m_autf[m_iLast.m_byte] = '\0';
}

void mux_string::append_TextPlain(const UTF8 *pStr, size_t nLen)
{
    if (  '\0' == *pStr
       || 0 == nLen
       || LBUF_SIZE-1 == m_iLast.m_byte)
    {
        // The selection range is empty, or no buffer space is left.
        //
        return;
    }

    if ((LBUF_SIZE-1) - m_iLast.m_byte < nLen)
    {
        nLen = (LBUF_SIZE-1) - m_iLast.m_byte;
    }

    memcpy(m_autf + m_iLast.m_byte, pStr, nLen * sizeof(m_autf[0]));

    if (0 != m_ncs)
    {
        realloc_m_pcs(m_iLast.m_point + nLen);
        for (size_t i = 0; i < nLen; i++)
        {
            m_pcs[m_iLast.m_point + i] = CS_NORMAL;
        }
    }

    mux_cursor i = m_iLast, j = i;
    while (  cursor_next(i)
          && i.m_byte <= m_iLast.m_byte + nLen)
    {
        j = i;
    }

    m_iLast = j;
    m_autf[m_iLast.m_byte] = '\0';
}

/*! \brief Compress each run of consecutive occurrences of the
 * specified character to a single character.
 *
 * For each compressed run of characters, the properties of the
 * first character are preserved.
 *
 * \param ch       Character to compress.
 * \return         None.
 */

void mux_string::compress(const UTF8 ch)
{
    for (size_t i = 0, j = 0; i < m_iLast.m_byte; i++)
    {
        if (m_autf[i] == ch)
        {
            // look ahead for multiple occurrences of ch
            //
            for (j = i + 1; j < m_iLast.m_byte && m_autf[j] == ch; j++)
            {
                ; // Nothing.
            }
            if (i + 1 < j)
            {
                delete_Chars(i, j - (i + 1));
            }
        }
    }
}

/*! \brief Compress each run of consecutive whitespace characters to a
 * single whitespace character.
 *
 * For each compressed run of whitespace characters, the properties
 * of the first whitespace character are preserved.
 *
 * \return         None.
 */

void mux_string::compress_Spaces(void)
{
    for (size_t i = 0, j = 0; i < m_iLast.m_byte; i++)
    {
        if (mux_isspace(m_autf[i]))
        {
            // look ahead for consecutive whitespace characters
            //
            for (j = i + 1; j < m_iLast.m_byte && mux_isspace(m_autf[j]); j++)
            {
                ; // Nothing.
            }
            if (i + 1 < j)
            {
                delete_Chars(i, j - (i + 1));
            }
        }
    }
}

/*! \brief Delete a range of characters.
 *
 * \param nStart   Beginning of range to delete.
 * \param nLen     Length of range.
 * \return         None.
 */

void mux_string::delete_Chars(size_t nStart, size_t nLen)
{
    if (  m_iLast.m_byte <= nStart
       || 0 == nLen)
    {
        // The range does not select any characters.
        //
        return;
    }

    size_t nEnd = nStart + nLen;
    if (m_iLast.m_byte <= nEnd)
    {
        // The range extends beyond the end, so we can simply truncate.
        //
        m_iLast.m_byte = nStart;
        m_autf[m_iLast.m_byte] = '\0';
        return;
    }

    size_t nMove = m_iLast.m_byte - nEnd;
    memmove(m_autf + nStart, m_autf + nEnd, nMove * sizeof(m_autf[0]));
    if (0 != m_ncs)
    {
        memmove(m_pcs + nStart, m_pcs + nEnd, nMove * sizeof(m_pcs[0]));
    }
    m_iLast.m_byte -= nLen;
    m_autf[m_iLast.m_byte] = '\0';
}

/*! \brief Perform a search-and-replace-all operation, or prepend or
 * append the replacement string.
 *
 * If sFrom is "^", sTo is prepended to this string. If sFrom is "$",
 * sTo is appended to this string.  Search-and-replace-all for a literal
 * caret or dollar sign can be done by escaping them with a backslash or
 * percent sign, but in that case sFrom will be destructively modified
 * to remove the escape character.
 *
 * \param sFrom     String to search for within this string.
 * \param sTo       Replacement string.
 * \return          None.
 */

void mux_string::edit(mux_string &sFrom, const mux_string &sTo)
{
    // Do the substitution.  Idea for prefix/suffix from R'nice@TinyTIM.
    //
    const UTF8 chFrom0 = sFrom.export_Char(0);
    mux_cursor nFrom = sFrom.length_cursor();
    if (  1 == nFrom.m_byte
       && '^' == chFrom0)
    {
        // Prepend 'to' to string.
        //
        prepend(sTo);
    }
    else if (  1 == nFrom.m_byte
            && '$' == chFrom0)
    {
        // Append 'to' to string.
        //
        append(sTo);
    }
    else
    {
        const UTF8 chFrom1 = sFrom.export_Char(1);
        // Replace all occurances of 'from' with 'to'. Handle the special
        // cases of from = \$ and \^.
        //
        if (  (  '\\' == chFrom0
              || '%' == chFrom0)
           && (  '$' == chFrom1
              || '^' == chFrom1)
           && 2 == nFrom.m_byte)
        {
            sFrom.delete_Chars(0,1);
            nFrom(nFrom.m_byte-1, nFrom.m_point-1);
        }

        mux_cursor iStart = CursorMin, iFound = CursorMin;
        mux_cursor nTo = sTo.m_iLast;
        bool bSucceeded = search(sFrom, &iFound);
        while (bSucceeded)
        {
            iStart = iStart + iFound;
            replace_Chars(sTo, iStart, nFrom);
            iStart = iStart + nTo;

            if (iStart < m_iLast)
            {
                bSucceeded = search(sFrom, &iFound, iStart);
            }
            else
            {
                bSucceeded = false;
            }
        }
    }
}

UTF8 mux_string::export_Char(size_t n) const
{
    if (m_iLast.m_byte <= n)
    {
        return '\0';
    }
    return m_autf[n];
}

LBUF_OFFSET mux_string::export_Char_UTF8(size_t iFirst, UTF8 *pBuffer) const
{
    if (m_iLast.m_byte <= iFirst)
    {
        if (NULL != pBuffer)
        {
            pBuffer[0] = '\0';
        }
        return 0;
    }

    LBUF_OFFSET nBytes = utf8_FirstByte[m_autf[iFirst]];

    if (UTF8_CONTINUE <= iFirst)
    {
        if (NULL != pBuffer)
        {
            pBuffer[0] = '\0';
        }
        return 0;
    }

    if (NULL != pBuffer)
    {
        LBUF_OFFSET i;
        for (i = 0; i < nBytes; i++)
        {
            pBuffer[i] = m_autf[iFirst + i];
        }
        pBuffer[i] = '\0';
    }
    return nBytes;
}

ColorState mux_string::export_Color(size_t n) const
{
    if (  m_iLast.m_byte <= n
       || 0 == m_ncs)
    {
        return CS_NORMAL;
    }
    return m_pcs[n];
}

double mux_string::export_Float(bool bStrict) const
{
    return mux_atof(m_autf, bStrict);
}

INT64 mux_string::export_I64(void) const
{
    return mux_atoi64(m_autf);
}

long mux_string::export_Long(void) const
{
    return mux_atol(m_autf);
}

/*! \brief Generates ANSI string from internal form.
 *
 * \param buff     Pointer to beginning of lbuf.
 * \param bufc     Pointer to current position. Defaults to NULL.
 * \param iStart   String position to begin copying from. Defaults to 0.
 * \param nLen     Number of chars to copy. Defaults to LBUF_SIZE.
 * \param nBuffer  Size of buffer we're outputting into.
 *                 Defaults to LBUF_SIZE-1.
 * \param bNoBleed Which output mode to use: normal or nobleed.
 *                 Defaults to false (normal).
 * \return         Number of bytes copied.
 */

LBUF_OFFSET mux_string::export_TextAnsi
(
    UTF8 *pBuffer,
    mux_cursor iStart,
    mux_cursor iEnd,
    size_t nBytesMax,
    bool bNoBleed
) const
{
    // Sanity check our arguments and find out how much room we have.
    // We assume we're outputting into an LBUF unless given a smaller nBuffer.
    //
    if (!pBuffer)
    {
        return 0;
    }
    if (  m_iLast <= iStart
       || iEnd <= iStart
       || 0 == nBytesMax)
    {
        *pBuffer = '\0';
        return 0;
    }
    if (m_iLast < iEnd)
    {
        iEnd = m_iLast;
    }

    // iStart is the position in the source string where we will start
    //  copying, and has a value in the range [0, m_iLast).
    // nAvail is the room left in the destination buffer,
    //  and has a value in the range (0, nBuffer).
    // nLeft is the length of the portion of the source string we'd
    //  like to copy, and has a value in the range (0, m_iLast.m_byte].
    // nLen is the length of the portion of the source string we will
    //  try to copy, and has a value in the ranges (0, nLeft] and (0, nAvail].
    //
    LBUF_OFFSET nBytesWanted  = iEnd.m_byte - iStart.m_byte;
    LBUF_OFFSET nPointsWanted = iEnd.m_point - iStart.m_point;
    if (0 == m_ncs)
    {
        return export_TextPlain(pBuffer, iStart, iEnd, nBytesMax);
    }
    bool bPlentyOfRoom = 
        (nBytesMax > nBytesWanted + (ANSI_MAXIMUM_BINARY_TRANSITION_LENGTH * nPointsWanted) + COLOR_MAXIMUM_BINARY_NORMAL + 1);
    mux_cursor iPos = iStart, iCopy = iStart;
    size_t nTransition = 0;
    const UTF8 *pTransition = NULL;
    ColorState csPrev = CS_NORMAL;
    LBUF_OFFSET nCopy = 0, nDone = 0;

    if (bPlentyOfRoom)
    {
        while (iPos < iEnd)
        {
            if (csPrev != m_pcs[iPos.m_point])
            {
                if (iCopy < iPos)
                {
                    nCopy = iPos.m_byte - iCopy.m_byte;
                    memcpy(pBuffer, m_autf + iCopy.m_byte, nCopy);
                    pBuffer += nCopy;
                    nDone += nCopy;
                    iCopy = iPos;
                }

                pTransition = ANSI_TransitionColorBinary( csPrev,
                                                          m_pcs[iPos.m_point],
                                                          &nTransition,
                                                          bNoBleed);
                memcpy(pBuffer, pTransition, nTransition * sizeof(pTransition[0]));
                pBuffer += nTransition;
                nDone += nTransition;
                csPrev = m_pcs[iPos.m_point];
            }
            cursor_next(iPos);
        }
        if (iCopy < iPos)
        {
            nCopy = iPos.m_byte - iCopy.m_byte;
            memcpy(pBuffer, m_autf + iCopy.m_byte, nCopy);
            pBuffer += nCopy;
            nDone += nCopy;
        }
        if (csPrev != CS_NORMAL)
        {
            pTransition = ColorBinaryNormal(csPrev, &nTransition, bNoBleed);
            memcpy(pBuffer, pTransition, nTransition * sizeof(pTransition[0]));
            pBuffer += nTransition;
            nDone += nTransition;
        }
        *pBuffer = '\0';
        return nDone;
    }

    // There's a chance we might hit the end of the buffer. Do it the hard way.
    size_t nNeededAfter = 0;
    bool bNearEnd = false;
    LBUF_OFFSET nChar = 0;
    while (iPos < iEnd)
    {
        if (csPrev != m_pcs[iPos.m_point])
        {
            pTransition = ANSI_TransitionColorBinary( csPrev, m_pcs[iPos.m_point],
                                                      &nTransition, bNoBleed);
        }
        else
        {
            nTransition = 0;
        }
        nChar = utf8_FirstByte[m_autf[iPos.m_byte]];
        if (nBytesMax < nDone + nTransition + nChar + COLOR_MAXIMUM_BINARY_NORMAL)
        {
            if (  !bNearEnd
               || nTransition)
            {
                ColorBinaryNormal(m_pcs[iPos.m_point], &nNeededAfter, bNoBleed);
                bNearEnd = true;
            }
            if (nBytesMax < nDone + nTransition + nChar + nNeededAfter)
            {
                // There isn't enough room to add the color sequence,
                // its character, and still get back to normal. Stop here.
                //
                break;
            }
        }
        if (nTransition)
        {
            memcpy(pBuffer, pTransition, nTransition * sizeof(pTransition[0]));
            pBuffer += nTransition;
            nDone += nTransition;
            csPrev = m_pcs[iPos.m_point];
        }
        memcpy(pBuffer, m_autf + iPos.m_byte, nChar * sizeof(m_autf[0]));
        pBuffer += nChar;
        nDone += nChar;
        cursor_next(iPos);
    }
    pTransition = ColorBinaryNormal(csPrev, &nTransition, bNoBleed);
    if (  nTransition
       && nDone + nTransition <= nBytesMax)
    {
        memcpy(pBuffer, pTransition, nTransition * sizeof(pTransition[0]));
        pBuffer += nTransition;
        nDone += nTransition;
    }
    *pBuffer = '\0';
    return nDone;
}

/*! \brief Outputs ANSI-stripped string from internal form.
 *
 * \param buff     Pointer to beginning of lbuf.
 * \param bufc     Pointer to current position. Defaults to NULL.
 * \param nStart   String position to begin copying from. Defaults to 0.
 * \param nLen     Number of chars to copy. Defaults to LBUF_SIZE.
 * \param nBuffer  Size of buffer we're outputting into.
 *                 Defaults to LBUF_SIZE-1.
 * \return         None.
 */

LBUF_OFFSET mux_string::export_TextPlain
(
    UTF8 *pBuffer,
    mux_cursor iStart,
    mux_cursor iEnd,
    size_t nBytesMax
) const
{
    // Sanity check our arguments and find out how much room we have.
    // We assume we're outputting into an LBUF unless given a smaller nBuffer.
    //
    if (  !pBuffer
       || m_iLast <= iStart
       || iEnd <= iStart
       || 0 == nBytesMax)
    {
        return 0;
    }
    if (m_iLast < iEnd)
    {
        iEnd = m_iLast;
    }
    LBUF_OFFSET nBytes  = iEnd.m_byte - iStart.m_byte;
    if (nBytesMax < nBytes)
    {
        nBytes = nBytesMax;
    }

    memcpy(pBuffer, m_autf + iStart.m_byte, nBytes);
    pBuffer[nBytes] = '\0';
    return nBytes;
}

/*! \brief Converts and Imports a dbref.
 *
 * \param num      dbref to convert and import.
 * \return         None.
 */

void mux_string::import(dbref num)
{
    realloc_m_pcs(0);

    m_autf[0] = '#';
    LBUF_OFFSET n = 1;

    // mux_ltoa() sets the '\0'.
    //
    n += (LBUF_OFFSET)mux_ltoa(num, m_autf + 1);
    m_iLast(n, n);
}

/*! \brief Converts and Imports an INT64.
 *
 * \param iInt     INT64 to convert and import.
 * \return         None.
 */

void mux_string::import(INT64 iInt)
{
    realloc_m_pcs(0);

    // mux_i64toa() sets the '\0'.
    //
    LBUF_OFFSET n = (LBUF_OFFSET)mux_i64toa(iInt, m_autf);
    m_iLast(n, n);
}

/*! \brief Converts and Imports an long integer.
 *
 * \param lLong    long integer to convert and import.
 * \return         None.
 */

void mux_string::import(long lLong)
{
    realloc_m_pcs(0);

    // mux_ltoa() sets the '\0'.
    //
    LBUF_OFFSET n = (LBUF_OFFSET)mux_ltoa(lLong, m_autf);
    m_iLast(n, n);
}

/*! \brief Import a portion of another mux_string.
 *
 * \param sStr     mux_string to import.
 * \param iStart   Where to begin importing.
 * \return         None.
 */

void mux_string::import(const mux_string &sStr, mux_cursor iStart)
{
    if (sStr.m_iLast <= iStart)
    {
        m_iLast = CursorMin;
        realloc_m_pcs(0);
    }
    else
    {
        m_iLast = sStr.m_iLast - iStart;
        memcpy(m_autf, sStr.m_autf + iStart.m_byte, m_iLast.m_byte);
        if (0 != sStr.m_ncs)
        {
            realloc_m_pcs(m_iLast.m_point);
            memcpy(m_pcs, sStr.m_pcs + iStart.m_point, m_iLast.m_point * sizeof(m_pcs[0]));
        }
    }
    m_autf[m_iLast.m_byte] = '\0';
}

/*! \brief Import ANSI string.
 *
 * Parses the given ANSI string into a form which can be more-easily
 * navigated.
 *
 * \param pStr     ANSI-color encoded string to import.
 * \return         None.
 */

void mux_string::import(const UTF8 *pStr)
{
    m_iLast = CursorMin;
    if (  NULL == pStr
       || '\0' == *pStr)
    {
        m_autf[m_iLast.m_byte] = '\0';
        return;
    }

    size_t nLen = strlen((char *)pStr);
    import(pStr, nLen);
}

/*! \brief Import ANSI string.
 *
 * Parses the given ANSI string into a form which can be more-easily
 * navigated.
 *
 * \param pStr     ANSI-color encoded string to import.
 * \param nLen     Length of portion of string, str, to import.
 * \return         None.
 */

void mux_string::import(const UTF8 *pStr, size_t nLen)
{
    m_iLast = CursorMin;

    if (  NULL == pStr
       || '\0' == *pStr
       || 0 == nLen)
    {
        realloc_m_pcs(0);
        m_autf[m_iLast.m_byte] = '\0';
        return;
    }

    if (LBUF_SIZE-1 < nLen)
    {
        nLen = LBUF_SIZE-1;
    }

    bool bColor = false;
    static ColorState acsTemp[LBUF_SIZE];
    ColorState cs = CS_NORMAL;

    size_t iPoint = 0;
    size_t iStr = 0;
    UTF8 *pch = m_autf;
    while (iStr < nLen)
    {
        unsigned int iCode = mux_color(pStr + iStr);
        if (COLOR_NOTCOLOR == iCode)
        {
            safe_chr_utf8(pStr + iStr, m_autf, &pch);
            acsTemp[iPoint++] = cs;
            if (CS_NORMAL != cs)
            {
                bColor = true;
            }
        }
        else
        {
            cs = UpdateColorState(cs, iCode);
        }
        iStr += utf8_FirstByte[(unsigned char)pStr[iStr]];
    }

    m_iLast(pch - m_autf, iPoint);
    if (bColor)
    {
        realloc_m_pcs(m_iLast.m_point);
        memcpy(m_pcs, acsTemp, m_iLast.m_point * sizeof(m_pcs[0]));
    }
    else
    {
        realloc_m_pcs(0);
    }
    m_autf[m_iLast.m_byte] = '\0';
}

mux_cursor mux_string::length_cursor(void) const
{
    return m_iLast;
}

size_t mux_string::length(void) const
{
    return m_iLast.m_byte;
}


void mux_string::prepend(dbref num)
{
    mux_string *sStore = new mux_string(*this);

    import(num);
    append(*sStore);
    delete sStore;
}

void mux_string::prepend(long lLong)
{
    mux_string *sStore = new mux_string(*this);

    import(lLong);
    append(*sStore);
    delete sStore;
}

void mux_string::prepend(INT64 iInt)
{
    mux_string *sStore = new mux_string(*this);

    import(iInt);
    append(*sStore);
    delete sStore;
}

void mux_string::prepend(const mux_string &sStr)
{
    mux_string *sStore = new mux_string(*this);

    import(sStr);
    append(*sStore);
    delete sStore;
}

void mux_string::prepend(const UTF8 *pStr)
{
    mux_string *sStore = new mux_string(*this);

    import(pStr);
    append(*sStore);
    delete sStore;
}

void mux_string::prepend(const UTF8 *pStr, size_t n)
{
    mux_string *sStore = new mux_string(*this);

    import(pStr, n);
    append(*sStore);
    delete sStore;
}

/*! \brief Resizes or deletes the m_pcs array if necessary.
 *
 * If asked to resize the array to 0, this method will delete the
 * array and set m_pcs to NULL.  Otherwise when this method returns
 * the m_pcs array will exist and have at least the required size.
 * Any color states that were already initialized and would fit within
 * the resulting array will be preserved.
 *
 * \param ncs      Size of m_pcs array required.
 * \return         None.
 */

void mux_string::realloc_m_pcs(size_t ncs)
{
    if (  0 == ncs
       && 0 != m_ncs)
    {
        delete [] m_pcs;
        m_pcs = NULL;
        m_ncs = 0;
    }
    else if (m_ncs < ncs)
    {
        // extend in chunks of 8
        //
        ncs |= 0x7;
        ncs++;

        ColorState *pcsOld = m_pcs;
        m_pcs = NULL;
        try
        {
            m_pcs = new ColorState[ncs];
        }
        catch (...)
        {
            ; // Nothing.
        }
        ISOUTOFMEMORY(m_pcs);

        if (0 != m_ncs)
        {
            memcpy(m_pcs, pcsOld, m_ncs * sizeof(m_pcs[0]));
            delete [] pcsOld;
        }

        m_ncs = ncs;
    }
}

void mux_string::replace_Chars
(
    const mux_string &sTo,
    mux_cursor iStart,
    mux_cursor nLen
)
{
    mux_cursor nTo = sTo.m_iLast;
    mux_cursor nMove = CursorMin;
    mux_cursor nCopy = nTo;
    size_t i;

    if (nLen != nTo)
    {
        nMove = m_iLast - (iStart + nLen);
        if (CursorMax < m_iLast + nTo - nLen)
        {
            if (CursorMax < iStart + nTo)
            {
                nCopy = CursorMax - iStart;
                nMove = CursorMin;
            }
            else
            {
                nMove = CursorMax - (iStart + nTo);
            }
        }
        if (CursorMin < nMove)
        {
            memmove(m_autf + iStart.m_byte + nTo.m_byte,
                    m_autf + iStart.m_byte + nLen.m_byte, nMove.m_byte * sizeof(m_autf[0]));
        }
        m_iLast = iStart + nCopy + nMove;

        if (0 != m_ncs)
        {
            realloc_m_pcs(m_iLast.m_point);
            if (CursorMin < nMove)
            {
                memmove(m_pcs + iStart.m_point + nTo.m_point,
                        m_pcs + iStart.m_point + nLen.m_point, nMove.m_point * sizeof(m_pcs[0]));
            }
        }
        else if (0 != sTo.m_ncs)
        {
            realloc_m_pcs(m_iLast.m_point);
            for (i = 0; i < iStart.m_point; i++)
            {
                m_pcs[i] = CS_NORMAL;
            }
            for (i = 0; i < nMove.m_point; i++)
            {
                m_pcs[i+iStart.m_point+nTo.m_point] = CS_NORMAL;
            }
        }
    }

    memcpy(m_autf + iStart.m_byte, sTo.m_autf, nCopy.m_byte * sizeof(m_autf[0]));

    if (0 != sTo.m_ncs)
    {
        memcpy(m_pcs + iStart.m_point, sTo.m_pcs, nCopy.m_point * sizeof(m_pcs[0]));
    }
    else if (0 != m_ncs)
    {
        for (i = 0; i < nTo.m_point; i++)
        {
            m_pcs[iStart.m_point + i] = CS_NORMAL;
        }
    }

    m_autf[m_iLast.m_byte] = '\0';
}

/*! \brief Reverses the string.
 *
 * \return         None.
 */

void mux_string::reverse(void)
{
    mux_string *sTemp = new mux_string;
    sTemp->realloc_m_pcs(m_ncs);

    mux_cursor i = m_iLast, j = i;

    while (cursor_prev(i))
    {
        sTemp->append(*this, i, j);
        j = i;
    }
    import(*sTemp);
    delete sTemp;
}

/*! \brief Searches text for a specified pattern.
 *
 * \param pPattern Pointer to pattern to search for.
 * \param nPos     Pointer to value of position in string where pattern
                   is found.
 * \param nStart   Position in string to begin looking at. Defaults to 0.
 * \return         True if found, false if not.
 */

bool mux_string::search
(
    const UTF8 *pPattern,
    mux_cursor *iPos,
    mux_cursor iStart
) const
{
    // Strip ANSI from pattern.
    //
    size_t nPat = 0;
    UTF8 *pPatBuf = strip_color(pPattern, &nPat);
    const UTF8 *pTarget = m_autf + iStart.m_byte;

    size_t i = 0;
    bool bSucceeded = false;
    if (nPat == 1)
    {
        // We can optimize the single-character case.
        //
        const unsigned char *p = (const unsigned char *)memchr(pTarget, pPatBuf[0], m_iLast.m_byte - iStart.m_byte);
        if (p)
        {
            i = p - pTarget;
            bSucceeded = true;
        }
    }
    else if (nPat > 1)
    {
        // We have a multi-byte pattern.
        //
        bSucceeded = BMH_StringSearch(&i, nPat, pPatBuf,
                                      m_iLast.m_byte - iStart.m_byte, pTarget);
    }

    if (iPos)
    {
        cursor_from_byte(*iPos, i);
    }
    return bSucceeded;
}

/*! \brief Searches text for a specified pattern.
 *
 * \param sPattern Reference to string to search for.
 * \param nPos     Pointer to value of position in string where pattern
                   is found.
 * \param nStart   Position in string to begin looking at. Defaults to 0.
 * \return         True if found, false if not.
 */

bool mux_string::search
(
    const mux_string &sPattern,
    mux_cursor *iPos,
    mux_cursor iStart
) const
{
    // Strip ANSI from pattern.
    //
    const UTF8 *pTarget = m_autf + iStart.m_byte;

    size_t i = 0;
    bool bSucceeded = false;
    if (1 == sPattern.m_iLast.m_byte)
    {
        // We can optimize the single-character case.
        //
        const unsigned char *p = (const unsigned char *)memchr(pTarget, sPattern.m_autf[0], m_iLast.m_byte - iStart.m_byte);
        if (p)
        {
            i = p - pTarget;
            bSucceeded = true;
        }
    }
    else
    {
        // We have a multi-byte pattern.
        //
        bSucceeded = BMH_StringSearch(&i, sPattern.m_iLast.m_byte, sPattern.m_autf,
                                      m_iLast.m_byte - iStart.m_byte, pTarget);
    }

    if (iPos)
    {
        cursor_from_byte(*iPos, i);
    }
    return bSucceeded;
}

void mux_string::set_Char(size_t n, const UTF8 cChar)
{
    if (m_iLast.m_byte <= n)
    {
        return;
    }
    m_autf[n] = cChar;
}

void mux_string::set_Color(size_t n, ColorState csColor)
{
    if (m_iLast.m_byte <= n)
    {
        return;
    }
    if (  0 == m_ncs
       && csColor != CS_NORMAL)
    {
        realloc_m_pcs(m_iLast.m_byte);
        for (LBUF_OFFSET i = 0; i < m_iLast.m_byte; i++)
        {
            m_pcs[i] = CS_NORMAL;
        }
    }
    if (0 != m_ncs)
    {
        m_pcs[n] = csColor;
    }
}

/*! \brief Removes a specified set of characters from string.
 *
 * \param pStripSet Pointer to string of characters to remove.
 * \param nStart    Position in string to begin checking. Defaults to 0.
 * \param nLen      Number of characters in string to check.
                    Defaults to LBUF_SIZE-1.
 * \return          None.
 */

void mux_string::strip(const UTF8 *pStripSet, size_t nStart, size_t nLen)
{
    static bool strip_table[UCHAR_MAX+1];

    if (  NULL == pStripSet
       || '\0' == pStripSet[0]
       || m_iLast.m_byte <= nStart
       || 0 == nLen)
    {
        // Nothing to do.
        //
        return;
    }

    if (m_iLast.m_byte-nStart < nLen)
    {
        nLen = m_iLast.m_byte-nStart;
    }

    // Load set of characters to strip.
    //
    memset(strip_table, false, sizeof(strip_table));
    while (*pStripSet)
    {
        strip_table[(unsigned char)*pStripSet] = true;
        pStripSet++;
    }
    stripWithTable(strip_table, nStart, nLen);
}

void mux_string::stripWithTable
(
    const bool strip_table[UCHAR_MAX+1],
    size_t nStart,
    size_t nLen
)
{
    if (  m_iLast.m_byte <= nStart
       || 0 == nLen)
    {
        // Nothing to do.
        //
        return;
    }

    if (m_iLast.m_byte-nStart < nLen)
    {
        nLen = m_iLast.m_byte-nStart;
    }

    bool bInStrip = false;
    size_t nStripStart = nStart;
    for (size_t i = nStart; i < nStart + nLen; i++)
    {
        if (  !bInStrip
           && strip_table[m_autf[i]])
        {
            bInStrip = true;
            nStripStart = i;
        }
        else if (  bInStrip
                && !strip_table[m_autf[i]])
        {
            // We've hit the end of a string to be stripped.
            //
            size_t nStrip = i - nStripStart;
            delete_Chars(nStripStart, nStrip);
            i -= nStrip;
            bInStrip = false;
        }
    }

    if (bInStrip)
    {
        if (m_iLast.m_byte == nStart+nLen)
        {
            // We found chars to strip at the end of the string.
            // We can just truncate.
            //
            m_autf[nStripStart] = '\0';
            m_iLast.m_byte = nStripStart;
        }
        else
        {
            size_t nStrip = nStart + nLen - nStripStart;
            delete_Chars(nStripStart, nStrip);
        }
    }
}

void mux_string::transform
(
    mux_string &sFromSet,
    mux_string &sToSet,
    size_t nStart,
    size_t nLen
)
{
    static unsigned char asciiTable[SCHAR_MAX+1];

    if (m_iLast.m_byte <= nStart)
    {
        return;
    }
    else if (m_iLast.m_byte - nStart < nLen)
    {
        nLen = m_iLast.m_byte - nStart;
    }

    // Set up table.
    //
    for (unsigned char c = 0; c <= SCHAR_MAX; c++)
    {
        asciiTable[c] = c;
    }

    unsigned char cFrom, cTo;
    mux_cursor iSetEnd = sFromSet.m_iLast;
    if (sToSet.m_iLast < iSetEnd)
    {
        iSetEnd = sToSet.m_iLast;
    }
    size_t nUTF = 0;
    for (mux_cursor i = CursorMin; i < iSetEnd; cursor_next(i))
    {
        cFrom = sFromSet.m_autf[i.m_byte];
        cTo = sToSet.m_autf[i.m_byte];
        if (  mux_isprint_ascii(cFrom)
           && mux_isprint_ascii(cTo))
        {
            asciiTable[cFrom] = cTo;
        }
        else
        {
            nUTF++;
        }
    }
    // TODO: transform_UTF8
    //
    //if (0 == nUTF)
    //{
        transform_Ascii(asciiTable, nStart, nLen);
    //}
    //else
    //{
    //    transform_UTF8(sFromSet, sToSet, asciiTable, nUTF, nStart, nLen);
    //}
}

void mux_string::transform_Ascii
(
    const unsigned char asciiTable[SCHAR_MAX+1],
    size_t nStart,
    size_t nLen
)
{
    if (m_iLast.m_byte <= nStart)
    {
        return;
    }
    else if (m_iLast.m_byte - nStart < nLen)
    {
        nLen = m_iLast.m_byte - nStart;
    }

    for (size_t i = nStart; i < nStart + nLen; i++)
    {
        if (mux_isprint_ascii(m_autf[i]))
        {
            m_autf[i] = asciiTable[m_autf[i]];
        }
    }
}

void mux_string::trim(const UTF8 ch, bool bLeft, bool bRight)
{
    if (  0 == m_iLast.m_byte
       || (  !bLeft
          && !bRight ))
    {
        return;
    }

    if (bRight)
    {
        size_t iPos = m_iLast.m_byte - 1;
        while (  ch == m_autf[iPos]
              && 0 < iPos)
        {
            iPos--;
        }

        if (iPos < m_iLast.m_byte - 1)
        {
            m_iLast.m_byte = iPos + 1;
            m_autf[m_iLast.m_byte] = '\0';
        }
    }

    if (bLeft)
    {
        size_t iPos = 0;
        while (  ch == m_autf[iPos]
              && iPos < m_iLast.m_byte)
        {
            iPos++;
        }

        if (0 < iPos)
        {
            delete_Chars(0, iPos);
        }
    }
}

void mux_string::trim(const UTF8 *p, bool bLeft, bool bRight)
{
    if (  0 == m_iLast.m_byte
       || NULL == p
       || '\0' == p[0]
       || (  !bLeft
          && !bRight ))
    {
        return;
    }

    size_t n = strlen((char *)p);

    if (1 == n)
    {
        trim(p[0], bLeft, bRight);
        return;
    }
    else
    {
        trim(p, n, bLeft, bRight);
    }
}

void mux_string::trim(const UTF8 *p, size_t n, bool bLeft, bool bRight)
{
    if (  CursorMin == m_iLast
       || NULL == p
       || 0 == n
       || m_iLast.m_byte < n
       || (  !bLeft
          && !bRight ))
    {
        return;
    }

    if (bRight)
    {
        size_t iPos = m_iLast.m_byte - 1;
        size_t iDist = n - 1;
        while (  p[iDist] == m_autf[iPos]
              && 0 < iPos)
        {
            iPos--;
            iDist = (0 < iDist) ? iDist - 1 : n - 1;
        }

        if (iPos < m_iLast.m_byte - 1)
        {
            m_iLast.m_byte = iPos + 1;
            m_autf[m_iLast.m_byte] = '\0';
        }
    }

    if (bLeft)
    {
        size_t iPos = 0;
        while (  p[iPos % n] == m_autf[iPos]
              && iPos < m_iLast.m_byte)
        {
            iPos++;
        }

        if (0 < iPos)
        {
            delete_Chars(0, iPos);
        }
    }
}

void mux_string::truncate(mux_cursor iEnd)
{
    if (m_iLast <= iEnd)
    {
        return;
    }
    m_iLast = iEnd;
    m_autf[m_iLast.m_byte] = '\0';
}

mux_words::mux_words(const mux_string &sStr) : m_s(&sStr)
{
    m_aiWordBegins[0] = 0;
    m_aiWordEnds[0] = 0;
    m_nWords = 0;
}

void mux_words::export_WordAnsi(LBUF_OFFSET n, UTF8 *buff, UTF8 **bufc)
{
    if (m_nWords <= n)
    {
        return;
    }

    mux_cursor iStart, iEnd;

    m_s->cursor_from_point(iStart, m_aiWordBegins[n]);
    m_s->cursor_from_point(iEnd, m_aiWordEnds[n]);
    m_s->export_TextAnsi(*bufc, iStart, iEnd, buff + LBUF_SIZE - *bufc);
}

LBUF_OFFSET mux_words::find_Words(void)
{
    mux_cursor n = m_s->m_iLast;
    LBUF_OFFSET nWords = 0;
    bool bPrev = true;

    for (mux_cursor i = CursorMin; i < n; m_s->cursor_next(i))
    {
        if (  !bPrev
           && m_aControl[m_s->m_autf[i.m_byte]])
        {
            bPrev = true;
            m_aiWordEnds[nWords] = i.m_point;
            nWords++;
        }
        else if (bPrev)
        {
            bPrev = false;
            m_aiWordBegins[nWords] = i.m_point;
        }
    }
    if (!bPrev)
    {
        m_aiWordEnds[nWords] = n.m_point;
        nWords++;
    }
    m_nWords = nWords;
    return m_nWords;
}

LBUF_OFFSET mux_words::find_Words(const UTF8 *pDelim)
{
    pDelim = strip_color(pDelim);
    mux_cursor nDelim = CursorMin;
    utf8_strlen(pDelim, nDelim);

    mux_cursor iPos = CursorMin;
    mux_cursor iStart = CursorMin;
    LBUF_OFFSET nWords = 0;
    bool bSucceeded = m_s->search(pDelim, &iPos, iStart);

    while (  bSucceeded
          && nWords + 1 < MAX_WORDS)
    {
        m_aiWordBegins[nWords] = iStart.m_point;
        iStart = iStart + iPos;
        m_aiWordEnds[nWords] = iStart.m_point;
        nWords++;
        iStart = iStart + nDelim;
        bSucceeded = m_s->search(pDelim, &iPos, iStart);
    }
    m_aiWordBegins[nWords] = iStart.m_point;
    m_aiWordEnds[nWords] = m_s->m_iLast.m_point;
    nWords++;
    m_nWords = nWords;
    return nWords;
}

#else

/*! \brief Constructs mux_string object.
 *
 * This constructor puts the mux_string object into an initial, reasonable,
 * and empty state.
 *
 * \return         None.
 */

mux_string::mux_string(void)
{
    m_n = 0;
    m_ach[0] = '\0';
    m_ncs = 0;
    m_pcs = NULL;
}


/*! \brief Constructs mux_string object.
 *
 * This is a deep copy constructor.
 *
 * \param sStr     mux_string to be copied.
 * \return         None.
 */

mux_string::mux_string(const mux_string &sStr)
{
    m_ncs = 0;
    m_pcs = NULL;
    import(sStr);
}

/*! \brief Constructs mux_string object from an ANSI string.
 *
 * Parses the given ANSI string into a form which can be more-easily
 * navigated.
 *
 * \param pStr     ANSI string to be parsed.
 * \return         None.
 */

mux_string::mux_string(const UTF8 *pStr)
{
    m_ncs = 0;
    m_pcs = NULL;
    import(pStr);
}

/*! \brief Destructs mux_string object.
 *
 * This destructor deletes the m_pcs array if necessary.
 *
 * \return         None.
 */

mux_string::~mux_string(void)
{
    realloc_m_pcs(0);
}

void mux_string::append(dbref num)
{
    append_TextPlain((const UTF8 *)"#", 1);
    append_TextPlain(mux_ltoa_t(num));
}

void mux_string::append(INT64 iInt)
{
    append_TextPlain(mux_i64toa_t(iInt));
}

void mux_string::append(long lLong)
{
    append_TextPlain(mux_ltoa_t(lLong));
}

/*! \brief Extract and append a range of characters.
 *
 * \param sStr     mux_string from which to extract characters.
 * \param nStart   Beginning of range to extract and apend.
 * \param nLen     Length of range to extract and append.
 * \return         None.
 */

void mux_string::append(const mux_string &sStr, size_t nStart, size_t nLen)
{
    if (  sStr.m_n <= nStart
       || 0 == nLen
       || LBUF_SIZE-1 == m_n)
    {
        // The selection range is empty, or no buffer space is left.
        //
        return;
    }

    if (sStr.m_n - nStart < nLen)
    {
        nLen = sStr.m_n - nStart;
    }

    if ((LBUF_SIZE-1)-m_n < nLen)
    {
        nLen = (LBUF_SIZE-1)-m_n;
    }

    memcpy(m_ach + m_n, sStr.m_ach + nStart, nLen * sizeof(m_ach[0]));

    if (0 != m_ncs)
    {
        realloc_m_pcs(m_n + nLen);
    }
    else if (0 != sStr.m_ncs)
    {
        realloc_m_pcs(m_n + nLen);
        for (size_t i = 0; i < m_n; i++)
        {
            m_pcs[i] = CS_NORMAL;
        }
    }

    if (0 != sStr.m_ncs)
    {
        memcpy(m_pcs + m_n, sStr.m_pcs + nStart, nLen * sizeof(m_pcs[0]));
    }
    else if (0 != m_ncs)
    {
        for (size_t i = 0; i < nLen; i++)
        {
            m_pcs[m_n+i] = CS_NORMAL;
        }
    }

    m_n += nLen;
    m_ach[m_n] = '\0';
}

void mux_string::append(const UTF8 *pStr)
{
    if (  NULL == pStr
       || '\0' == *pStr)
    {
        return;
    }

    size_t nAvail = (LBUF_SIZE-1) - m_n;
    if (0 == nAvail)
    {
        // No room.
        //
        return;
    }

    size_t nLen = strlen((char *)pStr);
    if (nAvail < nLen)
    {
        nLen = nAvail;
    }

    mux_string *sNew = new mux_string;

    sNew->import(pStr, nLen);

    append(*sNew);
    delete sNew;
}

void mux_string::append(const UTF8 *pStr, size_t nLen)
{
    if (  NULL == pStr
       || '\0' == *pStr)
    {
        return;
    }

    size_t nAvail = (LBUF_SIZE-1) - m_n;
    if (0 == nAvail)
    {
        // No room.
        //
        return;
    }
    if (nAvail < nLen)
    {
        nLen = nAvail;
    }

    mux_string *sNew = new mux_string;

    sNew->import(pStr, nLen);
    append(*sNew);
    delete sNew;
}

void mux_string::append_TextPlain(const UTF8 *pStr)
{
    if (  '\0' == *pStr
       || LBUF_SIZE-1 <= m_n)
    {
        // The selection range is empty, or no buffer space is left.
        //
        return;
    }

    size_t nLen = strlen((char *)pStr);

    if ((LBUF_SIZE-1)-m_n < nLen)
    {
        nLen = (LBUF_SIZE-1)-m_n;
    }

    memcpy(m_ach + m_n, pStr, nLen * sizeof(m_ach[0]));

    if (0 != m_ncs)
    {
        realloc_m_pcs(m_n + nLen);
        for (size_t i = 0; i < nLen; i++)
        {
            m_pcs[m_n+i] = CS_NORMAL;
        }
    }

    m_n += nLen;
    m_ach[m_n] = '\0';
}

void mux_string::append_TextPlain(const UTF8 *pStr, size_t nLen)
{
    if (  '\0' == *pStr
       || 0 == nLen
       || LBUF_SIZE-1 == m_n)
    {
        // The selection range is empty, or no buffer space is left.
        //
        return;
    }

    if ((LBUF_SIZE-1)-m_n < nLen)
    {
        nLen = (LBUF_SIZE-1)-m_n;
    }

    memcpy(m_ach + m_n, pStr, nLen * sizeof(m_ach[0]));

    if (0 != m_ncs)
    {
        realloc_m_pcs(m_n + nLen);
        for (size_t i = 0; i < nLen; i++)
        {
            m_pcs[m_n+i] = CS_NORMAL;
        }
    }

    m_n += nLen;
    m_ach[m_n] = '\0';
}

/*! \brief Compress each run of consecutive occurrences of the
 * specified character to a single character.
 *
 * For each compressed run of characters, the properties of the
 * first character are preserved.
 *
 * \param ch       Character to compress.
 * \return         None.
 */

void mux_string::compress(const UTF8 ch)
{
    for (size_t i = 0, j = 0; i < m_n; i++)
    {
        if (m_ach[i] == ch)
        {
            // look ahead for multiple occurrences of ch
            //
            for (j = i + 1; j < m_n && m_ach[j] == ch; j++)
            {
                ; // Nothing.
            }
            if (i + 1 < j)
            {
                delete_Chars(i, j - (i + 1));
            }
        }
    }
}

/*! \brief Compress each run of consecutive whitespace characters to a
 * single whitespace character.
 *
 * For each compressed run of whitespace characters, the properties
 * of the first whitespace character are preserved.
 *
 * \return         None.
 */

void mux_string::compress_Spaces(void)
{
    for (size_t i = 0, j = 0; i < m_n; i++)
    {
        if (mux_isspace(m_ach[i]))
        {
            // look ahead for consecutive whitespace characters
            //
            for (j = i + 1; j < m_n && mux_isspace(m_ach[j]); j++)
            {
                ; // Nothing.
            }
            if (i + 1 < j)
            {
                delete_Chars(i, j - (i + 1));
            }
        }
    }
}

/*! \brief Delete a range of characters.
 *
 * \param nStart   Beginning of range to delete.
 * \param nLen     Length of range.
 * \return         None.
 */

void mux_string::delete_Chars(size_t nStart, size_t nLen)
{
    if (  m_n <= nStart
       || 0 == nLen)
    {
        // The range does not select any characters.
        //
        return;
    }

    size_t nEnd = nStart + nLen;
    if (m_n <= nEnd)
    {
        // The range extends beyond the end, so we can simply truncate.
        //
        m_n = nStart;
        m_ach[m_n] = '\0';
        return;
    }

    size_t nMove = m_n - nEnd;
    memmove(m_ach + nStart, m_ach + nEnd, nMove * sizeof(m_ach[0]));
    if (0 != m_ncs)
    {
        memmove(m_pcs + nStart, m_pcs + nEnd, nMove * sizeof(m_pcs[0]));
    }
    m_n -= nLen;
    m_ach[m_n] = '\0';
}

/*! \brief Perform a search-and-replace-all operation, or prepend or
 * append the replacement string.
 *
 * If sFrom is "^", sTo is prepended to this string. If sFrom is "$",
 * sTo is appended to this string.  Search-and-replace-all for a literal
 * caret or dollar sign can be done by escaping them with a backslash or
 * percent sign, but in that case sFrom will be destructively modified
 * to remove the escape character.
 *
 * \param sFrom     String to search for within this string.
 * \param sTo       Replacement string.
 * \return          None.
 */

void mux_string::edit(mux_string &sFrom, const mux_string &sTo)
{
    // Do the substitution.  Idea for prefix/suffix from R'nice@TinyTIM.
    //
    const UTF8 chFrom0 = sFrom.export_Char(0);
    size_t nFrom = sFrom.length();
    if (  1 == nFrom
       && '^' == chFrom0)
    {
        // Prepend 'to' to string.
        //
        prepend(sTo);
    }
    else if (  1 == nFrom
            && '$' == chFrom0)
    {
        // Append 'to' to string.
        //
        append(sTo);
    }
    else
    {
        const UTF8 chFrom1 = sFrom.export_Char(1);
        // Replace all occurances of 'from' with 'to'. Handle the special
        // cases of from = \$ and \^.
        //
        if (  (  '\\' == chFrom0
              || '%' == chFrom0)
           && (  '$' == chFrom1
              || '^' == chFrom1)
           && 2 == nFrom)
        {
            sFrom.delete_Chars(0,1);
            nFrom--;
        }

        size_t nStart = 0;
        size_t nFound = 0;
        size_t nTo = sTo.m_n;
        bool bSucceeded = search(sFrom, &nFound);
        while (bSucceeded)
        {
            nStart += nFound;
            replace_Chars(sTo, nStart, nFrom);
            nStart += nTo;

            if (nStart < LBUF_SIZE-1)
            {
                bSucceeded = search(sFrom, &nFound, nStart);
            }
            else
            {
                bSucceeded = false;
            }
        }
    }
}

UTF8 mux_string::export_Char(size_t n) const
{
    if (m_n <= n)
    {
        return '\0';
    }
    return m_ach[n];
}

LBUF_OFFSET mux_string::export_Char_UTF8(size_t iFirst, UTF8 *pBuffer) const
{
    if (m_n <= iFirst)
    {
        if (NULL != pBuffer)
        {
            pBuffer[0] = '\0';
        }
        return 0;
    }

    LBUF_OFFSET nBytes = utf8_FirstByte[m_ach[iFirst]];

    if (UTF8_CONTINUE <= iFirst)
    {
        if (NULL != pBuffer)
        {
            pBuffer[0] = '\0';
        }
        return 0;
    }

    if (NULL != pBuffer)
    {
        LBUF_OFFSET i;
        for (i = 0; i < nBytes; i++)
        {
            pBuffer[i] = m_ach[iFirst + i];
        }
        pBuffer[i] = '\0';
    }
    return nBytes;
}

ColorState mux_string::export_Color(size_t n) const
{
    if (  m_n <= n
       || 0 == m_ncs)
    {
        return CS_NORMAL;
    }
    return m_pcs[n];
}

double mux_string::export_Float(bool bStrict) const
{
    return mux_atof(m_ach, bStrict);
}

INT64 mux_string::export_I64(void) const
{
    return mux_atoi64(m_ach);
}

long mux_string::export_Long(void) const
{
    return mux_atol(m_ach);
}

/*! \brief Generates ANSI string from internal form.
 *
 * \param buff     Pointer to beginning of lbuf.
 * \param bufc     Pointer to current position. Defaults to NULL.
 * \param iStart   String position to begin copying from. Defaults to 0.
 * \param nLen     Number of chars to copy. Defaults to LBUF_SIZE.
 * \param nBuffer  Size of buffer we're outputting into.
 *                 Defaults to LBUF_SIZE-1.
 * \param bNoBleed Which output mode to use: normal or nobleed.
 *                 Defaults to false (normal).
 * \return         None.
 */

void mux_string::export_TextAnsi
(
    UTF8 *buff,
    UTF8 **bufc,
    size_t iStart,
    size_t nLen,
    size_t nBuffer,
    bool bNoBleed
) const
{
    // Sanity check our arguments and find out how much room we have.
    // We assume we're outputting into an LBUF unless given a smaller nBuffer.
    //
    UTF8 *bufctemp;
    if (NULL == bufc)
    {
        bufc = &bufctemp;
        *bufc = buff;
    }
    if (  !buff
       || !*bufc)
    {
        return;
    }
    size_t nAvail = buff + nBuffer - *bufc;
    if (  nAvail < 1
       || nBuffer < nAvail)
    {
        return;
    }
    if (  m_n <= iStart
       || 0 == nLen)
    {
        **bufc = '\0';
        return;
    }
    size_t  nLeft   = (m_n - iStart);
    if (nLeft < nLen)
    {
        nLen = nLeft;
    }
    if (nAvail < nLen)
    {
        nLen = nAvail;
    }

    // nStart is the position in the source string where we will start
    //  copying, and has a value in the range [0, m_n).
    // nAvail is the room left in the destination buffer,
    //  and has a value in the range (0, nBuffer).
    // nLeft is the length of the portion of the source string we'd
    //  like to copy, and has a value in the range (0, m_n].
    // nLen is the length of the portion of the source string we will
    //  try to copy, and has a value in the ranges (0, nLeft] and (0, nAvail].
    //
    if (0 == m_ncs)
    {
        export_TextPlain(buff, bufc, iStart, nLen, nBuffer);
        return;
    }
    size_t iPos = iStart;
    bool bPlentyOfRoom =
        (nAvail > nLen * (ANSI_MAXIMUM_BINARY_TRANSITION_LENGTH + 1) + UTF8_SIZE4 + COLOR_MAXIMUM_BINARY_NORMAL);
    size_t nTransition = 0, nChar = 0;
    const UTF8 *pTransition = NULL;
    ColorState csPrev = CS_NORMAL;

    if (bPlentyOfRoom)
    {
        while (iPos < iStart + nLen)
        {
            if (csPrev != m_pcs[iPos])
            {
                pTransition = ANSI_TransitionColorBinary( csPrev,
                                                          m_pcs[iPos],
                                                          &nTransition,
                                                          bNoBleed);
                memcpy(*bufc, pTransition, nTransition * sizeof(pTransition[0]));
                *bufc += nTransition;
                csPrev = m_pcs[iPos];
            }
            nChar = utf8_FirstByte[m_ach[iPos]];
            if (UTF8_CONTINUE <= nChar)
            {
                nChar = 1;
            }
            memcpy(*bufc, m_ach + iPos, nChar * sizeof(m_ach[0]));
            *bufc += nChar;
            iPos += nChar;
        }
        if (csPrev != CS_NORMAL)
        {
            pTransition = ColorBinaryNormal(csPrev, &nTransition, bNoBleed);
            memcpy(*bufc, pTransition, nTransition * sizeof(pTransition[0]));
            *bufc += nTransition;
        }
        **bufc = '\0';
        return;
    }

    // There's a chance we might hit the end of the buffer. Do it the hard way.
    size_t nNeededAfter = 0;
    bool bNearEnd = false;
    while (iPos < iStart + nLen)
    {
        if (csPrev != m_pcs[iPos])
        {
            pTransition = ANSI_TransitionColorBinary( csPrev, m_pcs[iPos],
                                                      &nTransition, bNoBleed);
        }
        else
        {
            nTransition = 0;
        }
        nChar = utf8_FirstByte[m_ach[iPos]];
        if (nBuffer < (*bufc-buff) + nTransition + nChar + COLOR_MAXIMUM_BINARY_NORMAL)
        {
            if (  !bNearEnd
               || nTransition)
            {
                ColorBinaryNormal(m_pcs[iPos], &nNeededAfter, bNoBleed);
                bNearEnd = true;
            }
            if (nBuffer < (*bufc-buff) + nTransition + nChar + nNeededAfter)
            {
                // There isn't enough room to add the color sequence,
                // its character, and still get back to normal. Stop here.
                //
                break;
            }
        }
        if (nTransition)
        {
            memcpy(*bufc, pTransition, nTransition * sizeof(pTransition[0]));
            *bufc += nTransition;
            csPrev = m_pcs[iPos];
        }
        memcpy(*bufc, m_ach + iPos, nChar * sizeof(m_ach[0]));
        *bufc += nChar;
        iPos += nChar;
    }
    pTransition = ColorBinaryNormal(csPrev, &nTransition, bNoBleed);
    if (  nTransition
       && (*bufc-buff) + nTransition <= nBuffer)
    {
        memcpy(*bufc, pTransition, nTransition * sizeof(pTransition[0]));
        *bufc += nTransition;
    }
    **bufc = '\0';
}

/*! \brief Outputs ANSI-stripped string from internal form.
 *
 * \param buff     Pointer to beginning of lbuf.
 * \param bufc     Pointer to current position. Defaults to NULL.
 * \param nStart   String position to begin copying from. Defaults to 0.
 * \param nLen     Number of chars to copy. Defaults to LBUF_SIZE.
 * \param nBuffer  Size of buffer we're outputting into.
 *                 Defaults to LBUF_SIZE-1.
 * \return         None.
 */

void mux_string::export_TextPlain
(
    UTF8 *buff,
    UTF8 **bufc,
    size_t nStart,
    size_t nLen,
    size_t nBuffer
) const
{
    // Sanity check our arguments and find out how much room we have.
    // We assume we're outputting into an LBUF unless given a smaller nBuffer.
    //
    UTF8 *bufctemp;
    if (NULL == bufc)
    {
        bufc = &bufctemp;
        *bufc = buff;
    }
    if (  !buff
       || !*bufc)
    {
        return;
    }
    size_t nAvail = buff + nBuffer - *bufc;
    if (  nAvail < 1
       || nBuffer < nAvail)
    {
        return;
    }
    if (  m_n <= nStart
       || 0 == nLen)
    {
        return;
    }
    size_t  nLeft   = (m_n - nStart);
    if (nLeft < nLen)
    {
        nLen = nLeft;
    }
    if (nAvail < nLen)
    {
        nLen = nAvail;
    }

    // nStart is the position in the source string where we will start
    //  copying, and has a value in the range [0, m_n).
    // nAvail is the room left in the destination buffer,
    //  and has a value in the range (0, nBuffer).
    // nLeft is the length of the portion of the source string we'd
    //  like to copy, and has a value in the range (0, m_n].
    // nLen is the length of the portion of the source string we will copy,
    //  and has a value in the ranges (0, nLeft] and (0, nAvail].
    //
    memcpy(*bufc, m_ach+nStart, nLen * sizeof(m_ach[0]));
    *bufc += nLen;
    **bufc = '\0';
}

/*! \brief Converts and Imports a dbref.
 *
 * \param num      dbref to convert and import.
 * \return         None.
 */

void mux_string::import(dbref num)
{
    realloc_m_pcs(0);

    m_ach[0] = '#';
    m_n = 1;

    // mux_ltoa() sets the '\0'.
    //
    m_n += mux_ltoa(num, m_ach + 1);
}

/*! \brief Converts and Imports an INT64.
 *
 * \param iInt     INT64 to convert and import.
 * \return         None.
 */

void mux_string::import(INT64 iInt)
{
    realloc_m_pcs(0);

    // mux_i64toa() sets the '\0'.
    //
    m_n = mux_i64toa(iInt, m_ach);
}

/*! \brief Converts and Imports an long integer.
 *
 * \param lLong    long integer to convert and import.
 * \return         None.
 */

void mux_string::import(long lLong)
{
    realloc_m_pcs(0);

    // mux_ltoa() sets the '\0'.
    //
    m_n = mux_ltoa(lLong, m_ach);
}

/*! \brief Import a portion of another mux_string.
 *
 * \param sStr     mux_string to import.
 * \param nStart   Where to begin importing.
 * \return         None.
 */

void mux_string::import(const mux_string &sStr, size_t nStart)
{
    if (sStr.m_n <= nStart)
    {
        m_n = 0;
        realloc_m_pcs(0);
    }
    else
    {
        m_n = sStr.m_n - nStart;
        memcpy(m_ach, sStr.m_ach + nStart, m_n*sizeof(m_ach[0]));
        if (0 != sStr.m_ncs)
        {
            realloc_m_pcs(m_n);
            memcpy(m_pcs, sStr.m_pcs + nStart, m_n*sizeof(m_pcs[0]));
        }
    }
    m_ach[m_n] = '\0';
}

/*! \brief Import ANSI string.
 *
 * Parses the given ANSI string into a form which can be more-easily
 * navigated.
 *
 * \param pStr     ANSI-color encoded string to import.
 * \return         None.
 */

void mux_string::import(const UTF8 *pStr)
{
    m_n = 0;
    if (  NULL == pStr
       || '\0' == *pStr)
    {
        m_ach[m_n] = '\0';
        return;
    }

    size_t nLen = strlen((char *)pStr);
    import(pStr, nLen);
}

/*! \brief Import ANSI string.
 *
 * Parses the given ANSI string into a form which can be more-easily
 * navigated.
 *
 * \param pStr     ANSI-color encoded string to import.
 * \param nLen     Length of portion of string, str, to import.
 * \return         None.
 */

void mux_string::import(const UTF8 *pStr, size_t nLen)
{
    m_n = 0;

    if (  NULL == pStr
       || '\0' == *pStr
       || 0 == nLen)
    {
        realloc_m_pcs(0);
        m_ach[m_n] = '\0';
        return;
    }

    if (LBUF_SIZE-1 < nLen)
    {
        nLen = LBUF_SIZE-1;
    }

    bool bColor = false;
    static ColorState acsTemp[LBUF_SIZE];
    ColorState cs = CS_NORMAL;

    size_t iPoint = 0;
    size_t iStr = 0;
    UTF8 *pch = m_ach;
    while (iStr < nLen)
    {
        unsigned int iCode = mux_color(pStr + iStr);
        if (COLOR_NOTCOLOR == iCode)
        {
            safe_chr_utf8(pStr + iStr, m_ach, &pch);
            acsTemp[iPoint++] = cs;
            if (CS_NORMAL != cs)
            {
                bColor = true;
            }
        }
        else
        {
            cs = UpdateColorState(cs, iCode);
        }
        iStr += utf8_FirstByte[(unsigned char)pStr[iStr]];
    }

    m_n = iPoint;
    if (bColor)
    {
        realloc_m_pcs(m_n);
        memcpy(m_pcs, acsTemp, m_n*sizeof(m_pcs[0]));
    }
    else
    {
        realloc_m_pcs(0);
    }
    m_ach[m_n] = '\0';
}

size_t mux_string::length(void) const
{
    return m_n;
}

void mux_string::prepend(dbref num)
{
    mux_string *sStore = new mux_string(*this);

    import(num);
    append(*sStore);
    delete sStore;
}

void mux_string::prepend(long lLong)
{
    mux_string *sStore = new mux_string(*this);

    import(lLong);
    append(*sStore);
    delete sStore;
}

void mux_string::prepend(INT64 iInt)
{
    mux_string *sStore = new mux_string(*this);

    import(iInt);
    append(*sStore);
    delete sStore;
}

void mux_string::prepend(const mux_string &sStr)
{
    mux_string *sStore = new mux_string(*this);

    import(sStr);
    append(*sStore);
    delete sStore;
}

void mux_string::prepend(const UTF8 *pStr)
{
    mux_string *sStore = new mux_string(*this);

    import(pStr);
    append(*sStore);
    delete sStore;
}

void mux_string::prepend(const UTF8 *pStr, size_t n)
{
    mux_string *sStore = new mux_string(*this);

    import(pStr, n);
    append(*sStore);
    delete sStore;
}

/*! \brief Resizes or deletes the m_pcs array if necessary.
 *
 * If asked to resize the array to 0, this method will delete the
 * array and set m_pcs to NULL.  Otherwise when this method returns
 * the m_pcs array will exist and have at least the required size.
 * Any color states that were already initialized and would fit within
 * the resulting array will be preserved.
 *
 * \param ncs      Size of m_pcs array required.
 * \return         None.
 */

void mux_string::realloc_m_pcs(size_t ncs)
{
    if (  0 == ncs
       && 0 != m_ncs)
    {
        delete [] m_pcs;
        m_pcs = NULL;
        m_ncs = 0;
    }
    else if (m_ncs < ncs)
    {
        // extend in chunks of 8
        //
        ncs |= 0x7;
        ncs++;

        ColorState *pcsOld = m_pcs;
        m_pcs = NULL;
        try
        {
            m_pcs = new ColorState[ncs];
        }
        catch (...)
        {
            ; // Nothing.
        }
        ISOUTOFMEMORY(m_pcs);

        if (0 != m_ncs)
        {
            memcpy(m_pcs, pcsOld, m_ncs * sizeof(m_pcs[0]));
            delete [] pcsOld;
        }

        m_ncs = ncs;
    }
}

void mux_string::replace_Chars
(
    const mux_string &sTo,
    size_t nStart,
    size_t nLen
)
{
    size_t nTo = sTo.m_n;
    size_t nMove = 0;
    size_t nCopy = nTo;
    size_t i;

    if (nLen != nTo)
    {
        nMove = m_n - (nStart + nLen);
        if (LBUF_SIZE-1 < m_n + nTo - nLen)
        {
            if (LBUF_SIZE-1 < nStart + nTo)
            {
                nCopy = (LBUF_SIZE-1) - nStart;
                nMove = 0;
            }
            else
            {
                nMove = (LBUF_SIZE-1) - (nStart + nTo);
            }
        }
        if (nMove)
        {
            memmove(m_ach + nStart + nTo,
                    m_ach + nStart + nLen, nMove * sizeof(m_ach[0]));
        }
        m_n = nStart + nCopy + nMove;

        if (0 != m_ncs)
        {
            realloc_m_pcs(m_n);
            if (nMove)
            {
                memmove(m_pcs + nStart + nTo,
                        m_pcs + nStart + nLen, nMove * sizeof(m_pcs[0]));
            }
        }
        else if (0 != sTo.m_ncs)
        {
            realloc_m_pcs(m_n);
            for (i = 0; i < nStart; i++)
            {
                m_pcs[i] = CS_NORMAL;
            }
            for (i = 0; i < nMove; i++)
            {
                m_pcs[i+nStart+nTo] = CS_NORMAL;
            }
        }
    }

    memcpy(m_ach + nStart, sTo.m_ach, nCopy * sizeof(m_ach[0]));

    if (0 != sTo.m_ncs)
    {
        memcpy(m_pcs + nStart, sTo.m_pcs, nCopy * sizeof(m_pcs[0]));
    }
    else if (0 != m_ncs)
    {
        for (i = 0; i < nTo; i++)
        {
            m_pcs[nStart + i] = CS_NORMAL;
        }
    }

    m_ach[m_n] = '\0';
}

/*! \brief Reverses the string.
 *
 * \return         None.
 */

void mux_string::reverse(void)
{
    mux_string *sTemp = new mux_string;
    sTemp->realloc_m_pcs(m_ncs);

    size_t j = 0;
    for (size_t i = 1; i <= m_n; i++)
    {
        for (j = i; j <= m_n && UTF8_CONTINUE == utf8_FirstByte[m_ach[m_n - j]]; j++)
        {
            ; // Nothing.
        }
        sTemp->append(*this, m_n - j, j + 1 - i);
        i = j;
    }
    import(*sTemp);
    delete sTemp;
}

/*! \brief Searches text for a specified pattern.
 *
 * \param pPattern Pointer to pattern to search for.
 * \param nPos     Pointer to value of position in string where pattern
                   is found.
 * \param nStart   Position in string to begin looking at. Defaults to 0.
 * \return         True if found, false if not.
 */

bool mux_string::search
(
    const UTF8 *pPattern,
    size_t *nPos,
    size_t nStart
) const
{
    // Strip ANSI from pattern.
    //
    size_t nPat = 0;
    UTF8 *pPatBuf = strip_color(pPattern, &nPat);
    const UTF8 *pTarget = m_ach + nStart;

    size_t i = 0;
    bool bSucceeded = false;
    if (nPat == 1)
    {
        // We can optimize the single-character case.
        //
        const unsigned char *p = (const unsigned char *)memchr(pTarget, pPatBuf[0], m_n - nStart);
        if (p)
        {
            i = p - pTarget;
            bSucceeded = true;
        }
    }
    else if (nPat > 1)
    {
        // We have a multi-byte pattern.
        //
        bSucceeded = BMH_StringSearch(&i, nPat, pPatBuf,
                                      m_n - nStart, pTarget);
    }

    if (nPos)
    {
        *nPos = i;
    }
    return bSucceeded;
}

/*! \brief Searches text for a specified pattern.
 *
 * \param sPattern Reference to string to search for.
 * \param nPos     Pointer to value of position in string where pattern
                   is found.
 * \param nStart   Position in string to begin looking at. Defaults to 0.
 * \return         True if found, false if not.
 */

bool mux_string::search
(
    const mux_string &sPattern,
    size_t *nPos,
    size_t nStart
) const
{
    // Strip ANSI from pattern.
    //
    const UTF8 *pTarget = m_ach + nStart;

    size_t i = 0;
    bool bSucceeded = false;
    if (1 == sPattern.m_n)
    {
        // We can optimize the single-character case.
        //
        const unsigned char *p = (const unsigned char *)memchr(pTarget, sPattern.m_ach[0], m_n - nStart);
        if (p)
        {
            i = p - pTarget;
            bSucceeded = true;
        }
    }
    else
    {
        // We have a multi-byte pattern.
        //
        bSucceeded = BMH_StringSearch(&i, sPattern.m_n, sPattern.m_ach,
                                      m_n - nStart, pTarget);
    }

    if (nPos)
    {
        *nPos = i;
    }
    return bSucceeded;
}

void mux_string::set_Char(size_t n, const UTF8 cChar)
{
    if (m_n <= n)
    {
        return;
    }
    m_ach[n] = cChar;
}

void mux_string::set_Color(size_t n, ColorState csColor)
{
    if (m_n <= n)
    {
        return;
    }
    if (  0 == m_ncs
       && csColor != CS_NORMAL)
    {
        realloc_m_pcs(m_n);
        for (LBUF_OFFSET i = 0; i < m_n; i++)
        {
            m_pcs[i] = CS_NORMAL;
        }
    }
    if (0 != m_ncs)
    {
        m_pcs[n] = csColor;
    }
}

/*! \brief Removes a specified set of characters from string.
 *
 * \param pStripSet Pointer to string of characters to remove.
 * \param nStart    Position in string to begin checking. Defaults to 0.
 * \param nLen      Number of characters in string to check.
                    Defaults to LBUF_SIZE-1.
 * \return          None.
 */

void mux_string::strip(const UTF8 *pStripSet, size_t nStart, size_t nLen)
{
    static bool strip_table[UCHAR_MAX+1];

    if (  NULL == pStripSet
       || '\0' == pStripSet[0]
       || m_n <= nStart
       || 0 == nLen)
    {
        // Nothing to do.
        //
        return;
    }

    if (m_n-nStart < nLen)
    {
        nLen = m_n-nStart;
    }

    // Load set of characters to strip.
    //
    memset(strip_table, false, sizeof(strip_table));
    while (*pStripSet)
    {
        strip_table[(unsigned char)*pStripSet] = true;
        pStripSet++;
    }
    stripWithTable(strip_table, nStart, nLen);
}

void mux_string::stripWithTable
(
    const bool strip_table[UCHAR_MAX+1],
    size_t nStart,
    size_t nLen
)
{
    if (  m_n <= nStart
       || 0 == nLen)
    {
        // Nothing to do.
        //
        return;
    }

    if (m_n-nStart < nLen)
    {
        nLen = m_n-nStart;
    }

    bool bInStrip = false;
    size_t nStripStart = nStart;
    for (size_t i = nStart; i < nStart + nLen; i++)
    {
        if (  !bInStrip
           && strip_table[m_ach[i]])
        {
            bInStrip = true;
            nStripStart = i;
        }
        else if (  bInStrip
                && !strip_table[m_ach[i]])
        {
            // We've hit the end of a string to be stripped.
            //
            size_t nStrip = i - nStripStart;
            delete_Chars(nStripStart, nStrip);
            i -= nStrip;
            bInStrip = false;
        }
    }

    if (bInStrip)
    {
        if (m_n == nStart+nLen)
        {
            // We found chars to strip at the end of the string.
            // We can just truncate.
            //
            m_ach[nStripStart] = '\0';
            m_n = nStripStart;
        }
        else
        {
            size_t nStrip = nStart + nLen - nStripStart;
            delete_Chars(nStripStart, nStrip);
        }
    }
}

void mux_string::transform
(
    mux_string &sFromSet,
    mux_string &sToSet,
    size_t nStart,
    size_t nLen
)
{
    static unsigned char asciiTable[SCHAR_MAX+1];

    if (m_n <= nStart)
    {
        return;
    }
    else if (m_n - nStart < nLen)
    {
        nLen = m_n - nStart;
    }

    // Set up table.
    //
    for (unsigned char c = 0; c <= SCHAR_MAX; c++)
    {
        asciiTable[c] = c;
    }

    unsigned char cFrom, cTo;
    size_t nSet = sFromSet.m_n;
    if (sToSet.m_n < nSet)
    {
        nSet = sToSet.m_n;
    }
    size_t nUTF = 0;
    for (size_t i = 0; i < nSet; i++)
    {
        cFrom = sFromSet.m_ach[i];
        cTo = sToSet.m_ach[i];
        if (  mux_isprint_ascii(cFrom)
           && mux_isprint_ascii(cTo))
        {
            asciiTable[cFrom] = cTo;
        }
        else
        {
            nUTF++;
        }
    }
    // TODO: transform_UTF8
    //
    //if (0 == nUTF)
    //{
        transform_Ascii(asciiTable, nStart, nLen);
    //}
    //else
    //{
    //    transform_UTF8(sFromSet, sToSet, asciiTable, nUTF, nStart, nLen);
    //}
}

void mux_string::transform_Ascii
(
    const unsigned char asciiTable[SCHAR_MAX+1],
    size_t nStart,
    size_t nLen
)
{
    if (m_n <= nStart)
    {
        return;
    }
    else if (m_n - nStart < nLen)
    {
        nLen = m_n - nStart;
    }

    for (size_t i = nStart; i < nStart + nLen; i++)
    {
        if (mux_isprint_ascii(m_ach[i]))
        {
            m_ach[i] = asciiTable[m_ach[i]];
        }
    }
}

void mux_string::trim(const UTF8 ch, bool bLeft, bool bRight)
{
    if (  0 == m_n
       || (  !bLeft
          && !bRight ))
    {
        return;
    }

    if (bRight)
    {
        size_t iPos = m_n - 1;
        while (  ch == m_ach[iPos]
              && 0 < iPos)
        {
            iPos--;
        }

        if (iPos < m_n - 1)
        {
            m_n = iPos + 1;
            m_ach[m_n] = '\0';
        }
    }

    if (bLeft)
    {
        size_t iPos = 0;
        while (  ch == m_ach[iPos]
              && iPos < m_n)
        {
            iPos++;
        }

        if (0 < iPos)
        {
            delete_Chars(0, iPos);
        }
    }
}

void mux_string::trim(const UTF8 *p, bool bLeft, bool bRight)
{
    if (  0 == m_n
       || NULL == p
       || '\0' == p[0]
       || (  !bLeft
          && !bRight ))
    {
        return;
    }

    size_t n = strlen((char *)p);

    if (1 == n)
    {
        trim(p[0], bLeft, bRight);
        return;
    }
    else
    {
        trim(p, n, bLeft, bRight);
    }
}

void mux_string::trim(const UTF8 *p, size_t n, bool bLeft, bool bRight)
{
    if (  0 == m_n
       || NULL == p
       || 0 == n
       || m_n < n
       || (  !bLeft
          && !bRight ))
    {
        return;
    }

    if (bRight)
    {
        size_t iPos = m_n - 1;
        size_t iDist = n - 1;
        while (  p[iDist] == m_ach[iPos]
              && 0 < iPos)
        {
            iPos--;
            iDist = (0 < iDist) ? iDist - 1 : n - 1;
        }

        if (iPos < m_n - 1)
        {
            m_n = iPos + 1;
            m_ach[m_n] = '\0';
        }
    }

    if (bLeft)
    {
        size_t iPos = 0;
        while (  p[iPos % n] == m_ach[iPos]
              && iPos < m_n)
        {
            iPos++;
        }

        if (0 < iPos)
        {
            delete_Chars(0, iPos);
        }
    }
}

void mux_string::truncate(size_t nLen)
{
    if (m_n <= nLen)
    {
        return;
    }
    m_n = nLen;
    m_ach[m_n] = '\0';
}

mux_words::mux_words(const mux_string &sStr) : m_s(&sStr)
{
    m_aiWordBegins[0] = 0;
    m_aiWordEnds[0] = 0;
    m_nWords = 0;
}

void mux_words::export_WordAnsi(LBUF_OFFSET n, UTF8 *buff, UTF8 **bufc)
{
    if (m_nWords <= n)
    {
        return;
    }

    size_t iStart = m_aiWordBegins[n];
    size_t nLen = m_aiWordEnds[n] - iStart;
    m_s->export_TextAnsi(buff, bufc, iStart, nLen);
}

LBUF_OFFSET mux_words::find_Words(void)
{
    LBUF_OFFSET n = static_cast<LBUF_OFFSET>(m_s->m_n);
    LBUF_OFFSET nWords = 0;
    bool bPrev = true;

    for (LBUF_OFFSET i = 0; i < n; i++)
    {
        if (  !bPrev
           && m_aControl[m_s->m_ach[i]])
        {
            bPrev = true;
            m_aiWordEnds[nWords] = i;
            nWords++;
        }
        else if (bPrev)
        {
            bPrev = false;
            m_aiWordBegins[nWords] = i;
        }
    }
    if (!bPrev)
    {
        m_aiWordEnds[nWords] = n;
        nWords++;
    }
    m_nWords = nWords;
    return m_nWords;
}

LBUF_OFFSET mux_words::find_Words(const UTF8 *pDelim)
{
    size_t nDelim = 0;
    pDelim = strip_color(pDelim, &nDelim);

    size_t iPos = 0;
    LBUF_OFFSET iStart = 0;
    LBUF_OFFSET nWords = 0;
    bool bSucceeded = m_s->search(pDelim, &iPos, iStart);

    while (  bSucceeded
          && nWords + 1 < MAX_WORDS)
    {
        m_aiWordBegins[nWords] = iStart;
        m_aiWordEnds[nWords] = static_cast<LBUF_OFFSET>(iStart + iPos);
        nWords++;
        iStart = static_cast<LBUF_OFFSET>(iStart + iPos + nDelim);
        bSucceeded = m_s->search(pDelim, &iPos, iStart);
    }
    m_aiWordBegins[nWords] = iStart;
    m_aiWordEnds[nWords] = static_cast<LBUF_OFFSET>(m_s->m_n);
    nWords++;
    m_nWords = nWords;
    return nWords;
}
#endif

void mux_words::ignore_Word(LBUF_OFFSET n)
{
    if (m_nWords <= n)
    {
        return;
    }

    for (LBUF_OFFSET i = n; i < m_nWords - 1; i++)
    {
        m_aiWordBegins[i] = m_aiWordBegins[i + 1];
        m_aiWordEnds[i] = m_aiWordEnds[i + 1];
    }
    m_nWords--;
}

void mux_words::set_Control(const UTF8 *pControlSet)
{
    if (  NULL == pControlSet
       || '\0' == pControlSet[0])
    {
        // Nothing to do.
        //
        return;
    }

    // Load set of characters.
    //
    memset(m_aControl, false, sizeof(m_aControl));
    while (*pControlSet)
    {
        m_aControl[(unsigned char)*pControlSet] = true;
        pControlSet++;
    }
}

void mux_words::set_Control(const bool table[UCHAR_MAX+1])
{
    memcpy(m_aControl, table, sizeof(table));
}

LBUF_OFFSET mux_words::wordBegin(LBUF_OFFSET n) const
{
    if (m_nWords <= n)
    {
        return 0;
    }

    return m_aiWordBegins[n];
}

LBUF_OFFSET mux_words::wordEnd(LBUF_OFFSET n) const
{
    if (m_nWords <= n)
    {
        return 0;
    }

    return m_aiWordEnds[n];
}
