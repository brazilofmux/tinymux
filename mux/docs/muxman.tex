\documentclass[dvips]{book}
\usepackage{graphicx}
\usepackage{times}
\setlength{\oddsidemargin}{0.5in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6in}
\title{TinyMUX 2.0 Manual}
\author{Stephen Dennis (AKA Brazil)}
\date{2001-MAR-04}
\begin{document}
\frontmatter
\maketitle

\begin{minipage}[t]{0.64in}
\includegraphics[height=0.98in]{latticeS.ps}
\end{minipage}
\begin{minipage}[t]{2.75in}
\vspace{-0.90in}
\LARGE{Solid Vertical Domains, Ltd.}\\
\rule{2.75in}{0.02in}\\
\normalsize PMB 624\\
11410 NE 124TH ST\\
KIRKLAND WA 98034-4305
\end{minipage}

\mainmatter
\chapter{Introduction}
\section{Philosophy of this Document}
There is no single author to this document --- only an editor. There is an
overarching structure to the document, but otherwise, changes by everyone are
welcome. Please do your part to make it better.

Things are first broken down into views or perspectives that cater to a
particular type of reader at a particular experience or skill level and look
at the subject under discussion from a particular angle. I ask that top-level
divisions be chosen that way. Sub-divisions from there are much more flexible.
Some redundancy between perspectives is unavoidable. With an index, this
redundancy can help to pull the document together.
\section{Let's Begin}
There seem to be two good ways to begin:
\begin{enumerate}
\item
Find an expert to answer all your questions and prompt you for the questions
you would be asking if you even knew where to start.
\item
Do some research on your own and learn by quiet trial-and-error.
\end{enumerate}
There are advantages and disadvantages to both approaches. I recommend that
you rely on yourself and use the experts sparingly in specific areas as a way
to accelerate yourself through those specific issues. Always be prepared and
ready to find your own way.

There are only so many experts and their expertise may be narrow. Even experts
in the same area are known to disagree --- in fact, usually these experts
aren't talking to each other unless they are talking about something they don't
know about yet or they are disagreeing. You have little way of knowing whether
someone is an expert until you are already all wrapped up in their advice and
the political baggage they may carry with them. You may even need to put
yourself into the awkward position of having to motivate one of these experts
to help you. Enough said about that.

Solitary reading and trial-and-error has its own problems. Documentation that
is available is both limited and out of date. In order to get a good idea of
what you're dealing with, you may need to splice together information from
several
sources. It is easy to get stuck on a small point and waste a lot of time.
Also, these game servers are large enough and complicated enough that
experimentation without the advantage of some experience or history can be
nearly impossible.
\chapter{New to TinyMUX}
\section{Frequently Asked Questions (FAQ)}
\subsection{What is a Text-Based Game Server?}
It is a program that allows a multitude of people to connect to the same
text-based environment and interact with each other and with the environment.
The administrator runs this server on top of an operating system and the server
in turn allows other people to connect. % See Figure 1 below.

These layers are written in a particular computer language. The hardware
layers have their own C-like language for describing how a body of gates are
connected logically, geographical, thermally, etc.  Most operating systems are
written in C/C++ with some assembly language and some higher-level scripting
or macro languages. This is also sometimes called hardcode.

The term \emph{hardcode} usually means the approximately 75,000 lines of C/C++
source code that make up the game server itself.
All of the MUSH-type text-based game servers are written in C except MUX 2.0
which is a combination of C and C++.

However, the term can also be used more generically to refer to anything
written in C/C++ or even to anything written in a general purpose programming
language.

All of the Softcode Global Packages are written in a mostly universal language
that doesn't have a name. You could call it MUSHcode, but then you are probably
referring to the commands and functions of a specific version of a specific
server. You could call
it softcode, but then you are also probably including non-MUSH family languages
further away and more incompatible. For the purpose of this document, we'll
call it softcode with the understanding that we expect it to run on a particular
set of closely related servers and on TinyMUX 2.0 in particular.

\section{I'm using Windows. Why does the log say it can't find it's files?}
You are probably running the tinymux.exe file directly from the GUI by double
clicking on the icon. The server needs the current directory to be the game
sub-directory. All the file names are relative to that point, but when you
double-click on the tinymux.exe program directly, the current directory might
be the game$\backslash$bin or tinymux$\backslash$release directory, or it
might be somewhere else.  The current directory is too undefined for the game
to be run this way.

You should open a Command Prompt window (that is, an MS-DOS box), change to
the drive and `mux2.0$\backslash$game' sub-directory where you extracted the
distribution, make sure the tinymux.exe, a.exe, dbconvert.exe, and mkindx.exe
programs are in the `bin' sub-directory, and then run the startmux.bat batch
file.
\section{How to Begin Running TinyMUX}
The first thing you'll need is some server hardware with some flavor of Unix or
Windows running. It's more than a little helpful if this server has a dedicated
Internet or Intranet connection, as without it, you'll be using it by yourself.

You need to find the latest known-good distribution from
www.tinymux.com and download it. If you are using a web browser, it will
download it in `binary' mode for you automatically, however, if you use an FTP
client manually, you'll need to be sure to put the transfer into binary. Even
between Unix machines, Non-binary transfers can be problematic.

Here is a typical manual FTP conversation:
\footnotesize{\texttt{
\begin{verse}
\$ \emph{ftp svdltd.com}\\
Connected to svdltd.com.\\
220 sdennis0 Microsoft FTP Service (Version 4.0).\\
User (svdltd.com:(none)): \emph{anonymous}\\
331 Anonymous access allowed, send identity (e-mail name) as password.\\
Password: \emph{sdennis@svdltd.com}\\
230-Welcome to Solid Vertical Domains, Ltd.\\
230 Anonymous user logged in.\\
ftp$>$ \emph{cd TinyMUX}\\
250 CWD command successful.\\
ftp$>$ \emph{binary}\\
200 Type set to I.\\
ftp$>$ \emph{ls *.tar.gz}\\
200 PORT command successful.\\
150 Opening ASCII mode data connection for file list.\\
miam.tar.gz\\
mux2.0-B1.tar.gz\\
mux2.0-B2.tar.gz\\
mux2.0-B3.tar.gz\\
mux2.0-B4.tar.gz\\
mux2.0-B5.tar.gz\\
mux2.0-B6.tar.gz\\
mux2.0-B7.tar.gz\\
226 Transfer complete.\\
139 bytes received in 0.03 seconds (4.48 Kbytes/sec)\\
ftp$>$ \emph{get mux2.0-B7.tar.gz}\\
200 PORT command successful.\\
150 Opening BINARY mode data connection for mux2.0-B7.tar.gz(655702 bytes).\\
226 Transfer complete.\\
655702 bytes received in 0.09 seconds (6975.55 Kbytes/sec)\\
ftp$>$ \emph{quit}\\
221 Goodbye from Solid Vertical Domains, Ltd.\\
\$
\end{verse}
}}
The suffixes on the end of the filename tell you which tools were used to
produce the file and in which order. Gzip handles `.gz' files, and tar handled
`.tar' files. So in order to unpack this distribution, we do the following:
\footnotesize{\texttt{
\begin{verse}
\$ \emph{gzip -d mux2.0-B7.tar.gz}\\
\$ \emph{tar xvf mux2.0-B7.tar}
\end{verse}
}}
These two commands will create a sub-directory called `mux2.0' with all the
required files in the right places. So, in order to build the game, continue
as follows:
\footnotesize{\texttt{
\begin{verse}
\$ \emph{cd mux2.0/src}\\
\$ \emph{./Configure}\\
\$ \emph{make}
\end{verse}
}}
On some system `gmake' is required instead of `make'. At the end of this
process, you should have executable programs built in the mux2.0/src directory
with links made to the mux2.0/game/bin directory. A link in Unix parlance is
another name for the same file contents.

At this point, if you don't have an existing database to convert or import,
and if you don't have any configuration changes, you could simply run the
server and it would create a minimal database and let you connect to port
2860. This can be done as follows:
\footnotesize{\texttt{
\begin{verse}
\$ \emph{cd ../game}\\
\$ \emph{./Startmux}
\end{verse}
}}
The Startmux script will do a few things like index the help files and then
return to the \$-prompt again. You can verify that the server is running as
follows:
\footnotesize{\texttt{
\begin{verse}
\$ \emph{ps u}
\end{verse}
}}
You will see two processes, a netmux game process and a slave process that
handled reverse DNS lookups and the identd protocol for hosts that support
it. To connect to the game, do the following:
\footnotesize{\texttt{
\begin{verse}
\$ \emph{telnet localhost 2860}
\end{verse}
}}
You will see the connect.txt welcome screen contents and then the server will
wait for you to connect or logon. With a minimal database, there is only one
player defined: Wizard or \#1. And, there is only one room defined: Limbo or
\#0. The initial password for \#1 is something of a standard everywhere. You
should change it right away with the `@password' command. Do the following:
\footnotesize{\texttt{
\begin{verse}
Connect Wizard potrzebie\\
@password potrzebie=XXXXXXXX
\end{verse}
}}
where XXXXXX is a password of your own chosing.

Use `help @password' to learn more about the @password command, and
`help topic' if you need help on a command, function, or class of
functions.

Finally, at some point, you'll want to bring the game down in an orderly way.
People have stepped over the power cord and other non-orderly ways of bringing
the game down, but `@shutdown' is recommended instead as follows:
\footnotesize{\texttt{
\begin{verse}
\emph{@shutdown}\\
Goodbye.\\
Connection Lost.\\
\$
\end{verse}
}}
The database is quite rugged, but there are no guarantees if you make a
habit of abusing it.

Finally, buy a UPS. Backup, off-line. Do it. If you use Window NT, configure
it, and then leave the server alone. WinNT works best if you give it good
hardware, good drivers, a set of services to run, and then leave it alone
to serve.
\chapter{Configuration}
\section{Basic Configuration}
The game server reads from a configuration file when the game server starts or
restarts, but changing a configuration file while the game is running does not
change a running game's behavior. To accomplish that, look at the `@admin' or
`@restart' commands.

The name of the configuration file is given in the ./Startmux script on the
command line and it's netmux.conf for Unix installations and tinymux.conf for
Win32 installations.

If you look at this file, you'll see several lines with `include' in them.
Including a sub-configuration file is the same as if the contents were
present in the top-level configuration file.

Everything in a configuration file is handled as if \#1 (Wizard) did it.
\section{Site-Banning}
\subsection{Overview}
The following configuration options are used to restrict a player's access
based on their IP address:
\begin{itemize}
\item
\texttt{register\_site} allows existing players to connect to their
characters, but does not allow players from the specified subnet to create
new characters.
\item
\texttt{forbid\_site} disallows any connection and doesn't even show the
welcome screen.
\item
\texttt{allow\_guest\_from\_registered\_site $<$yes$|$no$>$.}  Default is
\texttt{yes}. This configuration option allows the \texttt{register\_site}
subnet list to control the ability of guests to connect from those sites as
well.
\item A future version of MUX will also include the \texttt{guest\_site}
configuration option. That option allows and requires the administrator to
manage the guest restrictions separately.
\end{itemize}
For register-only games, the administrator typically uses
\texttt{register\_site} to encompass the entire Internet (0.0.0.0 0.0.0.0).
In this case, it is more convenient to leave
\texttt{allow\_guest\_from\_registered\_site} at its default value of
\texttt{yes}, and then use \texttt{guest\_site} or \texttt{forbid\_site} to
control problem guests.

For open games that allow characters to be created at the initial welcome
screen, it is more convenient to turn\\
\texttt{allow\_guest\_from\_registered\_site} off, and then use
\texttt{register\_site} exclusively to control problem players and problem
guests. This allows players from that subnet to connect to existing
characters, but disallow them from creating new ones or from connecting as
guest.

So, the usefulness of the \texttt{forbid\_site} configuration option is
already narrow, and it continues to narrow further.

Also, remember that none of these configuration options are saved between
\texttt{@shutdown} or \texttt{@restart} and they need to be added to the
configuration file or appear on \#1's \texttt{STARTUP} attribute. However,
I would recommend against putting these commands on the \#1's \texttt{STARTUP}
attribute.
\subsection{Guessing the SubNet}
In order for the above restrictions to be useful, you need to guess the
player's subnet, and realize that a single player may be connecting from
different subnets and therefore each subnet that they connect from must be
dealt with separately.

Each shell account that a player uses to connect to the game will be on it's
own subnet. In some ways these are easy to deal with because these servers
can be expected to have a single static IP addresses, but it's not
guaranteed.

And large Internet Service Providers (ISPs) like AOL have subnets for each
service access number. So, if someone calls a particular local phone number
and logs into AOL, they are assigned an IP dynamically from a large static
pool. If they are willing to make a long-distance phone call to another
service access number, they may get an IP from a different large static
pool.

You must deal with the entire static pool for a particular service access
number. If they call a different service access number, then that will
represent a yet another subnet that needs to be handled separately as it will
probably not be adjacent numerically to their primary one.
\subsection{Example of Guessing}
Not that I want anyone to restrict my subnet, but let's take it as an example.
If I connect to a game, you will usually see 207.153.135.132 as the host name
if the server is running on Unix, and SDENNIS5 if the server is running on
Win32\footnote{Unix and NT both do reverse-DNS lookups. However, if no DNS
PTR entry exists, Windows does at extra step. It will query the client
machine for a NETBIOS name (which is also known as your computer name, and
can be found under your network settings). This NETBIOS name is unique
across an NT domain and across a NETBEUI subnet, but in a TCP/IP context,
it is not necessarily unique, and it's not possible to map from that NETBIOS
name back to a numerical IP.}.

You might also see me connect from svdltd.com or mirror.svdltd.com, and so,
for the sake of this example, you have three IP addresses that are close and
therefore they are probably within the same subnet. It's a fair guess.

\footnotesize{\texttt{
\begin{verse}
$>$ \emph{ping -a svdltd.com}\\
Pinging svdltd.com [207.153.135.130] with 32 bytes of data.\\
\ldots\\
$>$ \emph{ping -a 207.135.135.132}\\
Pinging SDENNIS5 [207.153.135.132] with 32 bytes of data.\\
\ldots\\
$>$ \emph{ping -a 207.135.135.134}\\
Pinging 207.153.135.134 with 32 bytes of data.\\
\ldots
\end{verse}
}}

And now, we need to convert from decimal, to hexadecimal, to binary as
follows:
\begin{verse}
130 ==> 0x82 ==> 1000.0010 binary.\\
132 ==> 0x84 ==> 1000.0100 binary.\\
134 ==> 0x86 ==> 1000.0110 binary.
\end{verse}
So, the subnet is at least the lower three binary digits because those three
digits are the only ones that are changing. Let's try a different fourth bit
and see if the hostname changes. That is, 1000.1001 binary ==> 137.
\footnotesize{\texttt{
\begin{verse}
$>$ \emph{ping -a 207.153.135.137}\\
\ldots\\
request timed out.
\ldots
\end{verse}
}}
And, for my subnet, it's hard to find another computer nearby. It turns out
that the lower 4 binary digits are within my subnet, but you couldn't guess
that unless one of my computers had allocated one of the higher IP addresses
from the local DHCP service. DHCP tends to assign IP numbers from lower to
higher, and it also tends to renew the same IP address to the same device.

Since, there wasn't a computer nearby, you might choose the lower four bits
anyway, but for this example, we'll proceed with the assumption that the
subnet is defined uniquely by the upper 29 bits and that the lower 3 bits are
used for devices within the subnet.
\subsection{What is the Base IP and Mask?}

The Base IP address for the above example is determined by zeroing out lower
three bits of an IP address out (e.g., 1000.0\underline{000} binary or 128).
The Base IP address is 207.153.135.128.

The mask is determined by setting all bits `one' except for the lower 3 bits
which are `zero' (e.g., the last byte of the IP address is
1111.1\underline{000} binary or 248). The mask for our example subnet is
255.255.255.248.

Another way of specifying the mask is to use a slash followed by a number
from 0 to 32 (`/N'). N is the number of `one' bits in the mask, or
equivalently, how many bits of the base IP address are significant - 29 in
our example.
\subsection{MUX commands}
You can apply the \texttt{register\_site} restriction to the desired subnet
with either of the following commands, but the second format is the preferred
format:
\footnotesize{\texttt{{
\begin{verse}
@admin register\_site=207.153.135.128 255.255.255.248\\
@admin register\_site=207.153.135.128/29
\end{verse}
}}
The 29 at the end represents the number of significant bits in the base subnet
address.
\backmatter
\end{document}
